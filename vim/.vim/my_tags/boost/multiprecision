!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BINARY_OP_FUNCTOR	/usr/include/boost/multiprecision/detail/default_ops.hpp	1491;"	d
BINARY_OP_FUNCTOR	/usr/include/boost/multiprecision/detail/default_ops.hpp	1897;"	d
BOOST_MATH_BIG_NUM_BASE_HPP	/usr/include/boost/multiprecision/detail/number_base.hpp	7;"	d
BOOST_MATH_BIG_NUM_DEF_OPS	/usr/include/boost/multiprecision/detail/default_ops.hpp	7;"	d
BOOST_MATH_BN_MPFR_HPP	/usr/include/boost/multiprecision/mpfr.hpp	7;"	d
BOOST_MATH_CONCEPTS_ER_HPP	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	7;"	d
BOOST_MATH_ER_GMP_BACKEND_HPP	/usr/include/boost/multiprecision/gmp.hpp	7;"	d
BOOST_MATH_EXTENDED_REAL_HPP	/usr/include/boost/multiprecision/number.hpp	7;"	d
BOOST_MATH_MP_TOMMATH_BACKEND_HPP	/usr/include/boost/multiprecision/tommath.hpp	7;"	d
BOOST_MATH_RATIONAL_ADAPTER_HPP	/usr/include/boost/multiprecision/rational_adapter.hpp	7;"	d
BOOST_MP_BIG_LANCZOS	/usr/include/boost/multiprecision/detail/big_lanczos.hpp	8;"	d
BOOST_MP_COMPARE_HPP	/usr/include/boost/multiprecision/detail/number_compare.hpp	7;"	d
BOOST_MP_CPP_DEC_FLOAT_BACKEND_HPP	/usr/include/boost/multiprecision/cpp_dec_float.hpp	17;"	d
BOOST_MP_CPP_INT_ADD_HPP	/usr/include/boost/multiprecision/cpp_int/add.hpp	9;"	d
BOOST_MP_CPP_INT_BIT_HPP	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	9;"	d
BOOST_MP_CPP_INT_CHECKED_HPP	/usr/include/boost/multiprecision/cpp_int/checked.hpp	7;"	d
BOOST_MP_CPP_INT_COMPARISON_HPP	/usr/include/boost/multiprecision/cpp_int/comparison.hpp	9;"	d
BOOST_MP_CPP_INT_CORE_HPP	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	7;"	d
BOOST_MP_CPP_INT_DIV_HPP	/usr/include/boost/multiprecision/cpp_int/divide.hpp	9;"	d
BOOST_MP_CPP_INT_HPP	/usr/include/boost/multiprecision/cpp_int.hpp	7;"	d
BOOST_MP_CPP_INT_LIM_HPP	/usr/include/boost/multiprecision/cpp_int/limits.hpp	9;"	d
BOOST_MP_CPP_INT_MISC_HPP	/usr/include/boost/multiprecision/cpp_int/misc.hpp	9;"	d
BOOST_MP_CPP_INT_MUL_HPP	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	9;"	d
BOOST_MP_DIGITS_HPP	/usr/include/boost/multiprecision/detail/digits.hpp	7;"	d
BOOST_MP_ENABLE_IF_WORKAROUND	/usr/include/boost/multiprecision/mpfr.hpp	1243;"	d
BOOST_MP_ENABLE_IF_WORKAROUND	/usr/include/boost/multiprecision/mpfr.hpp	1245;"	d
BOOST_MP_ENABLE_IF_WORKAROUND	/usr/include/boost/multiprecision/mpfr.hpp	1262;"	d
BOOST_MP_ET_OPS_HPP	/usr/include/boost/multiprecision/detail/et_ops.hpp	7;"	d
BOOST_MP_EXPLICIT_CONVERTIBLE_HPP	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	8;"	d
BOOST_MP_FORCEINLINE	/usr/include/boost/multiprecision/detail/number_base.hpp	23;"	d
BOOST_MP_FORCEINLINE	/usr/include/boost/multiprecision/detail/number_base.hpp	25;"	d
BOOST_MP_GENERIC_INTERCONVERT_HPP	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	7;"	d
BOOST_MP_INTEGER_HPP	/usr/include/boost/multiprecision/integer.hpp	7;"	d
BOOST_MP_INT_FUNC_HPP	/usr/include/boost/multiprecision/detail/integer_ops.hpp	7;"	d
BOOST_MP_MIN_EXPONENT_DIGITS	/usr/include/boost/multiprecision/detail/number_base.hpp	510;"	d
BOOST_MP_MIN_EXPONENT_DIGITS	/usr/include/boost/multiprecision/detail/number_base.hpp	512;"	d
BOOST_MP_MOVE	/usr/include/boost/multiprecision/detail/number_base.hpp	94;"	d
BOOST_MP_MOVE	/usr/include/boost/multiprecision/detail/number_base.hpp	96;"	d
BOOST_MP_MR_HPP	/usr/include/boost/multiprecision/miller_rabin.hpp	7;"	d
BOOST_MP_NO_DOUBLE_LIMB_TYPE_IO	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	84;"	d
BOOST_MP_NO_ET_OPS_HPP	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	7;"	d
BOOST_MP_RANDOM_HPP	/usr/include/boost/multiprecision/random.hpp	9;"	d
BOOST_MP_RESTRICTED_CONVERSION_HPP	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	8;"	d
BOOST_MP_TOMMATH_BIT_OP_CHECK	/usr/include/boost/multiprecision/tommath.hpp	366;"	d
BOOST_MP_USING_ABS	/usr/include/boost/multiprecision/detail/number_base.hpp	88;"	d
BOOST_NOEXCEPT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
BOOST_NOEXCEPT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::cpp_int_base	access:public
BOOST_NOEXCEPT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_double_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
BOOST_NOEXCEPT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_double_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::cpp_int_base	access:public
BOOST_NOEXCEPT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
BOOST_NOEXCEPT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::cpp_int_base	access:public
BOOST_NOEXCEPT	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(gmp_float&& o) BOOST_NOEXCEPT : detail::gmp_float_imp<0>(static_cast<detail::gmp_float_imp<0>&&>(o)) {}$/;"	m	struct:boost::multiprecision::gmp_float	access:public
BOOST_NOEXCEPT	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(gmp_float&& o) BOOST_NOEXCEPT : detail::gmp_float_imp<digits10>(static_cast<detail::gmp_float_imp<digits10>&&>(o)) {}$/;"	m	struct:boost::multiprecision::backends::gmp_float	access:public
BOOST_NOEXCEPT	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(mpfr_float_backend&& o) BOOST_NOEXCEPT : detail::mpfr_float_imp<0, allocate_dynamic>(static_cast<detail::mpfr_float_imp<0, allocate_dynamic>&&>(o)) {}$/;"	m	struct:boost::multiprecision::backends::mpfr_float_backend	access:public
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE cpp_int_backend& operator = (const cpp_int_backend& o) BOOST_NOEXCEPT_IF((Checked == unchecked) && boost::is_void<Allocator>::value)$/;"	f	namespace:boost::multiprecision	signature:(Checked == unchecked) && boost::is_void<Allocator>::value
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE cpp_int_backend& operator = (cpp_int_backend&& o) BOOST_NOEXCEPT_IF(boost::is_void<Allocator>::value)$/;"	f	namespace:boost::multiprecision	signature:(boost::is_void<Allocator>::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE void do_assign_arithmetic(signed_limb_type i, const mpl::false_&) BOOST_NOEXCEPT_IF((Checked == unchecked))$/;"	f	namespace:boost::multiprecision	access:private	signature:(Checked == unchecked)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^      const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^      const limb_type& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^      const signed_limb_type& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^   eval_add(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const limb_type& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^   eval_decrement(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^   eval_increment(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^inline void add_unsigned(CppInt1& result, const CppInt2& a, const CppInt3& b) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^inline void add_unsigned(CppInt1& result, const CppInt2& a, const limb_type& o) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^inline void subtract_unsigned(CppInt1& result, const CppInt2& a, const CppInt3& b) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^inline void subtract_unsigned(CppInt1& result, const CppInt2& a, const limb_type& b) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^      double_limb_type s) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^   Op op) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<CppInt1>::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^   eval_left_shift(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, T s) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^   eval_right_shift(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, T s) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& r) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_abs(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_convert_to(R* result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& backend) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_convert_to(R* result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& backend) BOOST_NOEXCEPT_IF(is_arithmetic<R>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_arithmetic<R>::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& b) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const signed_double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const signed_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const signed_double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const signed_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isfinite BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isfinite BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isinf BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isinf BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isnan BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isnan BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isnormal BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isnormal BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int fpclassify BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int fpclassify BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/random.hpp	/^    result_type max BOOST_PREVENT_MACRO_SUBSTITUTION () const { return _max; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/random.hpp	/^    result_type min BOOST_PREVENT_MACRO_SUBSTITUTION () const { return _min; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/random.hpp	/^    static result_type max BOOST_PREVENT_MACRO_SUBSTITUTION ()$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/random.hpp	/^    static result_type min BOOST_PREVENT_MACRO_SUBSTITUTION ()$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
BOOST_RANDOM_DETAIL_ARITHMETIC_CONSTRUCTOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ARITHMETIC_CONSTRUCTOR(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, result_type, seed_arg)
BOOST_RANDOM_DETAIL_ARITHMETIC_SEED	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ARITHMETIC_SEED(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, result_type, seed_arg)
BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^        BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(param_type, lhs, rhs)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(param_type, lhs, rhs)
BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(independent_bits_engine, x, y)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, x, y)
BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(uniform_smallint, lhs, rhs)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(uniform_smallint, lhs, rhs)
BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^        BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, param_type, parm)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(is, param_type, parm)
BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, independent_bits_engine, r)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(is, independent_bits_engine, r)
BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, uniform_smallint, ud)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(is, uniform_smallint, ud)
BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^        BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, param_type, parm)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(os, param_type, parm)
BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, independent_bits_engine, r)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(os, independent_bits_engine, r)
BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, uniform_smallint, ud)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(os, uniform_smallint, ud)
BOOST_RANDOM_DETAIL_SEED_SEQ_CONSTRUCTOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_SEED_SEQ_CONSTRUCTOR(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, SeedSeq, seq)
BOOST_RANDOM_DETAIL_SEED_SEQ_SEED	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_SEED_SEQ_SEED(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, SeedSeq, seq)
BOOST_STATIC_ASSERT	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   BOOST_STATIC_ASSERT((cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10 == -cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10));$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10 == -cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10)
BOOST_STATIC_ASSERT	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   BOOST_STATIC_ASSERT((std::numeric_limits<T>::radix == 2) || (std::numeric_limits<T>::radix == 10));$/;"	p	struct:boost::multiprecision::detail::digits2	access:public	signature:(std::numeric_limits<T>::radix == 2) || (std::numeric_limits<T>::radix == 10)
BOOST_STATIC_ASSERT	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   BOOST_STATIC_ASSERT(std::numeric_limits<T>::is_specialized);$/;"	p	struct:boost::multiprecision::detail::digits2	access:public	signature:(std::numeric_limits<T>::is_specialized)
BOOST_STATIC_ASSERT_MSG	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   BOOST_STATIC_ASSERT_MSG(boost::is_signed<ExponentType>::value, "ExponentType must be a signed built in integer type.");$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::is_signed<ExponentType>::value, Ó)
BOOST_STATIC_ASSERT_MSG	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_ASSERT_MSG(((sizeof(Allocator) == 0) && !is_void<Allocator>::value), "There is curently no support for unsigned arbitrary precision integers.");$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:((sizeof(Allocator) == 0) && !is_void<Allocator>::value), Ó
BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(bool, variable = false);$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(bool, variable = false)
BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(bool, variable = true);$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(bool, variable = true)
BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, max_limb_value = ~static_cast<limb_type>(0u));$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(limb_type, max_limb_value = ~static_cast<limb_type>(0u))
BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, max_limb_value = ~static_cast<limb_type>(0u));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(limb_type, max_limb_value = ~static_cast<limb_type>(0u))
BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, sign_bit_mask = 1u << (limb_bits - 1));$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(limb_type, sign_bit_mask = 1u << (limb_bits - 1))
BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, sign_bit_mask = 1u << (limb_bits - 1));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(limb_type, sign_bit_mask = 1u << (limb_bits - 1))
BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, upper_limb_mask = MinBits % limb_bits ? (limb_type(1) << (MinBits % limb_bits)) -1 : (~limb_type(0)));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(limb_type, upper_limb_mask = MinBits % limb_bits ? (limb_type(1) << (MinBits % limb_bits)) -1 : (~limb_type(0)))
BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, internal_limb_count = MinBits \/ limb_bits + (MinBits % limb_bits ? 1 : 0));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(unsigned, internal_limb_count = MinBits / limb_bits + (MinBits % limb_bits ? 1 : 0))
BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, internal_limb_count =$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(unsigned, internal_limb_count = MinBits ? MinBits / limb_bits + (MinBits % limb_bits ? 1 : 0) : sizeof(limb_data) / sizeof(limb_type))
BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT);$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT)
BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT);$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT)
HETERO_BINARY_OP_FUNCTOR	/usr/include/boost/multiprecision/detail/default_ops.hpp	1789;"	d
HETERO_BINARY_OP_FUNCTOR_B	/usr/include/boost/multiprecision/detail/default_ops.hpp	1733;"	d
INSTRUMENT_BACKEND	/usr/include/boost/multiprecision/detail/default_ops.hpp	19;"	d
INSTRUMENT_BACKEND	/usr/include/boost/multiprecision/detail/default_ops.hpp	21;"	d
UNARY_OP_FUNCTOR	/usr/include/boost/multiprecision/detail/default_ops.hpp	1429;"	d
UNARY_OP_FUNCTOR	/usr/include/boost/multiprecision/detail/default_ops.hpp	1898;"	d
_base	/usr/include/boost/multiprecision/random.hpp	/^    Engine _base;$/;"	m	class:boost::random::independent_bits_engine	access:private
_max	/usr/include/boost/multiprecision/random.hpp	/^        result_type _max;$/;"	m	class:boost::random::uniform_smallint::param_type	access:private
_max	/usr/include/boost/multiprecision/random.hpp	/^    result_type _max;$/;"	m	class:boost::random::uniform_smallint	access:private
_min	/usr/include/boost/multiprecision/random.hpp	/^        result_type _min;$/;"	m	class:boost::random::uniform_smallint::param_type	access:private
_min	/usr/include/boost/multiprecision/random.hpp	/^    result_type _min;$/;"	m	class:boost::random::uniform_smallint	access:private
a	/usr/include/boost/multiprecision/random.hpp	/^        result_type a() const { return _min; }$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:() const
a	/usr/include/boost/multiprecision/random.hpp	/^    result_type a() const { return _min; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
abs	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^abs(const detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& arg)
abs	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^abs(const number<Backend, et_off>& arg)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, et_off>& arg)
abs	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^abs(const number<Backend, et_on>& arg)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, et_on>& arg)
abs_funct	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^struct abs_funct$/;"	s	namespace:boost::multiprecision::detail
add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   add(number<B, ET>& result, const I& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, ET>& result, const I& a, const I& b)
add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline number<B1, ET1>& add(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
add	/usr/include/boost/multiprecision/integer.hpp	/^   add(Integer& result, const I2& a, const I2& b)$/;"	f	namespace:boost::multiprecision	signature:(Integer& result, const I2& a, const I2& b)
add_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct add_immediates{};$/;"	s	namespace:boost::multiprecision::detail
add_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& add_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
allocate_dynamic	/usr/include/boost/multiprecision/mpfr.hpp	/^   allocate_dynamic$/;"	e	enum:boost::multiprecision::mpfr_allocation_type
allocate_stack	/usr/include/boost/multiprecision/mpfr.hpp	/^   allocate_stack,$/;"	e	enum:boost::multiprecision::mpfr_allocation_type
allocator_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef typename Allocator::template rebind<limb_type>::other allocator_type;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
apply	/usr/include/boost/multiprecision/random.hpp	/^  struct apply$/;"	s	struct:boost::random::detail::select_uniform_01	access:public
arg	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg1>::type arg;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
arg1	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg1>::type arg1;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
arg2	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg2>::type arg2;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
arg3	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg3>::type arg3;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
arg4	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg4>::type arg4;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
arg_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct arg_type$/;"	s	namespace:boost::multiprecision::detail
arg_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct arg_type<expression<Tag, Arg1, Arg2, Arg3, Arg4> >$/;"	s	namespace:boost::multiprecision::detail
arity	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<0> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
arity	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<1> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
arity	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<2> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
arity	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<3> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
arity	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<4> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
array_type	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      >::type array_type;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:private
assign	/usr/include/boost/multiprecision/cpp_int.hpp	/^   void assign(const cpp_int_base& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_base& o)
assign	/usr/include/boost/multiprecision/number.hpp	/^   number& assign(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
assign_components	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void assign_components(T& result, const V& v1, const V& v2)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const V& v1, const V& v2)
assign_components	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline void assign_components(rational_adapter<IntBackend>& result, const V& v1, const V& v2)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adapter<IntBackend>& result, const V& v1, const V& v2)
assign_components_imp	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void assign_components_imp(T& result, const V& v1, const V& v2, const mpl::int_<number_kind_rational>&)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const V& v1, const V& v2, const mpl::int_<number_kind_rational>&)
b	/usr/include/boost/multiprecision/random.hpp	/^        result_type b() const { return _max; }$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:() const
b	/usr/include/boost/multiprecision/random.hpp	/^    result_type b() const { return _max; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
backend_type	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   typedef boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> backend_type;$/;"	t	class:std::numeric_limits	access:private
backend_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct backend_type<expression<tag, A1, A2, A3, A4> >$/;"	s	namespace:boost::multiprecision::detail
backend_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct backend_type<number<T, ExpressionTemplates> >$/;"	s	namespace:boost::multiprecision::detail
backend_type	/usr/include/boost/multiprecision/number.hpp	/^   typedef Backend backend_type;$/;"	t	class:boost::multiprecision::number	access:public
backends	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
backends	/usr/include/boost/multiprecision/cpp_int.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
backends	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
backends	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
backends	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{$/;"	n	namespace:boost::multiprecision
backends	/usr/include/boost/multiprecision/cpp_int/comparison.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
backends	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
backends	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
backends	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
backends	/usr/include/boost/multiprecision/gmp.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
backends	/usr/include/boost/multiprecision/mpfr.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
backends	/usr/include/boost/multiprecision/rational_adapter.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
backends	/usr/include/boost/multiprecision/tommath.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
base	/usr/include/boost/multiprecision/random.hpp	/^    const base_type& base() const { return _base; }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:() const
base_result	/usr/include/boost/multiprecision/random.hpp	/^    typedef typename base_type::result_type base_result;$/;"	t	class:boost::random::independent_bits_engine	access:private
base_type	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef std::numeric_limits<long double> base_type;$/;"	t	class:std::numeric_limits	access:private
base_type	/usr/include/boost/multiprecision/random.hpp	/^    typedef Engine base_type;$/;"	t	class:boost::random::independent_bits_engine	access:public
base_type	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef std::numeric_limits<boost::multiprecision::number<IntBackend> > base_type;$/;"	t	class:std::numeric_limits	access:private
base_unsigned	/usr/include/boost/multiprecision/random.hpp	/^    typedef typename make_unsigned<base_result>::type base_unsigned;$/;"	t	class:boost::random::independent_bits_engine	access:private
bit_and	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^struct bit_and{ limb_type operator()(limb_type a, limb_type b)const BOOST_NOEXCEPT { return a & b; } };$/;"	s	namespace:boost::multiprecision::backends
bit_flip	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   bit_flip(number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& x, unsigned index)
bit_flip	/usr/include/boost/multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer&>::type bit_flip(Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(Integer& val, unsigned index)
bit_or	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^struct bit_or { limb_type operator()(limb_type a, limb_type b)const BOOST_NOEXCEPT { return a | b; } };$/;"	s	namespace:boost::multiprecision::backends
bit_set	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   bit_set(number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& x, unsigned index)
bit_set	/usr/include/boost/multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer&>::type bit_set(Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(Integer& val, unsigned index)
bit_test	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   bit_test(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, unsigned index)
bit_test	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   bit_test(const number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, unsigned index)
bit_test	/usr/include/boost/multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, bool>::type bit_test(const Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& val, unsigned index)
bit_unset	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   bit_unset(number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& x, unsigned index)
bit_unset	/usr/include/boost/multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer&>::type bit_unset(Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(Integer& val, unsigned index)
bit_xor	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^struct bit_xor{ limb_type operator()(limb_type a, limb_type b)const BOOST_NOEXCEPT { return a ^ b; } };$/;"	s	namespace:boost::multiprecision::backends
bits_of	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bits_of$/;"	s	namespace:boost::multiprecision::detail
bits_per_limb	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^static const unsigned bits_per_limb = sizeof(limb_type) * CHAR_BIT;$/;"	m	namespace:boost::multiprecision
bitwise_and	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bitwise_and{};$/;"	s	namespace:boost::multiprecision::detail
bitwise_and_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bitwise_and_immediates{};$/;"	s	namespace:boost::multiprecision::detail
bitwise_complement	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bitwise_complement{};$/;"	s	namespace:boost::multiprecision::detail
bitwise_or	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bitwise_or{};$/;"	s	namespace:boost::multiprecision::detail
bitwise_or_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bitwise_or_immediates{};$/;"	s	namespace:boost::multiprecision::detail
bitwise_xor	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bitwise_xor{};$/;"	s	namespace:boost::multiprecision::detail
bitwise_xor_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bitwise_xor_immediates{};$/;"	s	namespace:boost::multiprecision::detail
block_multiplier	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^inline limb_type block_multiplier(unsigned count)$/;"	f	namespace:boost::multiprecision	signature:(unsigned count)
boost	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace boost{ namespace math{$/;"	n
boost	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/multiprecision/cpp_int.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n
boost	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n
boost	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{$/;"	n
boost	/usr/include/boost/multiprecision/cpp_int/comparison.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n
boost	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^namespace boost{ namespace multiprecision{$/;"	n
boost	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n
boost	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n
boost	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n
boost	/usr/include/boost/multiprecision/detail/big_lanczos.hpp	/^namespace boost{ namespace math{$/;"	n
boost	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^namespace boost{ namespace multiprecision{ namespace default_ops{$/;"	n
boost	/usr/include/boost/multiprecision/detail/digits.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n
boost	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^namespace boost{ namespace multiprecision{$/;"	n
boost	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n
boost	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^namespace boost{ namespace multiprecision{$/;"	n
boost	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/multiprecision/detail/number_base.hpp	/^namespace boost{ namespace math{ namespace tools{$/;"	n
boost	/usr/include/boost/multiprecision/detail/number_base.hpp	/^namespace boost{ namespace multiprecision{$/;"	n
boost	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^namespace boost{ namespace multiprecision{$/;"	n
boost	/usr/include/boost/multiprecision/gmp.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/multiprecision/integer.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/multiprecision/miller_rabin.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/multiprecision/mpfr.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/multiprecision/number.hpp	/^namespace boost{ namespace multiprecision{$/;"	n
boost	/usr/include/boost/multiprecision/random.hpp	/^namespace boost{ namespace random{ namespace detail{$/;"	n
boost	/usr/include/boost/multiprecision/random.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/multiprecision/rational_adapter.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/multiprecision/tommath.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n
boost	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n
boost	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n
boost::denominator	/usr/include/boost/multiprecision/number.hpp	/^inline multiprecision::number<T, ExpressionTemplates> denominator(const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a)
boost::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_float<0>::gmp_float(const gmp_int& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_int& o)
boost::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_float<0>::gmp_float(const gmp_rational& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_rational& o)
boost::gmp_float::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_float<0>& gmp_float<0>::operator=(const gmp_int& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_int& o)
boost::gmp_float::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_float<0>& gmp_float<0>::operator=(const gmp_rational& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_rational& o)
boost::gmp_float::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_float<Digits10>& gmp_float<Digits10>::operator=(const gmp_int& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_int& o)
boost::gmp_float::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_float<Digits10>& gmp_float<Digits10>::operator=(const gmp_rational& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_rational& o)
boost::gmp_int::gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_int::gmp_int(const gmp_rational& o)$/;"	f	class:boost::gmp_int	signature:(const gmp_rational& o)
boost::gmp_int::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_int& gmp_int::operator=(const gmp_rational& o)$/;"	f	class:boost::gmp_int	signature:(const gmp_rational& o)
boost::integer_traits	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^class integer_traits<multiprecision::double_limb_type>$/;"	c	namespace:boost	inherits:std::numeric_limits,detail::integer_traits_base
boost::integer_traits	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^class integer_traits<multiprecision::signed_double_limb_type>$/;"	c	namespace:boost	inherits:std::numeric_limits,detail::integer_traits_base
boost::math	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace boost{ namespace math{$/;"	n	namespace:boost
boost::math	/usr/include/boost/multiprecision/detail/big_lanczos.hpp	/^namespace boost{ namespace math{$/;"	n	namespace:boost
boost::math	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^namespace math{$/;"	n	namespace:boost
boost::math	/usr/include/boost/multiprecision/detail/number_base.hpp	/^namespace boost{ namespace math{ namespace tools{$/;"	n	namespace:boost
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isfinite BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isfinite BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isinf BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isinf BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isnan BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isnan BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isnormal BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool isnormal BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int fpclassify BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& arg)
boost::math::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int fpclassify BOOST_PREVENT_MACRO_SUBSTITUTION(const multiprecision::number<Backend, ExpressionTemplates>& arg)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& arg)
boost::math::detail	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^namespace detail{$/;"	n	namespace:boost::math
boost::math::detail::sinc_pi_imp	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   template <class T> T sinc_pi_imp(T);$/;"	p	namespace:boost::math::detail	signature:(T)
boost::math::detail::sinhc_pi_imp	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   template <class T> T sinhc_pi_imp(T);$/;"	p	namespace:boost::math::detail	signature:(T)
boost::math::lanczos	/usr/include/boost/multiprecision/detail/big_lanczos.hpp	/^namespace lanczos{$/;"	n	namespace:boost::math
boost::math::lanczos::lanczos	/usr/include/boost/multiprecision/detail/big_lanczos.hpp	/^struct lanczos<multiprecision::number<Backend, ExpressionTemplates>, Policy>$/;"	s	namespace:boost::math::lanczos
boost::math::lanczos::lanczos::precision_type	/usr/include/boost/multiprecision/detail/big_lanczos.hpp	/^   typedef typename boost::math::policies::precision<multiprecision::number<Backend, ExpressionTemplates>, Policy>::type precision_type;$/;"	t	struct:boost::math::lanczos::lanczos	access:public
boost::math::policies	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace policies{$/;"	n	namespace:boost::math
boost::math::policies::precision	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^struct precision< boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates>, Policy>$/;"	s	namespace:boost::math::policies
boost::math::policies::precision::cpp_dec_float_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10 = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	struct:boost::math::policies::precision	access:public
boost::math::policies::precision::digits_2	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef digits2<((cpp_dec_float_digits10 + 1LL) * 1000LL) \/ 301LL> digits_2;$/;"	t	struct:boost::math::policies::precision	access:public
boost::math::policies::precision::precision_type	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef typename Policy::precision_type precision_type;$/;"	t	struct:boost::math::policies::precision	access:public
boost::math::sinc_pi	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x)
boost::math::sinc_pi	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)
boost::math::sinhc_pi	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinhc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x)
boost::math::sinhc_pi	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinhc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)
boost::math::tools	/usr/include/boost/multiprecision/detail/number_base.hpp	/^namespace boost{ namespace math{ namespace tools{$/;"	n	namespace:boost::math
boost::math::tools::promote_arg	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct promote_arg<boost::multiprecision::detail::expression<tag, A1, A2, A3, A4> >$/;"	s	namespace:boost::math::tools
boost::math::tools::promote_arg::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type type;$/;"	t	struct:boost::math::tools::promote_arg	access:public
boost::math::tools::real_cast	/usr/include/boost/multiprecision/detail/number_base.hpp	/^inline R real_cast(const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>& val)$/;"	f	namespace:boost::math::tools	signature:(const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>& val)
boost::math::tools::real_cast	/usr/include/boost/multiprecision/detail/number_base.hpp	/^inline R real_cast(const boost::multiprecision::number<B, ET>& val)$/;"	f	namespace:boost::math::tools	signature:(const boost::multiprecision::number<B, ET>& val)
boost::multiprecision	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/cpp_int.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/cpp_int/comparison.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^namespace boost{ namespace multiprecision{ namespace default_ops{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/detail/digits.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/detail/number_base.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/gmp.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/integer.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/miller_rabin.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/mpfr.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/number.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/rational_adapter.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/tommath.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
boost::multiprecision	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
boost::multiprecision::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE cpp_int_backend& operator = (const cpp_int_backend& o) BOOST_NOEXCEPT_IF((Checked == unchecked) && boost::is_void<Allocator>::value)$/;"	f	namespace:boost::multiprecision	signature:(Checked == unchecked) && boost::is_void<Allocator>::value
boost::multiprecision::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE cpp_int_backend& operator = (cpp_int_backend&& o) BOOST_NOEXCEPT_IF(boost::is_void<Allocator>::value)$/;"	f	namespace:boost::multiprecision	signature:(boost::is_void<Allocator>::value)
boost::multiprecision::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE void do_assign_arithmetic(signed_limb_type i, const mpl::false_&) BOOST_NOEXCEPT_IF((Checked == unchecked))$/;"	f	namespace:boost::multiprecision	access:private	signature:(Checked == unchecked)
boost::multiprecision::abs	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^abs(const detail::expression<tag, A1, A2, A3, A4>& arg)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& arg)
boost::multiprecision::abs	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^abs(const number<Backend, et_off>& arg)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, et_off>& arg)
boost::multiprecision::abs	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^abs(const number<Backend, et_on>& arg)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, et_on>& arg)
boost::multiprecision::add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   add(number<B, ET>& result, const I& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, ET>& result, const I& a, const I& b)
boost::multiprecision::add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline number<B1, ET1>& add(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
boost::multiprecision::add	/usr/include/boost/multiprecision/integer.hpp	/^   add(Integer& result, const I2& a, const I2& b)$/;"	f	namespace:boost::multiprecision	signature:(Integer& result, const I2& a, const I2& b)
boost::multiprecision::allocate_dynamic	/usr/include/boost/multiprecision/mpfr.hpp	/^   allocate_dynamic$/;"	e	enum:boost::multiprecision::mpfr_allocation_type
boost::multiprecision::allocate_stack	/usr/include/boost/multiprecision/mpfr.hpp	/^   allocate_stack,$/;"	e	enum:boost::multiprecision::mpfr_allocation_type
boost::multiprecision::backends	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	/usr/include/boost/multiprecision/cpp_int.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	/usr/include/boost/multiprecision/cpp_int/comparison.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	/usr/include/boost/multiprecision/gmp.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	/usr/include/boost/multiprecision/mpfr.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	/usr/include/boost/multiprecision/rational_adapter.hpp	/^namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends	/usr/include/boost/multiprecision/tommath.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^      const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^      const limb_type& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^      const signed_limb_type& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^   eval_add(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const limb_type& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^   eval_decrement(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^   eval_increment(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^inline void add_unsigned(CppInt1& result, const CppInt2& a, const CppInt3& b) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^inline void add_unsigned(CppInt1& result, const CppInt2& a, const limb_type& o) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^inline void subtract_unsigned(CppInt1& result, const CppInt2& a, const CppInt3& b) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^inline void subtract_unsigned(CppInt1& result, const CppInt2& a, const limb_type& b) BOOST_NOEXCEPT_IF(is_non_throwing_cpp_int<CppInt1>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^      double_limb_type s) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^   Op op) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<CppInt1>::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<CppInt1>::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^   eval_left_shift(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, T s) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^   eval_right_shift(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, T s) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^      cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& r) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_abs(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_convert_to(R* result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& backend) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_convert_to(R* result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& backend) BOOST_NOEXCEPT_IF(is_arithmetic<R>::value)$/;"	f	namespace:boost::multiprecision::backends	signature:(is_arithmetic<R>::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& b) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const signed_double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^      const signed_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const signed_double_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::BOOST_NOEXCEPT_IF	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^   eval_multiply(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const signed_limb_type& val) BOOST_NOEXCEPT_IF((is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value))$/;"	f	namespace:boost::multiprecision::backends	signature:(is_non_throwing_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value)
boost::multiprecision::backends::assign	/usr/include/boost/multiprecision/cpp_int.hpp	/^   void assign(const cpp_int_base& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_base& o)
boost::multiprecision::backends::assign_components	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline void assign_components(rational_adapter<IntBackend>& result, const V& v1, const V& v2)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adapter<IntBackend>& result, const V& v1, const V& v2)
boost::multiprecision::backends::bit_and	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^struct bit_and{ limb_type operator()(limb_type a, limb_type b)const BOOST_NOEXCEPT { return a & b; } };$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::bit_or	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^struct bit_or { limb_type operator()(limb_type a, limb_type b)const BOOST_NOEXCEPT { return a | b; } };$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::bit_xor	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^struct bit_xor{ limb_type operator()(limb_type a, limb_type b)const BOOST_NOEXCEPT { return a ^ b; } };$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::check_in_range	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^void check_in_range(const CppInt& val, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends	signature:(const CppInt& val, const mpl::int_<checked>&)
boost::multiprecision::backends::check_is_negative	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^inline void check_is_negative(const mpl::false_&)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpl::false_&)
boost::multiprecision::backends::cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^class cpp_dec_float$/;"	c	namespace:boost::multiprecision::backends
boost::multiprecision::backends::cpp_dec_float::BOOST_STATIC_ASSERT	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   BOOST_STATIC_ASSERT((cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10 == -cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10));$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10 == -cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10)
boost::multiprecision::backends::cpp_dec_float::BOOST_STATIC_ASSERT_MSG	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   BOOST_STATIC_ASSERT_MSG(boost::is_signed<ExponentType>::value, "ExponentType must be a signed built in integer type.");$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::is_signed<ExponentType>::value, Ó)
boost::multiprecision::backends::cpp_dec_float::add_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& add_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
boost::multiprecision::backends::cpp_dec_float::array_type	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      >::type array_type;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::calculate_inv	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& calculate_inv (void)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
boost::multiprecision::backends::cpp_dec_float::calculate_inv	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::calculate_inv()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:()
boost::multiprecision::backends::cpp_dec_float::calculate_sqrt	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& calculate_sqrt(void)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
boost::multiprecision::backends::cpp_dec_float::calculate_sqrt	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::calculate_sqrt(void)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void)
boost::multiprecision::backends::cpp_dec_float::char_is_nonzero_predicate	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static bool char_is_nonzero_predicate(const char& c)  { return (c != static_cast<char>('0')); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const char& c)
boost::multiprecision::backends::cpp_dec_float::cmp_data	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   int cmp_data(const array_type& vd) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const array_type& vd) const
boost::multiprecision::backends::cpp_dec_float::cmp_data	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^int cpp_dec_float<Digits10, ExponentType, Allocator>::cmp_data(const array_type& vd) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const array_type& vd) const
boost::multiprecision::backends::cpp_dec_float::compare	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   int compare(const V& v)const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const V& v) const
boost::multiprecision::backends::cpp_dec_float::compare	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   int compare(const cpp_dec_float& v)const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v) const
boost::multiprecision::backends::cpp_dec_float::compare	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^int cpp_dec_float<Digits10, ExponentType, Allocator>::compare(const cpp_dec_float& v) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float& v) const
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float()   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(I i, typename enable_if<is_signed<I> >::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(I i, typename enable_if<is_signed<I> >::type* = 0)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(I i, typename enable_if<is_unsigned<I> >::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(I i, typename enable_if<is_unsigned<I> >::type* = 0)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const F val, typename enable_if<is_floating_point<F> >::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const F val, typename enable_if<is_floating_point<F> >::type* = 0)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const char* s) : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const char* s)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const cpp_dec_float& f)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& f)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const cpp_dec_float<D, ET, A>& f, typename enable_if_c<D <= Digits10>::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float<D, ET, A>& f, typename enable_if_c<D <= Digits10>::type* = 0)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const double val, ExponentType exponent);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const double val, ExponentType exponent)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(fpclass_type c)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(fpclass_type c)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   explicit cpp_dec_float(const cpp_dec_float<D, ET, A>& f, typename disable_if_c<D <= Digits10>::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float<D, ET, A>& f, typename disable_if_c<D <= Digits10>::type* = 0)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float(const double mantissa, const ExponentType exponent)   $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const double mantissa, const ExponentType exponent)
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_NaN	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      cpp_dec_float_NaN$/;"	e	enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10          = ((cpp_dec_float_digits10_setting < cpp_dec_float_digits10_limit_lo) ? cpp_dec_float_digits10_limit_lo : ((cpp_dec_float_digits10_setting > cpp_dec_float_digits10_limit_hi) ? cpp_dec_float_digits10_limit_hi : cpp_dec_float_digits10_setting));$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10_limit_hi	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10_limit_hi = boost::integer_traits<boost::int32_t>::const_max - 100;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10_limit_hi	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10_limit_hi;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10_limit_lo	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10_limit_lo = 9L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10_limit_lo	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10_limit_lo;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10_setting	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10_setting = Digits10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_digits10_setting	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10_setting;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_digits10 = 8L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_digits10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_mask	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_mask     = 100000000L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_mask	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_mask;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_number	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_number = static_cast<boost::int32_t>(((cpp_dec_float_elem_number_request < 2L) ? 2L : cpp_dec_float_elem_number_request) + 3L);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_number	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_number;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_number_request	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_number_request = static_cast<boost::int32_t>((cpp_dec_float_digits10 \/ cpp_dec_float_elem_digits10) + (((cpp_dec_float_digits10 % cpp_dec_float_elem_digits10) != 0) ? 1 : 0));$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_elem_number_request	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_number_request;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_finite	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      cpp_dec_float_finite,$/;"	e	enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_inf	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      cpp_dec_float_inf,$/;"	e	enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_max_exp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_max_exp           = static_cast<ExponentType>((cpp_dec_float_max_exp10 \/ 301LL) * 1000LL);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_max_exp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_max_exp10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_max_exp10         = (static_cast<ExponentType>(1) << (std::numeric_limits<ExponentType>::digits - 5));$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_max_exp10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_min_exp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_min_exp           = static_cast<ExponentType>((cpp_dec_float_min_exp10 \/ 301LL) * 1000LL);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_min_exp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_min_exp10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_min_exp10         = -cpp_dec_float_max_exp10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_min_exp10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_radix	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_radix             = 10L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_radix	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_radix;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::cpp_dec_float_total_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_total_digits10 = static_cast<boost::int32_t>(cpp_dec_float_elem_number * cpp_dec_float_elem_digits10);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::data	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   array_type      data;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::data_elem_is_non_nine_predicate	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static bool data_elem_is_non_nine_predicate(const boost::uint32_t& d)  { return (d != static_cast<boost::uint32_t>(cpp_dec_float::cpp_dec_float_elem_mask - 1)); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const boost::uint32_t& d)
boost::multiprecision::backends::cpp_dec_float::data_elem_is_non_zero_predicate	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static bool data_elem_is_non_zero_predicate(const boost::uint32_t& d)  { return (d != static_cast<boost::uint32_t>(0u)); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const boost::uint32_t& d)
boost::multiprecision::backends::cpp_dec_float::div_loop_n	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static boost::uint32_t div_loop_n (boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
boost::multiprecision::backends::cpp_dec_float::div_loop_n	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^boost::uint32_t cpp_dec_float<Digits10, ExponentType, Allocator>::div_loop_n(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
boost::multiprecision::backends::cpp_dec_float::div_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& div_unsigned_long_long(const unsigned long long n);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
boost::multiprecision::backends::cpp_dec_float::div_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::div_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const unsigned long long n)
boost::multiprecision::backends::cpp_dec_float::double_max	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& double_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::double_min	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& double_min()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef enum enum_fpclass_type$/;"	g	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::eps	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& eps()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::exp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   ExponentType    exp;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::exponent_type	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef ExponentType                   exponent_type;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::extract_double	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   double             extract_double            (void) const;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_double	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^double cpp_dec_float<Digits10, ExponentType, Allocator>::extract_double(void) const$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_integer_part	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float      extract_integer_part      (void) const  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_integer_part	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator> cpp_dec_float<Digits10, ExponentType, Allocator>::extract_integer_part(void) const  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_long_double	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   long double        extract_long_double       (void) const;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_long_double	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^long double cpp_dec_float<Digits10, ExponentType, Allocator>::extract_long_double(void) const$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_parts	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   void               extract_parts             (double& mantissa, ExponentType& exponent) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(double& mantissa, ExponentType& exponent) const
boost::multiprecision::backends::cpp_dec_float::extract_parts	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^void cpp_dec_float<Digits10, ExponentType, Allocator>::extract_parts(double& mantissa, ExponentType& exponent) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(double& mantissa, ExponentType& exponent) const
boost::multiprecision::backends::cpp_dec_float::extract_signed_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   signed long long   extract_signed_long_long  (void) const  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_signed_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^signed long long cpp_dec_float<Digits10, ExponentType, Allocator>::extract_signed_long_long(void) const  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   unsigned long long extract_unsigned_long_long(void) const  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::extract_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^unsigned long long cpp_dec_float<Digits10, ExponentType, Allocator>::extract_unsigned_long_long(void) const  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::float_types	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef mpl::list<long double>         float_types;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::fpclass	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   fpclass_type    fpclass;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::fpclass_type	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   fpclass_type;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	typeref:enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type	access:private
boost::multiprecision::backends::cpp_dec_float::from_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   void from_unsigned_long_long(const unsigned long long u) ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const unsigned long long u)
boost::multiprecision::backends::cpp_dec_float::from_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^void cpp_dec_float<Digits10, ExponentType, Allocator>::from_unsigned_long_long(const unsigned long long u) $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const unsigned long long u)
boost::multiprecision::backends::cpp_dec_float::half	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& half()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::inf	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& inf()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::init	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      static initializer init;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::init	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^typename cpp_dec_float<Digits10, ExponentType, Allocator>::initializer cpp_dec_float<Digits10, ExponentType, Allocator>::init;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
boost::multiprecision::backends::cpp_dec_float::initializer	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      struct initializer$/;"	s	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::initializer::do_nothing	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^         void do_nothing(){}$/;"	f	struct:boost::multiprecision::backends::cpp_dec_float::initializer	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::initializer::initializer	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^         initializer()$/;"	f	struct:boost::multiprecision::backends::cpp_dec_float::initializer	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::isfinite	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool isfinite(void) const  { return (fpclass == cpp_dec_float_finite); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::isinf	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool isinf   (void) const  { return (fpclass == cpp_dec_float_inf); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::isint	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool isint  (void) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::isint	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^bool cpp_dec_float<Digits10, ExponentType, Allocator>::isint() const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:() const
boost::multiprecision::backends::cpp_dec_float::isnan	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool isnan   (void) const  { return (fpclass == cpp_dec_float_NaN); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::isneg	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool isneg  (void) const  { return neg; }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::isone	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool isone  (void) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::isone	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^bool cpp_dec_float<Digits10, ExponentType, Allocator>::isone() const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:() const
boost::multiprecision::backends::cpp_dec_float::iszero	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool iszero (void) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
boost::multiprecision::backends::cpp_dec_float::long_double_max	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_double_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::long_double_min	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_double_min()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::long_long_max	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_long_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::long_long_min	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_long_min()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::max	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& (max)()$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::min	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& (min)()$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::mul_loop_n	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static boost::uint32_t mul_loop_n (boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
boost::multiprecision::backends::cpp_dec_float::mul_loop_n	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^boost::uint32_t cpp_dec_float<Digits10, ExponentType, Allocator>::mul_loop_n(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
boost::multiprecision::backends::cpp_dec_float::mul_loop_uv	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static boost::uint32_t mul_loop_uv(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)
boost::multiprecision::backends::cpp_dec_float::mul_loop_uv	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^boost::uint32_t cpp_dec_float<Digits10, ExponentType, Allocator>::mul_loop_uv(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)
boost::multiprecision::backends::cpp_dec_float::mul_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& mul_unsigned_long_long(const unsigned long long n);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
boost::multiprecision::backends::cpp_dec_float::mul_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::mul_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const unsigned long long n)
boost::multiprecision::backends::cpp_dec_float::nan	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& nan()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::neg	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool            neg;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::negate	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   void negate()   $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::one	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& one()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::operator *=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator*=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
boost::multiprecision::backends::cpp_dec_float::operator *=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator*=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
boost::multiprecision::backends::cpp_dec_float::operator ++	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator++(void)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
boost::multiprecision::backends::cpp_dec_float::operator +=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator+=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
boost::multiprecision::backends::cpp_dec_float::operator +=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator+=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
boost::multiprecision::backends::cpp_dec_float::operator --	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator--(void)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
boost::multiprecision::backends::cpp_dec_float::operator -=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator-=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
boost::multiprecision::backends::cpp_dec_float::operator -=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator-=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
boost::multiprecision::backends::cpp_dec_float::operator /=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator\/=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
boost::multiprecision::backends::cpp_dec_float::operator /=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator\/=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
boost::multiprecision::backends::cpp_dec_float::operator =	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (const char* v)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const char* v)
boost::multiprecision::backends::cpp_dec_float::operator =	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (const cpp_dec_float& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
boost::multiprecision::backends::cpp_dec_float::operator =	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (long double v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(long double v)
boost::multiprecision::backends::cpp_dec_float::operator =	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (long long v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(long long v)
boost::multiprecision::backends::cpp_dec_float::operator =	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (unsigned long long v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(unsigned long long v)
boost::multiprecision::backends::cpp_dec_float::operator =	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator=(const cpp_dec_float<D>& f)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float<D>& f)
boost::multiprecision::backends::cpp_dec_float::operator =	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator = (long double a)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(long double a)
boost::multiprecision::backends::cpp_dec_float::order	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   ExponentType order()const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:() const
boost::multiprecision::backends::cpp_dec_float::pow2	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static cpp_dec_float pow2(long long i);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(long long i)
boost::multiprecision::backends::cpp_dec_float::pow2	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator> cpp_dec_float<Digits10, ExponentType, Allocator>::pow2(const long long p)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const long long p)
boost::multiprecision::backends::cpp_dec_float::prec_elem	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   boost::int32_t  prec_elem;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
boost::multiprecision::backends::cpp_dec_float::precision	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   void precision(const boost::int32_t prec_digits) $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const boost::int32_t prec_digits)
boost::multiprecision::backends::cpp_dec_float::rd_string	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool rd_string(const char* const s);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const char* const s)
boost::multiprecision::backends::cpp_dec_float::rd_string	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^bool cpp_dec_float<Digits10, ExponentType, Allocator>::rd_string(const char* const s)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const char* const s)
boost::multiprecision::backends::cpp_dec_float::signed_types	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef mpl::list<long long>           signed_types;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::sizeof	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   BOOST_STATIC_ASSERT_MSG(sizeof(ExponentType) > 1, "ExponentType is too small.");$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(ExponentType)
boost::multiprecision::backends::cpp_dec_float::str	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   std::string str(boost::intmax_t digits, std::ios_base::fmtflags f)const;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(boost::intmax_t digits, std::ios_base::fmtflags f) const
boost::multiprecision::backends::cpp_dec_float::str	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^std::string cpp_dec_float<Digits10, ExponentType, Allocator>::str(boost::intmax_t number_of_digits, std::ios_base::fmtflags f) const$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::intmax_t number_of_digits, std::ios_base::fmtflags f) const
boost::multiprecision::backends::cpp_dec_float::sub_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& sub_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
boost::multiprecision::backends::cpp_dec_float::swap	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   void swap(cpp_dec_float& v) $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(cpp_dec_float& v)
boost::multiprecision::backends::cpp_dec_float::two	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& two()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::ulong_long_max	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& ulong_long_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_dec_float::unsigned_types	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef mpl::list<unsigned long long>  unsigned_types;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
boost::multiprecision::backends::cpp_dec_float::zero	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& zero()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
boost::multiprecision::backends::cpp_int_base	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE cpp_int_base(const cpp_int_base& o) : allocator_type(o), m_limbs(0), m_internal(true)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_base& o)
boost::multiprecision::backends::cpp_int_base	/usr/include/boost/multiprecision/cpp_int.hpp	/^   cpp_int_base(cpp_int_base&& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_base&& o)
boost::multiprecision::backends::cpp_int_base	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false> : private Allocator::template rebind<limb_type>::other$/;"	s	namespace:boost::multiprecision::backends	inherits:Allocator::,rebind::other
boost::multiprecision::backends::cpp_int_base::BOOST_NOEXCEPT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::BOOST_NOEXCEPT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_double_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::BOOST_NOEXCEPT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(bool, variable = true);$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(bool, variable = true)
boost::multiprecision::backends::cpp_int_base::BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, max_limb_value = ~static_cast<limb_type>(0u));$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(limb_type, max_limb_value = ~static_cast<limb_type>(0u))
boost::multiprecision::backends::cpp_int_base::BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, sign_bit_mask = 1u << (limb_bits - 1));$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(limb_type, sign_bit_mask = 1u << (limb_bits - 1))
boost::multiprecision::backends::cpp_int_base::BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, internal_limb_count =$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(unsigned, internal_limb_count = MinBits ? MinBits / limb_bits + (MinBits % limb_bits ? 1 : 0) : sizeof(limb_data) / sizeof(limb_type))
boost::multiprecision::backends::cpp_int_base::BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT);$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT)
boost::multiprecision::backends::cpp_int_base::allocator_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef typename Allocator::template rebind<limb_type>::other allocator_type;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::cap	/usr/include/boost/multiprecision/cpp_int.hpp	/^      unsigned cap = capacity();$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::checked_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef mpl::int_<Checked>                                    checked_type;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::const_limb_pointer	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef typename allocator_type::const_pointer                const_limb_pointer;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^   union data_type$/;"	u	struct:boost::multiprecision::backends::cpp_int_base	access:private
boost::multiprecision::backends::cpp_int_base::data_type::data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type() : first(0) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:()
boost::multiprecision::backends::cpp_int_base::data_type::data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(double_limb_type i) : double_first(i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(double_limb_type i)
boost::multiprecision::backends::cpp_int_base::data_type::data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(limb_type i) : first(i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(limb_type i)
boost::multiprecision::backends::cpp_int_base::data_type::data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(signed_double_limb_type i) : double_first(i < 0 ? -i : i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(signed_double_limb_type i)
boost::multiprecision::backends::cpp_int_base::data_type::data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(signed_limb_type i) : first(i < 0 ? -i : i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(signed_limb_type i)
boost::multiprecision::backends::cpp_int_base::data_type::double_first	/usr/include/boost/multiprecision/cpp_int.hpp	/^      double_limb_type double_first;$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
boost::multiprecision::backends::cpp_int_base::data_type::first	/usr/include/boost/multiprecision/cpp_int.hpp	/^      limb_type first;$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
boost::multiprecision::backends::cpp_int_base::data_type::la	/usr/include/boost/multiprecision/cpp_int.hpp	/^      limb_type la[internal_limb_count];$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
boost::multiprecision::backends::cpp_int_base::data_type::ld	/usr/include/boost/multiprecision/cpp_int.hpp	/^      limb_data ld;$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
boost::multiprecision::backends::cpp_int_base::detail::verify_new_size	/usr/include/boost/multiprecision/cpp_int.hpp	/^      detail::verify_new_size(new_size, min_size, checked_type());$/;"	p	class:boost::multiprecision::backends::cpp_int_base::detail	access:public	signature:(new_size, min_size, checked_type())
boost::multiprecision::backends::cpp_int_base::limb_data	/usr/include/boost/multiprecision/cpp_int.hpp	/^   struct limb_data$/;"	s	struct:boost::multiprecision::backends::cpp_int_base	access:private
boost::multiprecision::backends::cpp_int_base::limb_data::capacity	/usr/include/boost/multiprecision/cpp_int.hpp	/^      unsigned capacity;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base::limb_data	access:public
boost::multiprecision::backends::cpp_int_base::limb_data::data	/usr/include/boost/multiprecision/cpp_int.hpp	/^      limb_pointer data;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base::limb_data	access:public
boost::multiprecision::backends::cpp_int_base::limb_pointer	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef typename allocator_type::pointer                      limb_pointer;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::cpp_int_base::m_data	/usr/include/boost/multiprecision/cpp_int.hpp	/^   data_type   m_data;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
boost::multiprecision::backends::cpp_int_base::m_internal	/usr/include/boost/multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(1), m_sign(false), m_internal(true) { }$/;"	f	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(true)
boost::multiprecision::backends::cpp_int_base::m_internal	/usr/include/boost/multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(i > max_limb_value ? 2 : 1), m_sign(false), m_internal(true) { }$/;"	f	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(true)
boost::multiprecision::backends::cpp_int_base::m_internal	/usr/include/boost/multiprecision/cpp_int.hpp	/^   bool        m_sign, m_internal;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
boost::multiprecision::backends::cpp_int_base::m_limbs	/usr/include/boost/multiprecision/cpp_int.hpp	/^   unsigned    m_limbs;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
boost::multiprecision::backends::cpp_int_base::m_sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(1), m_sign(false), m_internal(true) { }$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(false)
boost::multiprecision::backends::cpp_int_base::m_sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(i > max_limb_value ? 2 : 1), m_sign(false), m_internal(true) { }$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(false)
boost::multiprecision::backends::cpp_int_base::m_sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^   bool        m_sign, m_internal;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
boost::multiprecision::backends::cpp_int_base::new_size	/usr/include/boost/multiprecision/cpp_int.hpp	/^         new_size = max_limbs;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
boost::multiprecision::backends::detail	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
boost::multiprecision::backends::detail	/usr/include/boost/multiprecision/cpp_int.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
boost::multiprecision::backends::detail	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{$/;"	n	namespace:boost::multiprecision::backends
boost::multiprecision::backends::detail	/usr/include/boost/multiprecision/gmp.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
boost::multiprecision::backends::detail	/usr/include/boost/multiprecision/mpfr.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
boost::multiprecision::backends::detail	/usr/include/boost/multiprecision/tommath.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
boost::multiprecision::backends::detail::check_tommath_result	/usr/include/boost/multiprecision/tommath.hpp	/^inline void check_tommath_result(unsigned v)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(unsigned v)
boost::multiprecision::backends::detail::checked_add	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_add(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
boost::multiprecision::backends::detail::checked_add	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_add(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
boost::multiprecision::backends::detail::checked_add_imp	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_add_imp(A a, A b, const mpl::false_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::false_&)
boost::multiprecision::backends::detail::checked_add_imp	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_add_imp(A a, A b, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::true_&)
boost::multiprecision::backends::detail::checked_divide	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_divide(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
boost::multiprecision::backends::detail::checked_divide	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_divide(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
boost::multiprecision::backends::detail::checked_left_shift	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_left_shift(A a, unsigned long long shift, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, unsigned long long shift, const mpl::int_<checked>&)
boost::multiprecision::backends::detail::checked_left_shift	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_left_shift(A a, unsigned long long shift, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, unsigned long long shift, const mpl::int_<unchecked>&)
boost::multiprecision::backends::detail::checked_multiply	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_multiply(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
boost::multiprecision::backends::detail::checked_multiply	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_multiply(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
boost::multiprecision::backends::detail::checked_subtract	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
boost::multiprecision::backends::detail::checked_subtract	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
boost::multiprecision::backends::detail::checked_subtract_imp	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract_imp(A a, A b, const mpl::false_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::false_&)
boost::multiprecision::backends::detail::checked_subtract_imp	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract_imp(A a, A b, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::true_&)
boost::multiprecision::backends::detail::dynamic_array	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^struct dynamic_array : public std::vector<T, typename rebind<T, Allocator>::type>$/;"	s	namespace:boost::multiprecision::backends::detail	inherits:std::vector
boost::multiprecision::backends::detail::dynamic_array::data	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   T* data()$/;"	f	struct:boost::multiprecision::backends::detail::dynamic_array	access:public	signature:()
boost::multiprecision::backends::detail::dynamic_array::data	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   const T* data()const$/;"	f	struct:boost::multiprecision::backends::detail::dynamic_array	access:public	signature:() const
boost::multiprecision::backends::detail::dynamic_array::dynamic_array	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   dynamic_array()$/;"	f	struct:boost::multiprecision::backends::detail::dynamic_array	access:public	signature:()
boost::multiprecision::backends::detail::get_default_precision	/usr/include/boost/multiprecision/mpfr.hpp	/^inline long get_default_precision() { return 50; }$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
boost::multiprecision::backends::detail::gmp_float_imp	/usr/include/boost/multiprecision/gmp.hpp	/^struct gmp_float_imp$/;"	s	namespace:boost::multiprecision::backends::detail
boost::multiprecision::backends::detail::gmp_float_imp::compare	/usr/include/boost/multiprecision/gmp.hpp	/^   typename enable_if<is_arithmetic<V>, int>::type compare(V v)const$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(V v) const
boost::multiprecision::backends::detail::gmp_float_imp::exponent_type	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef long                                      exponent_type;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
boost::multiprecision::backends::detail::gmp_float_imp::float_types	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef mpl::list<double, long double>            float_types;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
boost::multiprecision::backends::detail::gmp_float_imp::gmp_float_imp	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp(const gmp_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(const gmp_float_imp& o)
boost::multiprecision::backends::detail::gmp_float_imp::m_data	/usr/include/boost/multiprecision/gmp.hpp	/^   mpf_t m_data;$/;"	m	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:protected
boost::multiprecision::backends::detail::gmp_float_imp::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(const char* s)
boost::multiprecision::backends::detail::gmp_float_imp::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (const gmp_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(const gmp_float_imp& o)
boost::multiprecision::backends::detail::gmp_float_imp::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (double d)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(double d)
boost::multiprecision::backends::detail::gmp_float_imp::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (long double a)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(long double a)
boost::multiprecision::backends::detail::gmp_float_imp::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(long i)
boost::multiprecision::backends::detail::gmp_float_imp::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (long long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(long long i)
boost::multiprecision::backends::detail::gmp_float_imp::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (unsigned long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(unsigned long i)
boost::multiprecision::backends::detail::gmp_float_imp::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(unsigned long long i)
boost::multiprecision::backends::detail::gmp_float_imp::signed_types	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef mpl::list<long, long long>                 signed_types;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
boost::multiprecision::backends::detail::gmp_float_imp::str	/usr/include/boost/multiprecision/gmp.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
boost::multiprecision::backends::detail::gmp_float_imp::unsigned_types	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef mpl::list<unsigned long, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
boost::multiprecision::backends::detail::mpfr_float_imp	/usr/include/boost/multiprecision/mpfr.hpp	/^struct mpfr_float_imp<digits10, allocate_dynamic>$/;"	s	namespace:boost::multiprecision::backends::detail
boost::multiprecision::backends::detail::mpfr_float_imp	/usr/include/boost/multiprecision/mpfr.hpp	/^struct mpfr_float_imp<digits10, allocate_stack>$/;"	s	namespace:boost::multiprecision::backends::detail
boost::multiprecision::backends::detail::mpfr_float_imp::digits2	/usr/include/boost/multiprecision/mpfr.hpp	/^   static const unsigned digits2 = (digits10 * 1000uL) \/ 301uL + ((digits10 * 1000uL) % 301 ? 2u : 1u);$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
boost::multiprecision::backends::detail::mpfr_float_imp::exponent_type	/usr/include/boost/multiprecision/mpfr.hpp	/^   typedef long                                           exponent_type;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
boost::multiprecision::backends::detail::mpfr_float_imp::float_types	/usr/include/boost/multiprecision/mpfr.hpp	/^   typedef mpl::list<double, long double>                 float_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
boost::multiprecision::backends::detail::mpfr_float_imp::limb_count	/usr/include/boost/multiprecision/mpfr.hpp	/^   static const unsigned limb_count = mpfr_custom_get_size(digits2) \/ sizeof(mp_limb_t);$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
boost::multiprecision::backends::detail::mpfr_float_imp::m_buffer	/usr/include/boost/multiprecision/mpfr.hpp	/^   mp_limb_t m_buffer[limb_count];$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:protected
boost::multiprecision::backends::detail::mpfr_float_imp::m_data	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_t m_data;$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:protected
boost::multiprecision::backends::detail::mpfr_float_imp::mpfr_float_imp	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp()$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:()
boost::multiprecision::backends::detail::mpfr_float_imp::mpfr_float_imp	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp(const mpfr_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(const mpfr_float_imp& o)
boost::multiprecision::backends::detail::mpfr_float_imp::mpfr_float_imp	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp(unsigned prec)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(unsigned prec)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(const char* s)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (const mpfr_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(const mpfr_float_imp& o)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (double d)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(double d)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (long double a)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(long double a)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(long i)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (long long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(long long i)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (unsigned long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(unsigned long i)
boost::multiprecision::backends::detail::mpfr_float_imp::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(unsigned long long i)
boost::multiprecision::backends::detail::mpfr_float_imp::signed_types	/usr/include/boost/multiprecision/mpfr.hpp	/^   typedef mpl::list<long, long long>                     signed_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
boost::multiprecision::backends::detail::mpfr_float_imp::str	/usr/include/boost/multiprecision/mpfr.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
boost::multiprecision::backends::detail::mpfr_float_imp::unsigned_types	/usr/include/boost/multiprecision/mpfr.hpp	/^   typedef mpl::list<unsigned long, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
boost::multiprecision::backends::detail::raise_add_overflow	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline void raise_add_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
boost::multiprecision::backends::detail::raise_div_overflow	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline void raise_div_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
boost::multiprecision::backends::detail::raise_mul_overflow	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline void raise_mul_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
boost::multiprecision::backends::detail::raise_overflow	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline void raise_overflow(std::string op)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(std::string op)
boost::multiprecision::backends::detail::raise_subtract_overflow	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline void raise_subtract_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
boost::multiprecision::backends::detail::rebind	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^struct rebind$/;"	s	namespace:boost::multiprecision::backends::detail
boost::multiprecision::backends::detail::rebind::type	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef typename Allocator::template rebind<T>::other type;$/;"	t	struct:boost::multiprecision::backends::detail::rebind	access:public
boost::multiprecision::backends::detail::verify_limb_mask	/usr/include/boost/multiprecision/cpp_int.hpp	/^inline void verify_limb_mask(bool \/*b*\/, U \/*limb*\/, U \/*mask*\/, const mpl::int_<unchecked>&){}$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(bool , U , U , const mpl::int_<unchecked>&)
boost::multiprecision::backends::detail::verify_limb_mask	/usr/include/boost/multiprecision/cpp_int.hpp	/^inline void verify_limb_mask(bool b, U limb, U mask, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(bool b, U limb, U mask, const mpl::int_<checked>&)
boost::multiprecision::backends::detail::verify_new_size	/usr/include/boost/multiprecision/cpp_int.hpp	/^inline void verify_new_size(unsigned \/*new_size*\/, unsigned \/*min_size*\/, const mpl::int_<unchecked>&){}$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(unsigned , unsigned , const mpl::int_<unchecked>&)
boost::multiprecision::backends::detail::verify_new_size	/usr/include/boost/multiprecision/cpp_int.hpp	/^inline void verify_new_size(unsigned new_size, unsigned min_size, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(unsigned new_size, unsigned min_size, const mpl::int_<checked>&)
boost::multiprecision::backends::divide_unsigned_helper	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^void divide_unsigned_helper($/;"	f	namespace:boost::multiprecision::backends	signature:( CppInt1* result, const CppInt2& x, const CppInt3& y, CppInt1& r)
boost::multiprecision::backends::divide_unsigned_helper	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^void divide_unsigned_helper($/;"	f	namespace:boost::multiprecision::backends	signature:( CppInt1* result, const CppInt2& x, limb_type y, CppInt1& r)
boost::multiprecision::backends::eval_abs	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_abs(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x) $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
boost::multiprecision::backends::eval_abs	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_abs(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
boost::multiprecision::backends::eval_abs	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_abs(tommath_int& result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& val)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_add(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_add(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_add(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline void eval_add(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_add(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_add(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
boost::multiprecision::backends::eval_add	/usr/include/boost/multiprecision/tommath.hpp	/^void eval_add(tommath_int& t, const tommath_int& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
boost::multiprecision::backends::eval_bit_flip	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_bit_flip(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)
boost::multiprecision::backends::eval_bit_set	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_bit_set(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)
boost::multiprecision::backends::eval_bitwise_and	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_bitwise_and(tommath_int& result, const tommath_int& u, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& u, const tommath_int& v)
boost::multiprecision::backends::eval_bitwise_and	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_bitwise_and(tommath_int& result, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& v)
boost::multiprecision::backends::eval_bitwise_or	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_bitwise_or(tommath_int& result, const tommath_int& u, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& u, const tommath_int& v)
boost::multiprecision::backends::eval_bitwise_or	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_bitwise_or(tommath_int& result, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& v)
boost::multiprecision::backends::eval_bitwise_xor	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_bitwise_xor(tommath_int& result, const tommath_int& u, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& u, const tommath_int& v)
boost::multiprecision::backends::eval_bitwise_xor	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_bitwise_xor(tommath_int& result, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& v)
boost::multiprecision::backends::eval_ceil	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_ceil(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
boost::multiprecision::backends::eval_ceil	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_ceil(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
boost::multiprecision::backends::eval_convert_to	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_convert_to(long double* result, cpp_dec_float<Digits10, ExponentType, Allocator>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(long double* result, cpp_dec_float<Digits10, ExponentType, Allocator>& val)
boost::multiprecision::backends::eval_convert_to	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_convert_to(long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)  $/;"	f	namespace:boost::multiprecision::backends	signature:(long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
boost::multiprecision::backends::eval_convert_to	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_convert_to(unsigned long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)  $/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
boost::multiprecision::backends::eval_convert_to	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_convert_to(long long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(long long* result, const mpfr_float_backend<digits10, AllocationType>& val)
boost::multiprecision::backends::eval_convert_to	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_convert_to(long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(long* result, const mpfr_float_backend<digits10, AllocationType>& val)
boost::multiprecision::backends::eval_convert_to	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_convert_to(unsigned long long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned long long* result, const mpfr_float_backend<digits10, AllocationType>& val)
boost::multiprecision::backends::eval_convert_to	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_convert_to(unsigned long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned long* result, const mpfr_float_backend<digits10, AllocationType>& val)
boost::multiprecision::backends::eval_convert_to	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline void eval_convert_to(R* result, const rational_adapter<IntBackend>& backend)$/;"	f	namespace:boost::multiprecision::backends	signature:(R* result, const rational_adapter<IntBackend>& backend)
boost::multiprecision::backends::eval_convert_to	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_convert_to(A* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(A* result, const tommath_int& val)
boost::multiprecision::backends::eval_convert_to	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_convert_to(char* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(char* result, const tommath_int& val)
boost::multiprecision::backends::eval_convert_to	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_convert_to(signed char* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(signed char* result, const tommath_int& val)
boost::multiprecision::backends::eval_convert_to	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_convert_to(unsigned char* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned char* result, const tommath_int& val)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_divide(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_divide(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_divide(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, limb_type& b)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, signed_limb_type& b)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& b)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, limb_type b)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, signed_limb_type b)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline void eval_divide(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_divide(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
boost::multiprecision::backends::eval_divide	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_divide(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
boost::multiprecision::backends::eval_fabs	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_fabs(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x) $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
boost::multiprecision::backends::eval_fabs	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_fabs(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
boost::multiprecision::backends::eval_floor	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_floor(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
boost::multiprecision::backends::eval_floor	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_floor(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
boost::multiprecision::backends::eval_fpclassify	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline int eval_fpclassify(const cpp_dec_float<Digits10, ExponentType, Allocator>& x) $/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
boost::multiprecision::backends::eval_frexp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline typename disable_if<is_same<ExponentType, int> >::type eval_frexp(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, int* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, int* e)
boost::multiprecision::backends::eval_frexp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_frexp(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ExponentType* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ExponentType* e)
boost::multiprecision::backends::eval_frexp	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_frexp(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, int* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, int* e)
boost::multiprecision::backends::eval_frexp	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_frexp(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long* e)
boost::multiprecision::backends::eval_gcd	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_gcd($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a, limb_type v)
boost::multiprecision::backends::eval_gcd	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_gcd(tommath_int& result, const tommath_int& a, const tommath_int& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& a, const tommath_int& b)
boost::multiprecision::backends::eval_get_sign	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline int eval_get_sign(const cpp_dec_float<Digits10, ExponentType, Allocator>& val) $/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
boost::multiprecision::backends::eval_get_sign	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline int eval_get_sign(const rational_adapter<IntBackend>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const rational_adapter<IntBackend>& val)
boost::multiprecision::backends::eval_get_sign	/usr/include/boost/multiprecision/tommath.hpp	/^inline int eval_get_sign(const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
boost::multiprecision::backends::eval_get_sign	/usr/include/boost/multiprecision/tommath.hpp	/^int eval_get_sign(const tommath_int& val);$/;"	p	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
boost::multiprecision::backends::eval_integer_modulus	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_integer_modulus(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& x, Integer val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& x, Integer val)
boost::multiprecision::backends::eval_integer_modulus	/usr/include/boost/multiprecision/tommath.hpp	/^inline typename enable_if<is_signed<Integer>, Integer>::type eval_integer_modulus(const tommath_int& x, Integer val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& x, Integer val)
boost::multiprecision::backends::eval_integer_modulus	/usr/include/boost/multiprecision/tommath.hpp	/^inline typename enable_if<is_unsigned<Integer>, Integer>::type eval_integer_modulus(const tommath_int& x, Integer val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& x, Integer val)
boost::multiprecision::backends::eval_is_zero	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline bool eval_is_zero(const cpp_dec_float<Digits10, ExponentType, Allocator>& val) $/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
boost::multiprecision::backends::eval_is_zero	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline bool eval_is_zero(const rational_adapter<IntBackend>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const rational_adapter<IntBackend>& val)
boost::multiprecision::backends::eval_is_zero	/usr/include/boost/multiprecision/tommath.hpp	/^inline bool eval_is_zero(const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
boost::multiprecision::backends::eval_lcm	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_lcm(tommath_int& result, const tommath_int& a, const tommath_int& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& a, const tommath_int& b)
boost::multiprecision::backends::eval_ldexp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_ldexp(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ArgType e)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ArgType e)
boost::multiprecision::backends::eval_ldexp	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_ldexp(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long e)
boost::multiprecision::backends::eval_left_shift	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_left_shift(tommath_int& t, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, UI i)
boost::multiprecision::backends::eval_left_shift	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_left_shift(tommath_int& t, const tommath_int& v, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& v, UI i)
boost::multiprecision::backends::eval_lsb	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_lsb(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)
boost::multiprecision::backends::eval_lsb	/usr/include/boost/multiprecision/tommath.hpp	/^inline unsigned eval_lsb(const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
boost::multiprecision::backends::eval_modulus	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o)
boost::multiprecision::backends::eval_modulus	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b)
boost::multiprecision::backends::eval_modulus	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, limb_type b)
boost::multiprecision::backends::eval_modulus	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, signed_limb_type b)
boost::multiprecision::backends::eval_modulus	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& b)
boost::multiprecision::backends::eval_modulus	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, limb_type b)
boost::multiprecision::backends::eval_modulus	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, signed_limb_type b)
boost::multiprecision::backends::eval_modulus	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_modulus(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
boost::multiprecision::backends::eval_modulus	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_modulus(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_multiply(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_multiply(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_multiply(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^   eval_multiply($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> const& a, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> const& b)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^   eval_multiply($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, double_limb_type a, double_limb_type b)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^   eval_multiply($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, signed_double_limb_type a, signed_double_limb_type b)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline void eval_multiply(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_multiply(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_multiply(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
boost::multiprecision::backends::eval_multiply	/usr/include/boost/multiprecision/tommath.hpp	/^void eval_multiply(tommath_int& t, const tommath_int& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
boost::multiprecision::backends::eval_pow	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_pow(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& b, const mpfr_float_backend<Digits10, AllocateType>& e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& b, const mpfr_float_backend<Digits10, AllocateType>& e)
boost::multiprecision::backends::eval_powm	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_powm(tommath_int& result, const tommath_int& base, const tommath_int& p, const tommath_int& m)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& base, const tommath_int& p, const tommath_int& m)
boost::multiprecision::backends::eval_qr	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_qr(const tommath_int& x, const tommath_int& y, $/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& x, const tommath_int& y, tommath_int& q, tommath_int& r)
boost::multiprecision::backends::eval_right_shift	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_right_shift(tommath_int& t, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, UI i)
boost::multiprecision::backends::eval_right_shift	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_right_shift(tommath_int& t, const tommath_int& v, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& v, UI i)
boost::multiprecision::backends::eval_sqrt	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_sqrt(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
boost::multiprecision::backends::eval_sqrt	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_sqrt(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
boost::multiprecision::backends::eval_subtract	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_subtract(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
boost::multiprecision::backends::eval_subtract	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_subtract(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
boost::multiprecision::backends::eval_subtract	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_subtract(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
boost::multiprecision::backends::eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
boost::multiprecision::backends::eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
boost::multiprecision::backends::eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
boost::multiprecision::backends::eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
boost::multiprecision::backends::eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
boost::multiprecision::backends::eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
boost::multiprecision::backends::eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
boost::multiprecision::backends::eval_subtract	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline void eval_subtract(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)
boost::multiprecision::backends::eval_subtract	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_subtract(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
boost::multiprecision::backends::eval_subtract	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_subtract(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
boost::multiprecision::backends::eval_trunc	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_trunc(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
boost::multiprecision::backends::eval_trunc	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_trunc(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
boost::multiprecision::backends::find_lsb	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(limb_type mask, const Tag&)$/;"	f	namespace:boost::multiprecision::backends	signature:(limb_type mask, const Tag&)
boost::multiprecision::backends::find_lsb	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(limb_type mask, const mpl::int_<32>&)$/;"	f	namespace:boost::multiprecision::backends	signature:(limb_type mask, const mpl::int_<32>&)
boost::multiprecision::backends::find_lsb	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(limb_type mask, const mpl::int_<64>&)$/;"	f	namespace:boost::multiprecision::backends	signature:(limb_type mask, const mpl::int_<64>&)
boost::multiprecision::backends::find_lsb	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^inline unsigned find_lsb(Unsigned mask, const Tag&)$/;"	f	namespace:boost::multiprecision::backends	signature:(Unsigned mask, const Tag&)
boost::multiprecision::backends::find_lsb_imp	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^BOOST_FORCEINLINE unsigned find_lsb_imp(limb_type mask, mpl::false_ const&)$/;"	f	namespace:boost::multiprecision::backends	signature:(limb_type mask, mpl::false_ const&)
boost::multiprecision::backends::find_lsb_imp	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^BOOST_FORCEINLINE unsigned find_lsb_imp(limb_type mask, mpl::true_ const&)$/;"	f	namespace:boost::multiprecision::backends	signature:(limb_type mask, mpl::true_ const&)
boost::multiprecision::backends::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^struct gmp_float : public detail::gmp_float_imp<digits10>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::gmp_float_imp
boost::multiprecision::backends::gmp_float::BOOST_NOEXCEPT	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(gmp_float&& o) BOOST_NOEXCEPT : detail::gmp_float_imp<digits10>(static_cast<detail::gmp_float_imp<digits10>&&>(o)) {}$/;"	m	struct:boost::multiprecision::backends::gmp_float	access:public
boost::multiprecision::backends::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   explicit gmp_float(const gmp_float<D>& o, typename disable_if_c<D <= digits10>::type* = 0);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_float<D>& o, typename disable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float()$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:()
boost::multiprecision::backends::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_float& o) : detail::gmp_float_imp<digits10>(o) {}$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_float& o)
boost::multiprecision::backends::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_float<D>& o, typename enable_if_c<D <= digits10>::type* = 0);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_float<D>& o, typename enable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_int& o);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_int& o)
boost::multiprecision::backends::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_rational& o)
boost::multiprecision::backends::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const mpf_t val)$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const mpf_t val)
boost::multiprecision::backends::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const mpq_t val)$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const mpq_t val)
boost::multiprecision::backends::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const mpz_t val)$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const mpz_t val)
boost::multiprecision::backends::integer_gcd_reduce	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^inline double_limb_type integer_gcd_reduce(double_limb_type u, double_limb_type v)$/;"	f	namespace:boost::multiprecision::backends	signature:(double_limb_type u, double_limb_type v)
boost::multiprecision::backends::integer_gcd_reduce	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^inline limb_type integer_gcd_reduce(limb_type u, limb_type v)$/;"	f	namespace:boost::multiprecision::backends	signature:(limb_type u, limb_type v)
boost::multiprecision::backends::is_fixed_precision	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_fixed_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends	inherits:mpl::bool_
boost::multiprecision::backends::is_implicit_cpp_int_conversion	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_implicit_cpp_int_conversion<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::is_implicit_cpp_int_conversion::t1	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> t1;$/;"	t	struct:boost::multiprecision::backends::is_implicit_cpp_int_conversion	access:public
boost::multiprecision::backends::is_implicit_cpp_int_conversion::t2	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> t2;$/;"	t	struct:boost::multiprecision::backends::is_implicit_cpp_int_conversion	access:public
boost::multiprecision::backends::is_implicit_cpp_int_conversion::value	/usr/include/boost/multiprecision/cpp_int.hpp	/^   static const bool value =$/;"	m	struct:boost::multiprecision::backends::is_implicit_cpp_int_conversion	access:public
boost::multiprecision::backends::is_non_throwing_cpp_int	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_non_throwing_cpp_int : public mpl::false_{};$/;"	s	namespace:boost::multiprecision::backends	inherits:mpl::false_
boost::multiprecision::backends::is_non_throwing_cpp_int	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_non_throwing_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, unchecked, void> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision::backends	inherits:mpl::true_
boost::multiprecision::backends::is_trivial_cpp_int	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_trivial_cpp_int$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::is_trivial_cpp_int	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::is_trivial_cpp_int	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_trivial_cpp_int<cpp_int_base<MinBits, MaxBits, SignType, Checked, Allocator, true> >$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::is_trivial_cpp_int::self	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> self;$/;"	t	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
boost::multiprecision::backends::is_trivial_cpp_int::value	/usr/include/boost/multiprecision/cpp_int.hpp	/^   static const bool value = false;$/;"	m	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
boost::multiprecision::backends::is_trivial_cpp_int::value	/usr/include/boost/multiprecision/cpp_int.hpp	/^   static const bool value = is_void<Allocator>::value && (max_precision<self>::value <= (sizeof(double_limb_type) * CHAR_BIT) - (SignType == signed_packed ? 1 : 0));$/;"	m	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
boost::multiprecision::backends::is_trivial_cpp_int::value	/usr/include/boost/multiprecision/cpp_int.hpp	/^   static const bool value = true;$/;"	m	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
boost::multiprecision::backends::is_valid_bitwise_op	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^void is_valid_bitwise_op($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::int_<checked>&)
boost::multiprecision::backends::is_valid_bitwise_op	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^void is_valid_bitwise_op($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>&, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& , const mpl::int_<unchecked>&)
boost::multiprecision::backends::m_data	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base() BOOST_NOEXCEPT : m_data(), m_limbs(1), m_sign(false), m_internal(true) {}$/;"	p	namespace:boost::multiprecision::backends	signature:()
boost::multiprecision::backends::m_internal	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base() BOOST_NOEXCEPT : m_data(), m_limbs(1), m_sign(false), m_internal(true) {}$/;"	f	namespace:boost::multiprecision::backends	signature:(true)
boost::multiprecision::backends::m_sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base() BOOST_NOEXCEPT : m_data(), m_limbs(1), m_sign(false), m_internal(true) {}$/;"	p	namespace:boost::multiprecision::backends	signature:(false)
boost::multiprecision::backends::max_precision	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct max_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::max_precision::value	/usr/include/boost/multiprecision/cpp_int.hpp	/^   static const unsigned value = is_void<Allocator>::value ?$/;"	m	struct:boost::multiprecision::backends::max_precision	access:public
boost::multiprecision::backends::min_precision	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct min_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::min_precision::value	/usr/include/boost/multiprecision/cpp_int.hpp	/^   static const unsigned value = (is_void<Allocator>::value ? static_unsigned_max<MinBits, MaxBits>::value : MinBits);$/;"	m	struct:boost::multiprecision::backends::min_precision	access:public
boost::multiprecision::backends::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^struct mpfr_float_backend : public detail::mpfr_float_imp<digits10, AllocationType>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::mpfr_float_imp
boost::multiprecision::backends::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^struct mpfr_float_backend<0, allocate_dynamic> : public detail::mpfr_float_imp<0, allocate_dynamic>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::mpfr_float_imp
boost::multiprecision::backends::mpfr_float_backend::BOOST_NOEXCEPT	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(mpfr_float_backend&& o) BOOST_NOEXCEPT : detail::mpfr_float_imp<0, allocate_dynamic>(static_cast<detail::mpfr_float_imp<0, allocate_dynamic>&&>(o)) {}$/;"	m	struct:boost::multiprecision::backends::mpfr_float_backend	access:public
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   explicit mpfr_float_backend(const mpfr_float_backend<D, AT>& val, typename disable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D, AT>& val, typename disable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend() : detail::mpfr_float_imp<0, allocate_dynamic>() {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:()
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend() : detail::mpfr_float_imp<digits10, AllocationType>() {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:()
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_float<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_float<D>& val, typename disable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val, typename disable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_float<D>& val, typename enable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val, typename enable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_int& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_int& val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_rational& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_rational& val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpf_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpf_t val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend& o) : detail::mpfr_float_imp<0, allocate_dynamic>(o) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend& o) : detail::mpfr_float_imp<digits10, AllocationType>(o) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend& o, unsigned digits10)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o, unsigned digits10)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend<D, AT>& val, typename enable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D, AT>& val, typename enable_if_c<D <= digits10>::type* = 0)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D>& val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_t val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpq_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpq_t val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpz_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpz_t val)
boost::multiprecision::backends::mpfr_float_backend::mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(mpfr_float_backend&& o) : detail::mpfr_float_imp<digits10, AllocationType>(static_cast<detail::mpfr_float_imp<digits10, AllocationType>&&>(o)) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(mpfr_float_backend&& o)
boost::multiprecision::backends::mpfr_float_backend::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const V& v)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const V& v)
boost::multiprecision::backends::mpfr_float_backend::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const gmp_float<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val)
boost::multiprecision::backends::mpfr_float_backend::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const gmp_int& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_int& val)
boost::multiprecision::backends::mpfr_float_backend::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const gmp_rational& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_rational& val)
boost::multiprecision::backends::mpfr_float_backend::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpf_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpf_t val)
boost::multiprecision::backends::mpfr_float_backend::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_float_backend& o)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o)
boost::multiprecision::backends::mpfr_float_backend::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_float_backend<D, AT>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D, AT>& val)
boost::multiprecision::backends::mpfr_float_backend::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_float_backend<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D>& val)
boost::multiprecision::backends::mpfr_float_backend::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_t val)
boost::multiprecision::backends::mpfr_float_backend::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpq_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpq_t val)
boost::multiprecision::backends::mpfr_float_backend::operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpz_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpz_t val)
boost::multiprecision::backends::mpfr_float_backend::static_cast	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(mpfr_float_backend&& o) BOOST_NOEXCEPT : detail::mpfr_float_imp<0, allocate_dynamic>(static_cast<detail::mpfr_float_imp<0, allocate_dynamic>&&>(o)) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(o)
boost::multiprecision::backends::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const V& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(const V& v)
boost::multiprecision::backends::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_float<D>& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(const gmp_float<D>& o)
boost::multiprecision::backends::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_int& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(const gmp_int& o)
boost::multiprecision::backends::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_rational& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(const gmp_rational& o)
boost::multiprecision::backends::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpf_t val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpf_t val)
boost::multiprecision::backends::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpq_t val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpq_t val)
boost::multiprecision::backends::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpz_t val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpz_t val)
boost::multiprecision::backends::rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^struct rational_adapter$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::rational_adapter::compare	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   int compare(const rational_adapter& o)const$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const rational_adapter& o) const
boost::multiprecision::backends::rational_adapter::compare	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typename enable_if<is_arithmetic<Arithmatic>, int>::type compare(Arithmatic i)const$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(Arithmatic i) const
boost::multiprecision::backends::rational_adapter::data	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   const rational_type& data()const { return m_value; }$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:() const
boost::multiprecision::backends::rational_adapter::data	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_type& data() { return m_value; }$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:()
boost::multiprecision::backends::rational_adapter::float_types	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef typename IntBackend::float_types     float_types;$/;"	t	struct:boost::multiprecision::backends::rational_adapter	access:public
boost::multiprecision::backends::rational_adapter::integer_type	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef number<IntBackend>                integer_type;$/;"	t	struct:boost::multiprecision::backends::rational_adapter	access:public
boost::multiprecision::backends::rational_adapter::m_value	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_type m_value;$/;"	m	struct:boost::multiprecision::backends::rational_adapter	access:private
boost::multiprecision::backends::rational_adapter::negate	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:()
boost::multiprecision::backends::rational_adapter::operator =	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter& operator = (const IntBackend& o)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const IntBackend& o)
boost::multiprecision::backends::rational_adapter::operator =	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const char* s)
boost::multiprecision::backends::rational_adapter::operator =	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter& operator = (const rational_adapter& o)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const rational_adapter& o)
boost::multiprecision::backends::rational_adapter::operator =	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter& operator = (rational_adapter&& o)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(rational_adapter&& o)
boost::multiprecision::backends::rational_adapter::operator =	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typename enable_if<is_floating_point<Float>, rational_adapter&>::type operator = (Float i)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(Float i)
boost::multiprecision::backends::rational_adapter::operator =	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typename enable_if<is_integral<Int>, rational_adapter&>::type operator = (Int i)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(Int i)
boost::multiprecision::backends::rational_adapter::operator =	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typename enable_if_c<(boost::multiprecision::detail::is_explicitly_convertible<U, IntBackend>::value && !is_arithmetic<U>::value), rational_adapter&>::type operator = (const U& u) $/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const U& u)
boost::multiprecision::backends::rational_adapter::rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   explicit rational_adapter(const U& u, $/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const U& u, typename enable_if_c< boost::multiprecision::detail::is_explicitly_convertible<U, IntBackend>::value && !is_convertible<U, IntBackend>::value >::type* = 0)
boost::multiprecision::backends::rational_adapter::rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter(){}$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:()
boost::multiprecision::backends::rational_adapter::rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter(IntBackend&& o) : m_value(o) {}$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(IntBackend&& o)
boost::multiprecision::backends::rational_adapter::rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter(const IntBackend& o) : m_value(o) {}$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const IntBackend& o)
boost::multiprecision::backends::rational_adapter::rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter(const U& u, typename enable_if_c<is_convertible<U, IntBackend>::value>::type* = 0) $/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const U& u, typename enable_if_c<is_convertible<U, IntBackend>::value>::type* = 0)
boost::multiprecision::backends::rational_adapter::rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter(const rational_adapter& o)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const rational_adapter& o)
boost::multiprecision::backends::rational_adapter::rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter(rational_adapter&& o) : m_value(o.m_value) {}$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(rational_adapter&& o)
boost::multiprecision::backends::rational_adapter::rational_type	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef boost::rational<integer_type>        rational_type;$/;"	t	struct:boost::multiprecision::backends::rational_adapter	access:public
boost::multiprecision::backends::rational_adapter::signed_types	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef typename IntBackend::signed_types    signed_types;$/;"	t	struct:boost::multiprecision::backends::rational_adapter	access:public
boost::multiprecision::backends::rational_adapter::str	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
boost::multiprecision::backends::rational_adapter::swap	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   void swap(rational_adapter& o)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(rational_adapter& o)
boost::multiprecision::backends::rational_adapter::unsigned_types	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef typename IntBackend::unsigned_types  unsigned_types;$/;"	t	struct:boost::multiprecision::backends::rational_adapter	access:public
boost::multiprecision::backends::resize_for_carry	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^inline void resize_for_carry(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& \/*result*\/, unsigned \/*required*\/){}$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& , unsigned )
boost::multiprecision::backends::resize_for_carry	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^inline void resize_for_carry(cpp_int_backend<MinBits1, MaxBits1, SignType1, checked, void>& result, unsigned required)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, checked, void>& result, unsigned required)
boost::multiprecision::backends::tommath_int	/usr/include/boost/multiprecision/tommath.hpp	/^struct tommath_int$/;"	s	namespace:boost::multiprecision::backends
boost::multiprecision::backends::tommath_int::compare	/usr/include/boost/multiprecision/tommath.hpp	/^   int compare(V v)const$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(V v) const
boost::multiprecision::backends::tommath_int::compare	/usr/include/boost/multiprecision/tommath.hpp	/^   int compare(const tommath_int& o)const$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const tommath_int& o) const
boost::multiprecision::backends::tommath_int::data	/usr/include/boost/multiprecision/tommath.hpp	/^   ::mp_int& data() $/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
boost::multiprecision::backends::tommath_int::data	/usr/include/boost/multiprecision/tommath.hpp	/^   const ::mp_int& data()const $/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:() const
boost::multiprecision::backends::tommath_int::float_types	/usr/include/boost/multiprecision/tommath.hpp	/^   typedef mpl::list<long double>                           float_types;$/;"	t	struct:boost::multiprecision::backends::tommath_int	access:public
boost::multiprecision::backends::tommath_int::m_data	/usr/include/boost/multiprecision/tommath.hpp	/^   ::mp_int m_data;$/;"	m	struct:boost::multiprecision::backends::tommath_int	access:protected
boost::multiprecision::backends::tommath_int::negate	/usr/include/boost/multiprecision/tommath.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
boost::multiprecision::backends::tommath_int::operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (boost::int32_t i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(boost::int32_t i)
boost::multiprecision::backends::tommath_int::operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (boost::uint32_t i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(boost::uint32_t i)
boost::multiprecision::backends::tommath_int::operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const char* s)
boost::multiprecision::backends::tommath_int::operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (const tommath_int& o)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const tommath_int& o)
boost::multiprecision::backends::tommath_int::operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (long double a)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(long double a)
boost::multiprecision::backends::tommath_int::operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (long long i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(long long i)
boost::multiprecision::backends::tommath_int::operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (tommath_int&& o)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(tommath_int&& o)
boost::multiprecision::backends::tommath_int::operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(unsigned long long i)
boost::multiprecision::backends::tommath_int::signed_types	/usr/include/boost/multiprecision/tommath.hpp	/^   typedef mpl::list<boost::int32_t, long long>             signed_types;$/;"	t	struct:boost::multiprecision::backends::tommath_int	access:public
boost::multiprecision::backends::tommath_int::str	/usr/include/boost/multiprecision/tommath.hpp	/^   std::string str(std::streamsize \/*digits*\/, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(std::streamsize , std::ios_base::fmtflags f) const
boost::multiprecision::backends::tommath_int::tommath_int	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int()$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
boost::multiprecision::backends::tommath_int::tommath_int	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int(const tommath_int& o)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const tommath_int& o)
boost::multiprecision::backends::tommath_int::unsigned_types	/usr/include/boost/multiprecision/tommath.hpp	/^   typedef mpl::list<boost::uint32_t, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::backends::tommath_int	access:public
boost::multiprecision::backends::tommath_int::~tommath_int	/usr/include/boost/multiprecision/tommath.hpp	/^   ~tommath_int()$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
boost::multiprecision::bit_flip	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   bit_flip(number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& x, unsigned index)
boost::multiprecision::bit_flip	/usr/include/boost/multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer&>::type bit_flip(Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(Integer& val, unsigned index)
boost::multiprecision::bit_set	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   bit_set(number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& x, unsigned index)
boost::multiprecision::bit_set	/usr/include/boost/multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer&>::type bit_set(Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(Integer& val, unsigned index)
boost::multiprecision::bit_test	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   bit_test(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, unsigned index)
boost::multiprecision::bit_test	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   bit_test(const number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, unsigned index)
boost::multiprecision::bit_test	/usr/include/boost/multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, bool>::type bit_test(const Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& val, unsigned index)
boost::multiprecision::bit_unset	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   bit_unset(number<Backend, ExpressionTemplates>& x, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& x, unsigned index)
boost::multiprecision::bit_unset	/usr/include/boost/multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, Integer&>::type bit_unset(Integer& val, unsigned index)$/;"	f	namespace:boost::multiprecision	signature:(Integer& val, unsigned index)
boost::multiprecision::bits_per_limb	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^static const unsigned bits_per_limb = sizeof(limb_type) * CHAR_BIT;$/;"	m	namespace:boost::multiprecision
boost::multiprecision::block_multiplier	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^inline limb_type block_multiplier(unsigned count)$/;"	f	namespace:boost::multiprecision	signature:(unsigned count)
boost::multiprecision::checked	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   checked = 1,$/;"	e	enum:boost::multiprecision::cpp_int_check_type
boost::multiprecision::compare	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE typename enable_if<is_arithmetic<Arithmetic>, int>::type compare(Arithmetic i)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(Arithmetic i) const
boost::multiprecision::compare_imp	/usr/include/boost/multiprecision/cpp_int.hpp	/^   int compare_imp(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::false_&, const mpl::true_&)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::false_&, const mpl::true_&) const
boost::multiprecision::compare_imp	/usr/include/boost/multiprecision/cpp_int.hpp	/^   int compare_imp(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::true_&, const mpl::false_&)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::true_&, const mpl::false_&) const
boost::multiprecision::component_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct component_type<detail::expression<tag, A1, A2, A3, A4> > : public component_type<typename detail::expression<tag, A1, A2, A3, A4>::result_type>{};$/;"	s	namespace:boost::multiprecision	inherits:component_type
boost::multiprecision::component_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct component_type<number<T, ExpressionTemplates> > : public component_type<T>{};$/;"	s	namespace:boost::multiprecision	inherits:component_type
boost::multiprecision::component_type	/usr/include/boost/multiprecision/rational_adapter.hpp	/^struct component_type<rational_adapter<T> >$/;"	s	namespace:boost::multiprecision
boost::multiprecision::component_type::type	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef number<T> type;$/;"	t	struct:boost::multiprecision::component_type	access:public
boost::multiprecision::concepts	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^namespace concepts{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::concepts::eval_add	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_add(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
boost::multiprecision::concepts::eval_ceil	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_ceil(number_backend_float_architype& result, const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg)
boost::multiprecision::concepts::eval_convert_to	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_convert_to(long double* result, number_backend_float_architype& val)$/;"	f	namespace:boost::multiprecision::concepts	signature:(long double* result, number_backend_float_architype& val)
boost::multiprecision::concepts::eval_convert_to	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_convert_to(long long* result, const number_backend_float_architype& val)$/;"	f	namespace:boost::multiprecision::concepts	signature:(long long* result, const number_backend_float_architype& val)
boost::multiprecision::concepts::eval_convert_to	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_convert_to(unsigned long long* result, const number_backend_float_architype& val)$/;"	f	namespace:boost::multiprecision::concepts	signature:(unsigned long long* result, const number_backend_float_architype& val)
boost::multiprecision::concepts::eval_divide	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_divide(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
boost::multiprecision::concepts::eval_floor	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_floor(number_backend_float_architype& result, const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg)
boost::multiprecision::concepts::eval_fpclassify	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline int eval_fpclassify(const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(const number_backend_float_architype& arg)
boost::multiprecision::concepts::eval_frexp	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_frexp(number_backend_float_architype& result, const number_backend_float_architype& arg, int* exp)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg, int* exp)
boost::multiprecision::concepts::eval_ldexp	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_ldexp(number_backend_float_architype& result, const number_backend_float_architype& arg, int exp)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg, int exp)
boost::multiprecision::concepts::eval_multiply	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_multiply(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
boost::multiprecision::concepts::eval_sqrt	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_sqrt(number_backend_float_architype& result, const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg)
boost::multiprecision::concepts::eval_subtract	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_subtract(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
boost::multiprecision::concepts::mp_number_float_architype	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^typedef boost::multiprecision::number<number_backend_float_architype> mp_number_float_architype;$/;"	t	namespace:boost::multiprecision::concepts
boost::multiprecision::concepts::number_backend_float_architype	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^struct number_backend_float_architype$/;"	s	namespace:boost::multiprecision::concepts
boost::multiprecision::concepts::number_backend_float_architype::compare	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(const number_backend_float_architype& o)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const number_backend_float_architype& o) const
boost::multiprecision::concepts::number_backend_float_architype::compare	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(long double d)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long double d) const
boost::multiprecision::concepts::number_backend_float_architype::compare	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(long long i)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long long i) const
boost::multiprecision::concepts::number_backend_float_architype::compare	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(unsigned long long i)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(unsigned long long i) const
boost::multiprecision::concepts::number_backend_float_architype::exponent_type	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef int                                  exponent_type;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
boost::multiprecision::concepts::number_backend_float_architype::float_types	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef mpl::list<long double>               float_types;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
boost::multiprecision::concepts::number_backend_float_architype::m_value	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   long double m_value;$/;"	m	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
boost::multiprecision::concepts::number_backend_float_architype::negate	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:()
boost::multiprecision::concepts::number_backend_float_architype::number_backend_float_architype	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype()$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:()
boost::multiprecision::concepts::number_backend_float_architype::number_backend_float_architype	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype(const number_backend_float_architype& o)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const number_backend_float_architype& o)
boost::multiprecision::concepts::number_backend_float_architype::operator =	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (const char* s)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const char* s)
boost::multiprecision::concepts::number_backend_float_architype::operator =	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (const number_backend_float_architype& o)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const number_backend_float_architype& o)
boost::multiprecision::concepts::number_backend_float_architype::operator =	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (long double d)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long double d)
boost::multiprecision::concepts::number_backend_float_architype::operator =	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (long long i)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long long i)
boost::multiprecision::concepts::number_backend_float_architype::operator =	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(unsigned long long i)
boost::multiprecision::concepts::number_backend_float_architype::signed_types	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef mpl::list<long long>                 signed_types;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
boost::multiprecision::concepts::number_backend_float_architype::str	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
boost::multiprecision::concepts::number_backend_float_architype::swap	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   void swap(number_backend_float_architype& o)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(number_backend_float_architype& o)
boost::multiprecision::concepts::number_backend_float_architype::unsigned_types	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef mpl::list<unsigned long long>        unsigned_types;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
boost::multiprecision::cpp_dec_float_100	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^typedef number<cpp_dec_float<100> > cpp_dec_float_100;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::cpp_dec_float_50	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^typedef number<cpp_dec_float<50> > cpp_dec_float_50;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::cpp_int_backend	/usr/include/boost/multiprecision/cpp_int.hpp	/^   explicit cpp_int_backend(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other,$/;"	f	namespace:boost::multiprecision	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other, typename enable_if_c< (!((is_signed_number<cpp_int_backend<MinBits, MaxBits, SignType, Allocator> >::value || !is_signed_number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2> >::value) && (!is_void<Allocator>::value || (is_void<Allocator2>::value && (MinBits >= MinBits2)))) && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2> >::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Allocator> >::value) >::type* = 0)
boost::multiprecision::cpp_int_backend	/usr/include/boost/multiprecision/cpp_int.hpp	/^   explicit cpp_int_backend(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other,$/;"	f	namespace:boost::multiprecision	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other, typename enable_if_c< (!((is_signed_number<cpp_int_backend<MinBits, MaxBits, SignType, Allocator> >::value || !is_signed_number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2> >::value)) && (!is_void<Allocator>::value || (is_void<Allocator2>::value && (MinBits >= MinBits2))) && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Allocator> >::value) >::type* = 0)
boost::multiprecision::cpp_int_backend	/usr/include/boost/multiprecision/cpp_int.hpp	/^   explicit cpp_int_backend(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other,$/;"	f	namespace:boost::multiprecision	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other, typename enable_if_c< (!((is_signed_number<cpp_int_backend<MinBits, MaxBits, SignType, Allocator> >::value || !is_signed_number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2> >::value)) && (!is_void<Allocator>::value || (is_void<Allocator2>::value && (MinBits >= MinBits2))) && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2> >::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Allocator> >::value) >::type* = 0)
boost::multiprecision::cpp_int_base	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct cpp_int_base<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator, false> : private Allocator::template rebind<limb_type>::other$/;"	s	namespace:boost::multiprecision	inherits:Allocator::,rebind::other
boost::multiprecision::cpp_int_base	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct cpp_int_base<MinBits, MinBits, signed_magnitude, Checked, void, false>$/;"	s	namespace:boost::multiprecision
boost::multiprecision::cpp_int_base::BOOST_NOEXCEPT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::cpp_int_base	access:public
boost::multiprecision::cpp_int_base::BOOST_NOEXCEPT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_double_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::cpp_int_base	access:public
boost::multiprecision::cpp_int_base::BOOST_NOEXCEPT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base(signed_limb_type i)BOOST_NOEXCEPT$/;"	m	struct:boost::multiprecision::cpp_int_base	access:public
boost::multiprecision::cpp_int_base::BOOST_STATIC_ASSERT_MSG	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_ASSERT_MSG(((sizeof(Allocator) == 0) && !is_void<Allocator>::value), "There is curently no support for unsigned arbitrary precision integers.");$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:((sizeof(Allocator) == 0) && !is_void<Allocator>::value), Ó
boost::multiprecision::cpp_int_base::BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(bool, variable = false);$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(bool, variable = false)
boost::multiprecision::cpp_int_base::BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, max_limb_value = ~static_cast<limb_type>(0u));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(limb_type, max_limb_value = ~static_cast<limb_type>(0u))
boost::multiprecision::cpp_int_base::BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, sign_bit_mask = 1u << (limb_bits - 1));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(limb_type, sign_bit_mask = 1u << (limb_bits - 1))
boost::multiprecision::cpp_int_base::BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(limb_type, upper_limb_mask = MinBits % limb_bits ? (limb_type(1) << (MinBits % limb_bits)) -1 : (~limb_type(0)));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(limb_type, upper_limb_mask = MinBits % limb_bits ? (limb_type(1) << (MinBits % limb_bits)) -1 : (~limb_type(0)))
boost::multiprecision::cpp_int_base::BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, internal_limb_count = MinBits \/ limb_bits + (MinBits % limb_bits ? 1 : 0));$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(unsigned, internal_limb_count = MinBits / limb_bits + (MinBits % limb_bits ? 1 : 0))
boost::multiprecision::cpp_int_base::BOOST_STATIC_CONSTANT	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_STATIC_CONSTANT(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT);$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(unsigned, limb_bits = sizeof(limb_type) * CHAR_BIT)
boost::multiprecision::cpp_int_base::checked_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef mpl::int_<Checked>              checked_type;$/;"	t	struct:boost::multiprecision::cpp_int_base	access:public
boost::multiprecision::cpp_int_base::const_limb_pointer	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef const limb_type*                const_limb_pointer;$/;"	t	struct:boost::multiprecision::cpp_int_base	access:public
boost::multiprecision::cpp_int_base::data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^   union data_type{$/;"	u	struct:boost::multiprecision::cpp_int_base	access:private
boost::multiprecision::cpp_int_base::data_type::data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type() : m_first_limb(0) {}$/;"	f	union:boost::multiprecision::cpp_int_base::data_type	access:public	signature:()
boost::multiprecision::cpp_int_base::data_type::data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(double_limb_type i) : m_double_first_limb(i) {}$/;"	f	union:boost::multiprecision::cpp_int_base::data_type	access:public	signature:(double_limb_type i)
boost::multiprecision::cpp_int_base::data_type::data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(limb_type i) : m_first_limb(i) {}$/;"	f	union:boost::multiprecision::cpp_int_base::data_type	access:public	signature:(limb_type i)
boost::multiprecision::cpp_int_base::data_type::m_data	/usr/include/boost/multiprecision/cpp_int.hpp	/^      limb_type          m_data[internal_limb_count];$/;"	m	union:boost::multiprecision::cpp_int_base::data_type	access:public
boost::multiprecision::cpp_int_base::data_type::m_double_first_limb	/usr/include/boost/multiprecision/cpp_int.hpp	/^      double_limb_type   m_double_first_limb;$/;"	m	union:boost::multiprecision::cpp_int_base::data_type	access:public
boost::multiprecision::cpp_int_base::data_type::m_first_limb	/usr/include/boost/multiprecision/cpp_int.hpp	/^      limb_type          m_first_limb;$/;"	m	union:boost::multiprecision::cpp_int_base::data_type	access:public
boost::multiprecision::cpp_int_base::internal_limb_count	/usr/include/boost/multiprecision/cpp_int.hpp	/^const unsigned cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::internal_limb_count;$/;"	m	class:boost::multiprecision::cpp_int_base
boost::multiprecision::cpp_int_base::limb_bits	/usr/include/boost/multiprecision/cpp_int.hpp	/^const unsigned cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::limb_bits;$/;"	m	class:boost::multiprecision::cpp_int_base
boost::multiprecision::cpp_int_base::limb_pointer	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef limb_type*                      limb_pointer;$/;"	t	struct:boost::multiprecision::cpp_int_base	access:public
boost::multiprecision::cpp_int_base::limbs	/usr/include/boost/multiprecision/cpp_int.hpp	/^      std::copy(other.limbs(), other.limbs() + (std::min)(other.size(), this->size()), this->limbs());$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:()
boost::multiprecision::cpp_int_base::m_limbs	/usr/include/boost/multiprecision/cpp_int.hpp	/^   boost::uint16_t    m_limbs;$/;"	m	struct:boost::multiprecision::cpp_int_base	access:private
boost::multiprecision::cpp_int_base::m_sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^      : m_wrapper(i), m_limbs(1), m_sign(false) {}$/;"	f	struct:boost::multiprecision::cpp_int_base	access:public	signature:(false)
boost::multiprecision::cpp_int_base::m_sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^      : m_wrapper(i), m_limbs(i > max_limb_value ? 2 : 1), m_sign(false) {}$/;"	f	struct:boost::multiprecision::cpp_int_base	access:public	signature:(false)
boost::multiprecision::cpp_int_base::m_sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^   bool               m_sign;$/;"	m	struct:boost::multiprecision::cpp_int_base	access:private
boost::multiprecision::cpp_int_base::m_wrapper	/usr/include/boost/multiprecision/cpp_int.hpp	/^   } m_wrapper;$/;"	m	struct:boost::multiprecision::cpp_int_base	typeref:union:boost::multiprecision::cpp_int_base::data_type	access:private
boost::multiprecision::cpp_int_base::max_limb_value	/usr/include/boost/multiprecision/cpp_int.hpp	/^const limb_type cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::max_limb_value;$/;"	m	class:boost::multiprecision::cpp_int_base
boost::multiprecision::cpp_int_base::sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^      this->sign(other.sign());$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(other.sign())
boost::multiprecision::cpp_int_base::sign_bit_mask	/usr/include/boost/multiprecision/cpp_int.hpp	/^const limb_type cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::sign_bit_mask;$/;"	m	class:boost::multiprecision::cpp_int_base
boost::multiprecision::cpp_int_base::variable	/usr/include/boost/multiprecision/cpp_int.hpp	/^const bool cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::variable;$/;"	m	class:boost::multiprecision::cpp_int_base
boost::multiprecision::cpp_int_check_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^enum cpp_int_check_type$/;"	g	namespace:boost::multiprecision
boost::multiprecision::cpp_integer_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^enum cpp_integer_type$/;"	g	namespace:boost::multiprecision
boost::multiprecision::default_ops	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^namespace boost{ namespace multiprecision{ namespace default_ops{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::default_ops	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^namespace default_ops$/;"	n	namespace:boost::multiprecision
boost::multiprecision::default_ops	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^namespace default_ops{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::default_ops::assign_components	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void assign_components(T& result, const V& v1, const V& v2)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const V& v1, const V& v2)
boost::multiprecision::default_ops::assign_components_imp	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void assign_components_imp(T& result, const V& v1, const V& v2, const mpl::int_<number_kind_rational>&)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const V& v1, const V& v2, const mpl::int_<number_kind_rational>&)
boost::multiprecision::default_ops::calculate_next_larger_type	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^struct calculate_next_larger_type$/;"	s	namespace:boost::multiprecision::default_ops
boost::multiprecision::default_ops::calculate_next_larger_type::iter_type	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   >::type iter_type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
boost::multiprecision::default_ops::calculate_next_larger_type::list_type	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   >::type list_type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
boost::multiprecision::default_ops::calculate_next_larger_type::pred_type	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   typedef typename has_enough_bits<R, std::numeric_limits<R>::digits>::template type<mpl::_> pred_type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
boost::multiprecision::default_ops::calculate_next_larger_type::type	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^      >::type type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
boost::multiprecision::default_ops::check_in_range	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool check_in_range(const T& t)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& t)
boost::multiprecision::default_ops::check_in_range	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool check_in_range(const terminal<T>&)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const terminal<T>&)
boost::multiprecision::default_ops::eval_abs	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_abs(T& result, const T& arg)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg)
boost::multiprecision::default_ops::eval_add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_add(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_add(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_add(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_add_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_add_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_add_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_add_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_add_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_add_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_add_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_add_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_add_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_add_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bit_flip	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bit_flip(T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val, unsigned index)
boost::multiprecision::default_ops::eval_bit_set	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bit_set(T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val, unsigned index)
boost::multiprecision::default_ops::eval_bit_test	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool eval_bit_test(const T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val, unsigned index)
boost::multiprecision::default_ops::eval_bit_unset	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bit_unset(T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val, unsigned index)
boost::multiprecision::default_ops::eval_bitwise_and	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_bitwise_and(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_bitwise_and	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_and(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_and	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_bitwise_and(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_and_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_bitwise_and_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_bitwise_and_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_bitwise_and_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_bitwise_and_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_and_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_bitwise_and_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_and_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_bitwise_and_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_and_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_or	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_bitwise_or(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_bitwise_or	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_or(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_or	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_bitwise_or(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_or_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_bitwise_or_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_bitwise_or_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_bitwise_or_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_bitwise_or_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_or_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_bitwise_or_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_or_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_bitwise_or_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_or_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_xor	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_bitwise_xor(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_bitwise_xor	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_xor(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_xor	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_bitwise_xor(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_bitwise_xor_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_bitwise_xor_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_bitwise_xor_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_bitwise_xor_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_bitwise_xor_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_xor_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_bitwise_xor_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_xor_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_bitwise_xor_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_xor_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_ceil	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_ceil();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
boost::multiprecision::default_ops::eval_complement	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_complement(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_convert_to	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_convert_to(R* result, const B& backend)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(R* result, const B& backend)
boost::multiprecision::default_ops::eval_convert_to	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_convert_to(std::string* result, const B& backend)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(std::string* result, const B& backend)
boost::multiprecision::default_ops::eval_convert_to	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_convert_to(terminal<R>* result, const B& backend)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(terminal<R>* result, const B& backend)
boost::multiprecision::default_ops::eval_decrement	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_decrement(T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val)
boost::multiprecision::default_ops::eval_divide	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_divide(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_divide	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_divide(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_divide	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_divide(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_divide_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_divide_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_divide_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_divide_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_divide_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_divide_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_divide_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_divide_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_divide_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_divide_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_divide_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_divide_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_eq	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool eval_eq(const B& a, const A& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const A& b)
boost::multiprecision::default_ops::eval_eq	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool eval_eq(const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const B& b)
boost::multiprecision::default_ops::eval_fabs	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_fabs(T& result, const T& arg)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg)
boost::multiprecision::default_ops::eval_floor	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_floor();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
boost::multiprecision::default_ops::eval_fmod	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_arithmetic<A>, void>::type eval_fmod(T& result, const A& x, const T& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const A& x, const T& a)
boost::multiprecision::default_ops::eval_fmod	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_arithmetic<A>, void>::type eval_fmod(T& result, const T& x, const A& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& x, const A& a)
boost::multiprecision::default_ops::eval_fmod	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_fmod(T& result, const T& a, const T& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a, const T& b)
boost::multiprecision::default_ops::eval_fpclassify	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int eval_fpclassify(const Backend& arg)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const Backend& arg)
boost::multiprecision::default_ops::eval_frexp	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_frexp();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
boost::multiprecision::default_ops::eval_gcd	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_gcd(T& result, const Arithmetic& a, const T& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const Arithmetic& a, const T& b)
boost::multiprecision::default_ops::eval_gcd	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_gcd(T& result, const T& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a, const Arithmetic& b)
boost::multiprecision::default_ops::eval_gcd	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_gcd(B& result, const B& a, const B& b);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
boost::multiprecision::default_ops::eval_gcd	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^inline void eval_gcd(B& result, const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
boost::multiprecision::default_ops::eval_get_sign	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int eval_get_sign(const T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val)
boost::multiprecision::default_ops::eval_gt	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool eval_gt(const B& a, const A& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const A& b)
boost::multiprecision::default_ops::eval_gt	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool eval_gt(const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const B& b)
boost::multiprecision::default_ops::eval_increment	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_increment(T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val)
boost::multiprecision::default_ops::eval_integer_modulus	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^inline Integer eval_integer_modulus(const Backend& x, Integer val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const Backend& x, Integer val)
boost::multiprecision::default_ops::eval_is_zero	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool eval_is_zero(const T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val)
boost::multiprecision::default_ops::eval_lcm	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_lcm(T& result, const Arithmetic& a, const T& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const Arithmetic& a, const T& b)
boost::multiprecision::default_ops::eval_lcm	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_lcm(T& result, const T& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a, const Arithmetic& b)
boost::multiprecision::default_ops::eval_lcm	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_lcm(B& result, const B& a, const B& b);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
boost::multiprecision::default_ops::eval_lcm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^inline void eval_lcm(B& result, const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
boost::multiprecision::default_ops::eval_ldexp	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_ldexp();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
boost::multiprecision::default_ops::eval_left_shift	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_left_shift(T& result, const T& arg, const V val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg, const V val)
boost::multiprecision::default_ops::eval_lsb	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline unsigned eval_lsb(const T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val)
boost::multiprecision::default_ops::eval_lt	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool eval_lt(const B& a, const A& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const A& b)
boost::multiprecision::default_ops::eval_lt	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool eval_lt(const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const B& b)
boost::multiprecision::default_ops::eval_modulus	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_modulus(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_modulus	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_modulus(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_modulus	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_modulus(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_modulus_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_modulus_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_modulus_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_modulus_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_modulus_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_modulus_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_modulus_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_modulus_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_modulus_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_modulus_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_modulus_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_modulus_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_multiply(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_multiply	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_multiply(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_multiply(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply_add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply_add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
boost::multiprecision::default_ops::eval_multiply_add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply_add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
boost::multiprecision::default_ops::eval_multiply_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_multiply_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_multiply_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_multiply_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_multiply_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_multiply_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_multiply_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_multiply_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_multiply_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_multiply_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply_subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply_subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
boost::multiprecision::default_ops::eval_multiply_subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_multiply_subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
boost::multiprecision::default_ops::eval_qr	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^inline void eval_qr(const Backend& x, const Backend& y, Backend& q, Backend& r)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const Backend& x, const Backend& y, Backend& q, Backend& r)
boost::multiprecision::default_ops::eval_right_shift	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_right_shift(T& result, const T& arg, const V val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg, const V val)
boost::multiprecision::default_ops::eval_round	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_round(T& result, const T& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a)
boost::multiprecision::default_ops::eval_sqrt	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_sqrt();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
boost::multiprecision::default_ops::eval_subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_subtract(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
boost::multiprecision::default_ops::eval_subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_subtract(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_subtract(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_subtract_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_subtract_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_subtract_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_subtract_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
boost::multiprecision::default_ops::eval_subtract_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_signed_number<T>::value>::type eval_subtract_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_subtract_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_unsigned_number<T>::value>::type eval_subtract_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
boost::multiprecision::default_ops::eval_subtract_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_subtract_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
boost::multiprecision::default_ops::eval_subtract_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_subtract_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
boost::multiprecision::default_ops::eval_trunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_trunc(T& result, const T& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a)
boost::multiprecision::default_ops::eval_trunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_trunc();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
boost::multiprecision::default_ops::has_enough_bits	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^struct has_enough_bits$/;"	s	namespace:boost::multiprecision::default_ops
boost::multiprecision::default_ops::has_enough_bits::type	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   struct type : public mpl::and_<mpl::not_<is_same<R, T> >, mpl::bool_<std::numeric_limits<T>::digits >= b> >{};$/;"	s	struct:boost::multiprecision::default_ops::has_enough_bits	inherits:mpl::and_	access:public
boost::multiprecision::default_ops::terminal	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^struct terminal$/;"	s	namespace:boost::multiprecision::default_ops
boost::multiprecision::default_ops::terminal::operator =	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   terminal& operator = (R val) {  value = val;  }$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:(R val)
boost::multiprecision::default_ops::terminal::operator R	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   operator R()const {  return value;  }$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:() const
boost::multiprecision::default_ops::terminal::terminal	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   terminal(){}$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:()
boost::multiprecision::default_ops::terminal::terminal	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   terminal(const R& v) : value(v){}$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:(const R& v)
boost::multiprecision::default_ops::terminal::value	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   R value;$/;"	m	struct:boost::multiprecision::default_ops::terminal	access:public
boost::multiprecision::denominator	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline number<IntBackend, ET> denominator(const number<rational_adapter<IntBackend>, ET>& val)$/;"	f	namespace:boost::multiprecision	signature:(const number<rational_adapter<IntBackend>, ET>& val)
boost::multiprecision::detail	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	/usr/include/boost/multiprecision/detail/digits.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	/usr/include/boost/multiprecision/detail/number_base.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	/usr/include/boost/multiprecision/integer.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	/usr/include/boost/multiprecision/miller_rabin.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	/usr/include/boost/multiprecision/number.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	/usr/include/boost/multiprecision/rational_adapter.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
boost::multiprecision::detail::abs_funct	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^struct abs_funct$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::abs_funct::operator ()	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   void operator()(Backend& result, const Backend& arg)const$/;"	f	struct:boost::multiprecision::detail::abs_funct	access:public	signature:(Backend& result, const Backend& arg) const
boost::multiprecision::detail::add_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct add_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::arg_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct arg_type$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::arg_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct arg_type<expression<Tag, Arg1, Arg2, Arg3, Arg4> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::arg_type::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef expression<Tag, Arg1, Arg2, Arg3, Arg4> type;$/;"	t	struct:boost::multiprecision::detail::arg_type	access:public
boost::multiprecision::detail::arg_type::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef expression<terminal, T> type;$/;"	t	struct:boost::multiprecision::detail::arg_type	access:public
boost::multiprecision::detail::backend_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct backend_type<expression<tag, A1, A2, A3, A4> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::backend_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct backend_type<number<T, ExpressionTemplates> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::backend_type::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef T type;$/;"	t	struct:boost::multiprecision::detail::backend_type	access:public
boost::multiprecision::detail::backend_type::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename backend_type<typename expression<tag, A1, A2, A3, A4>::result_type>::type type;$/;"	t	struct:boost::multiprecision::detail::backend_type	access:public
boost::multiprecision::detail::bits_of	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bits_of$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::bits_of::value	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned value =$/;"	m	struct:boost::multiprecision::detail::bits_of	access:public
boost::multiprecision::detail::bitwise_and	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bitwise_and{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::bitwise_and_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bitwise_and_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::bitwise_complement	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bitwise_complement{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::bitwise_or	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bitwise_or{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::bitwise_or_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bitwise_or_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::bitwise_xor	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bitwise_xor{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::bitwise_xor_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct bitwise_xor_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical::tag_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   >::type tag_type;$/;"	t	struct:boost::multiprecision::detail::canonical	access:public
boost::multiprecision::detail::canonical::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename canonical_imp<Val, Backend, tag_type>::type type;$/;"	t	struct:boost::multiprecision::detail::canonical	access:public
boost::multiprecision::detail::canonical_imp	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical_imp$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical_imp	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<0> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical_imp	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<1> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical_imp	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<2> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical_imp	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<3> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical_imp	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical_imp<number<B, et_off>, Backend, Tag>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical_imp	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical_imp<number<B, et_on>, Backend, Tag>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::canonical_imp::iter_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   >::type iter_type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
boost::multiprecision::detail::canonical_imp::pred_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename has_enough_bits<bits_of<Val>::value>::template type<mpl::_> pred_type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
boost::multiprecision::detail::canonical_imp::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef B type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
boost::multiprecision::detail::canonical_imp::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef const char* type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
boost::multiprecision::detail::canonical_imp::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename mpl::deref<iter_type>::type type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
boost::multiprecision::detail::canonical_imp::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename remove_cv<typename decay<const Val>::type>::type type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
boost::multiprecision::detail::cast_to_unsigned	/usr/include/boost/multiprecision/miller_rabin.hpp	/^   cast_to_unsigned(const I& val)$/;"	f	namespace:boost::multiprecision::detail	signature:(const I& val)
boost::multiprecision::detail::check_shift_range	/usr/include/boost/multiprecision/detail/number_base.hpp	/^void check_shift_range(V val, const mpl::false_&, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::detail	signature:(V val, const mpl::false_&, const mpl::true_&)
boost::multiprecision::detail::check_shift_range	/usr/include/boost/multiprecision/detail/number_base.hpp	/^void check_shift_range(V val, const mpl::true_&, const mpl::false_&)$/;"	f	namespace:boost::multiprecision::detail	signature:(V val, const mpl::true_&, const mpl::false_&)
boost::multiprecision::detail::check_shift_range	/usr/include/boost/multiprecision/detail/number_base.hpp	/^void check_shift_range(V val, const mpl::true_&, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::detail	signature:(V val, const mpl::true_&, const mpl::true_&)
boost::multiprecision::detail::check_small_factors	/usr/include/boost/multiprecision/miller_rabin.hpp	/^bool check_small_factors(const I& n)$/;"	f	namespace:boost::multiprecision::detail	signature:(const I& n)
boost::multiprecision::detail::combine_expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct combine_expression$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::combine_expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct combine_expression<T1, number<T2, ExpressionTemplates> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::combine_expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct combine_expression<number<T, ExpressionTemplates>, number<T, ExpressionTemplates> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::combine_expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct combine_expression<number<T1, ExpressionTemplates1>, number<T2, ExpressionTemplates2> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::combine_expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct combine_expression<number<T1, ExpressionTemplates>, T2>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::combine_expression::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^      >::type type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
boost::multiprecision::detail::combine_expression::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef number<T, ExpressionTemplates> type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
boost::multiprecision::detail::combine_expression::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef number<T1, ExpressionTemplates> type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
boost::multiprecision::detail::combine_expression::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef number<T2, ExpressionTemplates> type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
boost::multiprecision::detail::combine_expression::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename mpl::if_c<(sizeof(T1() + T2()) == sizeof(T1)), T1, T2>::type type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
boost::multiprecision::detail::complement_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct complement_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::digits10_2_2	/usr/include/boost/multiprecision/detail/digits.hpp	/^inline unsigned long digits10_2_2(unsigned long d10)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long d10)
boost::multiprecision::detail::digits2	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct digits2$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::digits2::BOOST_STATIC_ASSERT	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   BOOST_STATIC_ASSERT((std::numeric_limits<T>::radix == 2) || (std::numeric_limits<T>::radix == 10));$/;"	p	struct:boost::multiprecision::detail::digits2	access:public	signature:(std::numeric_limits<T>::radix == 2) || (std::numeric_limits<T>::radix == 10)
boost::multiprecision::detail::digits2::BOOST_STATIC_ASSERT	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   BOOST_STATIC_ASSERT(std::numeric_limits<T>::is_specialized);$/;"	p	struct:boost::multiprecision::detail::digits2	access:public	signature:(std::numeric_limits<T>::is_specialized)
boost::multiprecision::detail::digits2::value	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const long value = std::numeric_limits<T>::radix == 10 ?  (((std::numeric_limits<T>::digits + 1) * 1000L) \/ 301L) : std::numeric_limits<T>::digits;$/;"	m	struct:boost::multiprecision::detail::digits2	access:public
boost::multiprecision::detail::digits2_2_10	/usr/include/boost/multiprecision/detail/digits.hpp	/^inline unsigned long digits2_2_10(unsigned long d2)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long d2)
boost::multiprecision::detail::divide_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct divide_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::divides	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct divides{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::double_integer	/usr/include/boost/multiprecision/integer.hpp	/^struct double_integer$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::double_integer::int_t_digits	/usr/include/boost/multiprecision/integer.hpp	/^   static const unsigned int_t_digits =$/;"	m	struct:boost::multiprecision::detail::double_integer	access:public
boost::multiprecision::detail::double_integer::mpl::if_c	/usr/include/boost/multiprecision/integer.hpp	/^   typedef typename mpl::if_c<$/;"	t	class:boost::multiprecision::detail::double_integer::mpl	access:public
boost::multiprecision::detail::double_precision_type	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^struct double_precision_type$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::double_precision_type::type	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   typedef Backend type;$/;"	t	struct:boost::multiprecision::detail::double_precision_type	access:public
boost::multiprecision::detail::dummy_size	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^struct dummy_size{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::eval_powm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_signed<Integer1> >::type eval_powm(Backend& result, const Backend& a, Integer1 b, Integer2 c)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend& result, const Backend& a, Integer1 b, Integer2 c)
boost::multiprecision::detail::eval_powm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_signed<Integer> >::type eval_powm(Backend& result, const Backend& a, Integer b, const Backend& c)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend& result, const Backend& a, Integer b, const Backend& c)
boost::multiprecision::detail::eval_powm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_unsigned<Integer1> >::type eval_powm(Backend& result, const Backend& a, Integer1 b, Integer2 c)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend& result, const Backend& a, Integer1 b, Integer2 c)
boost::multiprecision::detail::eval_powm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_unsigned<Integer> >::type eval_powm(Backend& result, const Backend& a, Integer b, const Backend& c)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend& result, const Backend& a, Integer b, const Backend& c)
boost::multiprecision::detail::eval_powm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^void eval_powm(Backend& result, const Backend& a, const Backend& p, Integer c)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend& result, const Backend& a, const Backend& p, Integer c)
boost::multiprecision::detail::eval_powm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^void eval_powm(Backend& result, const Backend& a, const Backend& p, const Backend& c)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend& result, const Backend& a, const Backend& p, const Backend& c)
boost::multiprecision::detail::expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression<tag, Arg1, Arg2, Arg3, void>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression<tag, Arg1, Arg2, void, void>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression<tag, Arg1, void, void, void>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression<terminal, Arg1, void, void, void>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression::arg	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg1>::type arg;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
boost::multiprecision::detail::expression::arg1	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg1>::type arg1;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
boost::multiprecision::detail::expression::arg2	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg2>::type arg2;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
boost::multiprecision::detail::expression::arg3	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg3>::type arg3;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
boost::multiprecision::detail::expression::arg4	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typename expression_storage<Arg4>::type arg4;$/;"	m	struct:boost::multiprecision::detail::expression	access:private
boost::multiprecision::detail::expression::arity	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<0> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::arity	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<1> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::arity	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<2> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::arity	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<3> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::arity	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef mpl::int_<4> arity;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned depth = 0;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_depth > right_depth ? (left_depth > middle_depth ? left_depth : middle_depth) : (right_depth > middle_depth ? right_depth : middle_depth);$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_depth > right_depth ? left_depth : right_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_max_depth > right_max_depth ? left_max_depth : right_max_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   explicit expression(const Arg1& a) : arg(a) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a)
boost::multiprecision::detail::expression::expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   expression(const Arg1& a1, const Arg2& a2) : arg1(a1), arg2(a2) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a1, const Arg2& a2)
boost::multiprecision::detail::expression::expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   expression(const Arg1& a1, const Arg2& a2, const Arg3& a3) : arg1(a1), arg2(a2), arg3(a3) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a1, const Arg2& a2, const Arg3& a3)
boost::multiprecision::detail::expression::expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   expression(const Arg1& a1, const Arg2& a2, const Arg3& a3, const Arg4& a4) : arg1(a1), arg2(a2), arg3(a3), arg4(a4) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a1, const Arg2& a2, const Arg3& a3, const Arg4& a4)
boost::multiprecision::detail::expression::left	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   left_type left()const { return left_type(arg); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::left	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   left_type left()const { return left_type(arg1); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::left_depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned left_depth = left_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::left_max_depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned left_max_depth = left_depth > left_middle_depth ? left_depth : left_middle_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::left_middle	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   left_middle_type left_middle()const { return left_middle_type(arg2); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::left_middle_depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned left_middle_depth = left_middle_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::left_middle_result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename left_middle_type::result_type left_middle_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::left_middle_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg2>::type left_middle_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::left_result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename left_type::result_type left_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::left_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg1>::type left_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::middle	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   middle_type middle()const { return middle_type(arg2); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::middle_depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned middle_depth = middle_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::middle_result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename middle_type::result_type middle_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::middle_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg2>::type middle_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::operator =	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   expression& operator=(const expression&);$/;"	p	struct:boost::multiprecision::detail::expression	access:private	signature:(const expression&)
boost::multiprecision::detail::expression::operator unmentionable_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   operator unmentionable_type()const$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   >::type result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef Arg1 result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename combine_expression<left_result_type, right_result_type>::type result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename left_type::result_type result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   right_type right()const { return right_type(arg2); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::right	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   right_type right()const { return right_type(arg3); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::right	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   right_type right()const { return right_type(arg4); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::right_depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned right_depth = right_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_max_depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned right_max_depth = right_depth > right_middle_depth ? right_depth : right_middle_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_middle	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   right_middle_type right_middle()const { return right_middle_type(arg3); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
boost::multiprecision::detail::expression::right_middle_depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned right_middle_depth = right_middle_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_middle_result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename right_middle_type::result_type right_middle_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_middle_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg3>::type right_middle_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename right_type::result_type right_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg2>::type right_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg3>::type right_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::right_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg4>::type right_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::tag_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef tag tag_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression::tag_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef terminal tag_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
boost::multiprecision::detail::expression_storage	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression_storage$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression_storage	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression_storage<T*>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression_storage	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression_storage<const T*>$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression_storage	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression_storage<expression<tag, A1, A2, A3, A4> >$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::expression_storage::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef T* type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
boost::multiprecision::detail::expression_storage::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef const T& type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
boost::multiprecision::detail::expression_storage::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef const T* type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
boost::multiprecision::detail::expression_storage::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef expression<tag, A1, A2, A3, A4> type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
boost::multiprecision::detail::format_float_string	/usr/include/boost/multiprecision/detail/number_base.hpp	/^void format_float_string(S& str, boost::intmax_t my_exp, boost::intmax_t digits, std::ios_base::fmtflags f, bool iszero)$/;"	f	namespace:boost::multiprecision::detail	signature:(S& str, boost::intmax_t my_exp, boost::intmax_t digits, std::ios_base::fmtflags f, bool iszero)
boost::multiprecision::detail::function	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct function{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::generic_interconvert	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& \/*to_type*\/, const mpl::int_<number_kind_floating_point>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_floating_point>& )
boost::multiprecision::detail::generic_interconvert	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& \/*to_type*\/, const mpl::int_<number_kind_integer>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_integer>& )
boost::multiprecision::detail::generic_interconvert	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& \/*to_type*\/, const mpl::int_<number_kind_rational>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_rational>& )
boost::multiprecision::detail::generic_interconvert	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_integer>& \/*to_type*\/, const mpl::int_<number_kind_integer>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_integer>& , const mpl::int_<number_kind_integer>& )
boost::multiprecision::detail::generic_interconvert	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_rational>& \/*to_type*\/, const mpl::int_<number_kind_integer>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_rational>& , const mpl::int_<number_kind_integer>& )
boost::multiprecision::detail::generic_interconvert	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_rational>& \/*to_type*\/, const mpl::int_<number_kind_rational>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_rational>& , const mpl::int_<number_kind_rational>& )
boost::multiprecision::detail::has_enough_bits	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct has_enough_bits$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::has_enough_bits::type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   struct type : public mpl::bool_<bits_of<T>::value>= b>{};$/;"	s	struct:boost::multiprecision::detail::has_enough_bits	inherits:mpl::bool_,b	access:public
boost::multiprecision::detail::has_generic_interconversion	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^struct has_generic_interconversion$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::has_generic_interconversion::type	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::has_generic_interconversion	access:public
boost::multiprecision::detail::is_explicitly_convertible	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^struct is_explicitly_convertible<cpp_dec_float<D1, E1, A1>, cpp_dec_float<D2, E2, A2> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::true_
boost::multiprecision::detail::is_explicitly_convertible	/usr/include/boost/multiprecision/rational_adapter.hpp	/^struct is_explicitly_convertible<U, rational_adapter<IntBackend> > : public is_explicitly_convertible<U, IntBackend> {};$/;"	s	namespace:boost::multiprecision::detail	inherits:is_explicitly_convertible
boost::multiprecision::detail::is_explicitly_convertible	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^struct is_explicitly_convertible : public is_explicitly_convertible_imp<From, To>::type$/;"	s	namespace:boost::multiprecision::detail	inherits:is_explicitly_convertible_imp::type
boost::multiprecision::detail::is_explicitly_convertible_imp	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^struct is_explicitly_convertible_imp$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::is_explicitly_convertible_imp::selector	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^   static type_traits::no_type selector(...);$/;"	p	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public	signature:(....)
boost::multiprecision::detail::is_explicitly_convertible_imp::selector	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^   static type_traits::yes_type selector(dummy_size<sizeof(static_cast<T1>(declval<S1>()))>*);$/;"	p	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public	signature:(dummy_size<sizeof(static_cast<T1>(declval<S1>()))>*)
boost::multiprecision::detail::is_explicitly_convertible_imp::type	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^   typedef boost::integral_constant<bool,value> type;$/;"	t	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public
boost::multiprecision::detail::is_explicitly_convertible_imp::value	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^   static const bool value = sizeof(selector<S,T>(0)) == sizeof(type_traits::yes_type);$/;"	m	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public
boost::multiprecision::detail::is_lossy_conversion	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^struct is_lossy_conversion$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::is_lossy_conversion::type	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::is_lossy_conversion	access:public
boost::multiprecision::detail::is_lossy_conversion::value	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^   static const bool value = type::value;$/;"	m	struct:boost::multiprecision::detail::is_lossy_conversion	access:public
boost::multiprecision::detail::is_restricted_conversion	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^struct is_restricted_conversion$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::is_restricted_conversion::type	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::is_restricted_conversion	access:public
boost::multiprecision::detail::is_restricted_conversion::value	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^   static const bool value = type::value;$/;"	m	struct:boost::multiprecision::detail::is_restricted_conversion	access:public
boost::multiprecision::detail::is_small_prime	/usr/include/boost/multiprecision/miller_rabin.hpp	/^inline bool is_small_prime(unsigned n)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned n)
boost::multiprecision::detail::is_valid_mixed_compare	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::false_
boost::multiprecision::detail::is_valid_mixed_compare	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> > $/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::bool_
boost::multiprecision::detail::is_valid_mixed_compare	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<number<B, ET>, Val> : public is_convertible<Val, number<B, ET> > {};$/;"	s	namespace:boost::multiprecision::detail	inherits:is_convertible
boost::multiprecision::detail::is_valid_mixed_compare	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<number<B, ET>, expression<tag, Arg1, Arg2, Arg3, Arg4> > $/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::bool_
boost::multiprecision::detail::is_valid_mixed_compare	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<number<B, ET>, number<B, ET> > : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::false_
boost::multiprecision::detail::largest_signed_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^struct largest_signed_type$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::largest_signed_type::type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::largest_signed_type	access:public
boost::multiprecision::detail::largest_unsigned_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^struct largest_unsigned_type$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::largest_unsigned_type::type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::largest_unsigned_type	access:public
boost::multiprecision::detail::minus	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct minus{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::modulus	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct modulus{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::modulus_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct modulus_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::multiplies	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct multiplies{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::multiply_add	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct multiply_add{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::multiply_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct multiply_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::multiply_subtract	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct multiply_subtract{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::negate	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct negate{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::operator <<	/usr/include/boost/multiprecision/number.hpp	/^inline std::ostream& operator << (std::ostream& os, const expression<tag, A1, A2, A3, A4>& r)$/;"	f	namespace:boost::multiprecision::detail	signature:(std::ostream& os, const expression<tag, A1, A2, A3, A4>& r)
boost::multiprecision::detail::plus	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct plus{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::powm_func	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^struct powm_func$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::powm_func::operator ()	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   void operator()(T& result, const T& b, const U& p, const V& m)const$/;"	f	struct:boost::multiprecision::detail::powm_func	access:public	signature:(T& result, const T& b, const U& p, const V& m) const
boost::multiprecision::detail::shift_left	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct shift_left{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::shift_right	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct shift_right{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::subtract_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct subtract_immediates{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::terminal	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct terminal{};$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::unmentionable	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct unmentionable$/;"	s	namespace:boost::multiprecision::detail
boost::multiprecision::detail::unmentionable::proc	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static void proc(){}$/;"	f	struct:boost::multiprecision::detail::unmentionable	access:public	signature:()
boost::multiprecision::detail::unmentionable_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^typedef void (*unmentionable_type)();$/;"	t	namespace:boost::multiprecision::detail
boost::multiprecision::digits_per_block_10	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^static const limb_type digits_per_block_10 = 18;$/;"	m	namespace:boost::multiprecision
boost::multiprecision::divide_qr	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   divide_qr(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>& y,$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
boost::multiprecision::divide_qr	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   divide_qr(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const number<Backend, ExpressionTemplates>& y,$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const number<Backend, ExpressionTemplates>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
boost::multiprecision::divide_qr	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   divide_qr(const number<Backend, ExpressionTemplates>& x, const multiprecision::detail::expression<tag, A1, A2, A3, A4>& y,$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, const multiprecision::detail::expression<tag, A1, A2, A3, A4>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
boost::multiprecision::divide_qr	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   divide_qr(const number<Backend, ExpressionTemplates>& x, const number<Backend, ExpressionTemplates>& y,$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, const number<Backend, ExpressionTemplates>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
boost::multiprecision::divide_qr	/usr/include/boost/multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value>::type divide_qr(const Integer& x, const Integer& y, Integer& q, Integer& r)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& x, const Integer& y, Integer& q, Integer& r)
boost::multiprecision::do_assign_arithmetic	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typename disable_if<is_unsigned<A> >::type do_assign_arithmetic(A val, const mpl::true_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(A val, const mpl::true_&)
boost::multiprecision::do_assign_arithmetic	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typename enable_if<is_unsigned<A> >::type do_assign_arithmetic(A val, const mpl::true_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(A val, const mpl::true_&)
boost::multiprecision::do_assign_arithmetic	/usr/include/boost/multiprecision/cpp_int.hpp	/^   void do_assign_arithmetic(double_limb_type i, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(double_limb_type i, const mpl::false_&)
boost::multiprecision::do_assign_arithmetic	/usr/include/boost/multiprecision/cpp_int.hpp	/^   void do_assign_arithmetic(long double a, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(long double a, const mpl::false_&)
boost::multiprecision::do_assign_arithmetic	/usr/include/boost/multiprecision/cpp_int.hpp	/^   void do_assign_arithmetic(signed_double_limb_type i, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(signed_double_limb_type i, const mpl::false_&)
boost::multiprecision::do_assign_string	/usr/include/boost/multiprecision/cpp_int.hpp	/^   void do_assign_string(const char* s, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(const char* s, const mpl::false_&)
boost::multiprecision::do_assign_string	/usr/include/boost/multiprecision/cpp_int.hpp	/^   void do_assign_string(const char* s, const mpl::true_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(const char* s, const mpl::true_&)
boost::multiprecision::do_get_string	/usr/include/boost/multiprecision/cpp_int.hpp	/^   std::string do_get_string(std::ios_base::fmtflags f, const mpl::false_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::false_&) const
boost::multiprecision::do_get_string	/usr/include/boost/multiprecision/cpp_int.hpp	/^   std::string do_get_string(std::ios_base::fmtflags f, const mpl::true_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::true_&) const
boost::multiprecision::do_get_trivial_string	/usr/include/boost/multiprecision/cpp_int.hpp	/^   std::string do_get_trivial_string(std::ios_base::fmtflags f, const mpl::false_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::false_&) const
boost::multiprecision::do_get_trivial_string	/usr/include/boost/multiprecision/cpp_int.hpp	/^   std::string do_get_trivial_string(std::ios_base::fmtflags f, const mpl::true_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::true_&) const
boost::multiprecision::double_limb_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^typedef boost::uint128_type double_limb_type;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::et_off	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   et_off  = 0,$/;"	e	enum:boost::multiprecision::expression_template_option
boost::multiprecision::et_on	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   et_on   = 1$/;"	e	enum:boost::multiprecision::expression_template_option
boost::multiprecision::eval_abs	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_abs(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
boost::multiprecision::eval_abs	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_abs(gmp_int& result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& val)
boost::multiprecision::eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
boost::multiprecision::eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
boost::multiprecision::eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
boost::multiprecision::eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
boost::multiprecision::eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
boost::multiprecision::eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
boost::multiprecision::eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
boost::multiprecision::eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
boost::multiprecision::eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
boost::multiprecision::eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
boost::multiprecision::eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
boost::multiprecision::eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
boost::multiprecision::eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
boost::multiprecision::eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
boost::multiprecision::eval_bitwise_and	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_bitwise_and(gmp_int& result, const gmp_int& u, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u, const gmp_int& v)
boost::multiprecision::eval_bitwise_and	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_bitwise_and(gmp_int& result, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& v)
boost::multiprecision::eval_bitwise_or	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_bitwise_or(gmp_int& result, const gmp_int& u, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u, const gmp_int& v)
boost::multiprecision::eval_bitwise_or	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_bitwise_or(gmp_int& result, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& v)
boost::multiprecision::eval_bitwise_xor	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_bitwise_xor(gmp_int& result, const gmp_int& u, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u, const gmp_int& v)
boost::multiprecision::eval_bitwise_xor	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_bitwise_xor(gmp_int& result, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& v)
boost::multiprecision::eval_ceil	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_ceil(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
boost::multiprecision::eval_complement	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_complement(gmp_int& result, const gmp_int& u)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u)
boost::multiprecision::eval_convert_to	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_convert_to(double* result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(double* result, const gmp_int& val)
boost::multiprecision::eval_convert_to	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_convert_to(long long* result, const gmp_float<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(long long* result, const gmp_float<digits10>& val)
boost::multiprecision::eval_convert_to	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_convert_to(long* result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(long* result, const gmp_int& val)
boost::multiprecision::eval_convert_to	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_convert_to(unsigned long long* result, const gmp_float<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(unsigned long long* result, const gmp_float<digits10>& val)
boost::multiprecision::eval_convert_to	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_convert_to(unsigned long* result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(unsigned long* result, const gmp_int& val)
boost::multiprecision::eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
boost::multiprecision::eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
boost::multiprecision::eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
boost::multiprecision::eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
boost::multiprecision::eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
boost::multiprecision::eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
boost::multiprecision::eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
boost::multiprecision::eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
boost::multiprecision::eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
boost::multiprecision::eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
boost::multiprecision::eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
boost::multiprecision::eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
boost::multiprecision::eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
boost::multiprecision::eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
boost::multiprecision::eval_eq	/usr/include/boost/multiprecision/gmp.hpp	/^inline typename enable_if<is_arithmetic<T>, bool>::type eval_eq(const gmp_int& a, const T& b)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& a, const T& b)
boost::multiprecision::eval_fabs	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_fabs(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
boost::multiprecision::eval_floor	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_floor(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
boost::multiprecision::eval_frexp	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_frexp(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, int* e)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, int* e)
boost::multiprecision::eval_frexp	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_frexp(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long* e)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long* e)
boost::multiprecision::eval_gcd	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_gcd(gmp_int& result, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& a, const gmp_int& b)
boost::multiprecision::eval_get_sign	/usr/include/boost/multiprecision/gmp.hpp	/^inline int eval_get_sign(const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& val)
boost::multiprecision::eval_gt	/usr/include/boost/multiprecision/gmp.hpp	/^inline typename enable_if<is_arithmetic<T>, bool>::type eval_gt(const gmp_int& a, const T& b)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& a, const T& b)
boost::multiprecision::eval_is_zero	/usr/include/boost/multiprecision/gmp.hpp	/^inline bool eval_is_zero(const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& val)
boost::multiprecision::eval_lcm	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_lcm(gmp_int& result, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& a, const gmp_int& b)
boost::multiprecision::eval_ldexp	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_ldexp(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long e)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long e)
boost::multiprecision::eval_left_shift	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_left_shift(gmp_int& t, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, UI i)
boost::multiprecision::eval_left_shift	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_left_shift(gmp_int& t, const gmp_int& v, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& v, UI i)
boost::multiprecision::eval_lt	/usr/include/boost/multiprecision/gmp.hpp	/^inline typename enable_if<is_arithmetic<T>, bool>::type eval_lt(const gmp_int& a, const T& b)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& a, const T& b)
boost::multiprecision::eval_modulus	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
boost::multiprecision::eval_modulus	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
boost::multiprecision::eval_modulus	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
boost::multiprecision::eval_modulus	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
boost::multiprecision::eval_modulus	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
boost::multiprecision::eval_modulus	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
boost::multiprecision::eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
boost::multiprecision::eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
boost::multiprecision::eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
boost::multiprecision::eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
boost::multiprecision::eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
boost::multiprecision::eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
boost::multiprecision::eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
boost::multiprecision::eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
boost::multiprecision::eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
boost::multiprecision::eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
boost::multiprecision::eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
boost::multiprecision::eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
boost::multiprecision::eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
boost::multiprecision::eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
boost::multiprecision::eval_multiply_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply_add(gmp_int& t, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, const gmp_int& b)
boost::multiprecision::eval_multiply_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply_add(gmp_int& t, const gmp_int& a, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, long i)
boost::multiprecision::eval_multiply_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply_add(gmp_int& t, const gmp_int& a, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, unsigned long i)
boost::multiprecision::eval_multiply_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply_subtract(gmp_int& t, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, const gmp_int& b)
boost::multiprecision::eval_multiply_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply_subtract(gmp_int& t, const gmp_int& a, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, long i)
boost::multiprecision::eval_multiply_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply_subtract(gmp_int& t, const gmp_int& a, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, unsigned long i)
boost::multiprecision::eval_right_shift	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_right_shift(gmp_int& t, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, UI i)
boost::multiprecision::eval_right_shift	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_right_shift(gmp_int& t, const gmp_int& v, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& v, UI i)
boost::multiprecision::eval_sqrt	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_sqrt(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
boost::multiprecision::eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
boost::multiprecision::eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
boost::multiprecision::eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
boost::multiprecision::eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
boost::multiprecision::eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
boost::multiprecision::eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
boost::multiprecision::eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
boost::multiprecision::eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
boost::multiprecision::eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
boost::multiprecision::eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
boost::multiprecision::eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
boost::multiprecision::eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
boost::multiprecision::eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
boost::multiprecision::eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
boost::multiprecision::eval_trunc	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_trunc(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
boost::multiprecision::expression_template_default	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression_template_default$/;"	s	namespace:boost::multiprecision
boost::multiprecision::expression_template_default	/usr/include/boost/multiprecision/rational_adapter.hpp	/^struct expression_template_default<backends::rational_adapter<IntBackend> > : public expression_template_default<IntBackend> {};$/;"	s	namespace:boost::multiprecision	inherits:expression_template_default
boost::multiprecision::expression_template_default::value	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const expression_template_option value = et_on;$/;"	m	struct:boost::multiprecision::expression_template_default	access:public
boost::multiprecision::expression_template_option	/usr/include/boost/multiprecision/detail/number_base.hpp	/^enum expression_template_option$/;"	g	namespace:boost::multiprecision
boost::multiprecision::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^struct gmp_float<0> : public detail::gmp_float_imp<0>$/;"	s	namespace:boost::multiprecision	inherits:detail::gmp_float_imp
boost::multiprecision::gmp_float::BOOST_NOEXCEPT	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(gmp_float&& o) BOOST_NOEXCEPT : detail::gmp_float_imp<0>(static_cast<detail::gmp_float_imp<0>&&>(o)) {}$/;"	m	struct:boost::multiprecision::gmp_float	access:public
boost::multiprecision::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float()$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:()
boost::multiprecision::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_float& o) : detail::gmp_float_imp<0>(o) {}$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float& o)
boost::multiprecision::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_float& o, unsigned digits10)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float& o, unsigned digits10)
boost::multiprecision::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_float<D>& o)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float<D>& o)
boost::multiprecision::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_rational& o)
boost::multiprecision::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpf_t val)
boost::multiprecision::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpq_t val)
boost::multiprecision::gmp_float::gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpz_t val)
boost::multiprecision::gmp_float::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const V& v)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const V& v)
boost::multiprecision::gmp_float::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_float& o)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float& o)
boost::multiprecision::gmp_float::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_float<D>& o)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float<D>& o)
boost::multiprecision::gmp_float::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_int& o);$/;"	p	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_int& o)
boost::multiprecision::gmp_float::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_rational& o)
boost::multiprecision::gmp_float::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpf_t val)
boost::multiprecision::gmp_float::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpq_t val)
boost::multiprecision::gmp_float::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpz_t val)
boost::multiprecision::gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^struct gmp_int$/;"	s	namespace:boost::multiprecision
boost::multiprecision::gmp_int::compare	/usr/include/boost/multiprecision/gmp.hpp	/^   int compare(V v)const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(V v) const
boost::multiprecision::gmp_int::compare	/usr/include/boost/multiprecision/gmp.hpp	/^   int compare(const gmp_int& o)const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_int& o) const
boost::multiprecision::gmp_int::compare	/usr/include/boost/multiprecision/gmp.hpp	/^   int compare(long i)const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(long i) const
boost::multiprecision::gmp_int::compare	/usr/include/boost/multiprecision/gmp.hpp	/^   int compare(unsigned long i)const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(unsigned long i) const
boost::multiprecision::gmp_int::data	/usr/include/boost/multiprecision/gmp.hpp	/^   const mpz_t& data()const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:() const
boost::multiprecision::gmp_int::data	/usr/include/boost/multiprecision/gmp.hpp	/^   mpz_t& data()$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:()
boost::multiprecision::gmp_int::float_types	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef mpl::list<double, long double>                 float_types;$/;"	t	struct:boost::multiprecision::gmp_int	access:public
boost::multiprecision::gmp_int::gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   explicit gmp_int(const gmp_float<Digits10>& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_float<Digits10>& o)
boost::multiprecision::gmp_int::gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   explicit gmp_int(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_rational& o)
boost::multiprecision::gmp_int::gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   explicit gmp_int(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpf_t val)
boost::multiprecision::gmp_int::gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   explicit gmp_int(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpq_t val)
boost::multiprecision::gmp_int::gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int()$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:()
boost::multiprecision::gmp_int::gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int(const gmp_int& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_int& o)
boost::multiprecision::gmp_int::gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpz_t val)
boost::multiprecision::gmp_int::m_data	/usr/include/boost/multiprecision/gmp.hpp	/^   mpz_t m_data;$/;"	m	struct:boost::multiprecision::gmp_int	access:protected
boost::multiprecision::gmp_int::negate	/usr/include/boost/multiprecision/gmp.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:()
boost::multiprecision::gmp_int::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (const char* s)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const char* s)
boost::multiprecision::gmp_int::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (const gmp_int& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_int& o)
boost::multiprecision::gmp_int::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (double d)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(double d)
boost::multiprecision::gmp_int::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (long double a)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(long double a)
boost::multiprecision::gmp_int::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(long i)
boost::multiprecision::gmp_int::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (long long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(long long i)
boost::multiprecision::gmp_int::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (unsigned long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(unsigned long i)
boost::multiprecision::gmp_int::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(unsigned long long i)
boost::multiprecision::gmp_int::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator=(const gmp_float<Digits10>& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_float<Digits10>& o)
boost::multiprecision::gmp_int::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator=(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_rational& o)
boost::multiprecision::gmp_int::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator=(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpf_t val)
boost::multiprecision::gmp_int::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator=(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpq_t val)
boost::multiprecision::gmp_int::operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator=(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpz_t val)
boost::multiprecision::gmp_int::signed_types	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef mpl::list<long, long long>                     signed_types;$/;"	t	struct:boost::multiprecision::gmp_int	access:public
boost::multiprecision::gmp_int::str	/usr/include/boost/multiprecision/gmp.hpp	/^   std::string str(std::streamsize \/*digits*\/, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(std::streamsize , std::ios_base::fmtflags f) const
boost::multiprecision::gmp_int::swap	/usr/include/boost/multiprecision/gmp.hpp	/^   void swap(gmp_int& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(gmp_int& o)
boost::multiprecision::gmp_int::unsigned_types	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef mpl::list<unsigned long, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::gmp_int	access:public
boost::multiprecision::gmp_int::~gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   ~gmp_int()$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:()
boost::multiprecision::integer_modulus	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   integer_modulus(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, Integer val)$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, Integer val)
boost::multiprecision::integer_modulus	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   integer_modulus(const number<Backend, ExpressionTemplates>& x, Integer val)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, Integer val)
boost::multiprecision::integer_modulus	/usr/include/boost/multiprecision/integer.hpp	/^typename enable_if_c<is_integral<I1>::value && is_integral<I2>::value, I2>::type integer_modulus(const I1& x, I2 val)$/;"	f	namespace:boost::multiprecision	signature:(const I1& x, I2 val)
boost::multiprecision::iround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int iround(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
boost::multiprecision::iround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int iround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::iround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int iround(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
boost::multiprecision::iround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int iround(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
boost::multiprecision::is_compatible_arithmetic_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_compatible_arithmetic_type$/;"	s	namespace:boost::multiprecision	inherits:mpl::bool_
boost::multiprecision::is_number	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_number : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::false_
boost::multiprecision::is_number	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_number<number<Backend, ExpressionTemplates> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::true_
boost::multiprecision::is_number_expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_number_expression : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::false_
boost::multiprecision::is_number_expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_number_expression<detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::true_
boost::multiprecision::is_signed_number	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_signed_number : public mpl::bool_<!is_unsigned_number<T>::value> {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::bool_
boost::multiprecision::is_unsigned_number	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_unsigned_number<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision	inherits:mpl::bool_
boost::multiprecision::is_unsigned_number	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_unsigned_number : public mpl::false_{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::false_
boost::multiprecision::is_unsigned_number	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_unsigned_number<number<Backend, ExpressionTemplates> > : public is_unsigned_number<Backend> {};$/;"	s	namespace:boost::multiprecision	inherits:is_unsigned_number
boost::multiprecision::itrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int itrunc(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
boost::multiprecision::itrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int itrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::itrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int itrunc(const number<Backend, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& v)
boost::multiprecision::itrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int itrunc(const number<Backend, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& v, const Policy& pol)
boost::multiprecision::limb_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^typedef detail::largest_unsigned_type<64>::type limb_type;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::llround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long llround(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
boost::multiprecision::llround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long llround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::llround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long llround(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
boost::multiprecision::llround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long llround(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
boost::multiprecision::lltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
boost::multiprecision::lltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::lltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
boost::multiprecision::lltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
boost::multiprecision::lround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long lround(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
boost::multiprecision::lround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long lround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::lround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long lround(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
boost::multiprecision::lround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long lround(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
boost::multiprecision::lsb	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   lsb(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x)$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x)
boost::multiprecision::lsb	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   lsb(const number<Backend, ExpressionTemplates>& x)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x)
boost::multiprecision::lsb	/usr/include/boost/multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, unsigned>::type lsb(const Integer& val)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& val)
boost::multiprecision::ltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
boost::multiprecision::ltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::ltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
boost::multiprecision::ltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
boost::multiprecision::max_block_10	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^static const limb_type max_block_10 = 1000000000000000000uLL;$/;"	m	namespace:boost::multiprecision
boost::multiprecision::miller_rabin_test	/usr/include/boost/multiprecision/miller_rabin.hpp	/^   miller_rabin_test(const I& n, unsigned trials, Engine& gen)$/;"	f	namespace:boost::multiprecision	signature:(const I& n, unsigned trials, Engine& gen)
boost::multiprecision::miller_rabin_test	/usr/include/boost/multiprecision/miller_rabin.hpp	/^   miller_rabin_test(const I& x, unsigned trials)$/;"	f	namespace:boost::multiprecision	signature:(const I& x, unsigned trials)
boost::multiprecision::miller_rabin_test	/usr/include/boost/multiprecision/miller_rabin.hpp	/^bool miller_rabin_test(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials)
boost::multiprecision::miller_rabin_test	/usr/include/boost/multiprecision/miller_rabin.hpp	/^bool miller_rabin_test(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials, Engine& gen)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials, Engine& gen)
boost::multiprecision::minmax	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^inline void minmax(const T& a, const T& b, T& aa, T& bb)$/;"	f	namespace:boost::multiprecision	signature:(const T& a, const T& b, T& aa, T& bb)
boost::multiprecision::mpf_init2	/usr/include/boost/multiprecision/gmp.hpp	/^      mpf_init2(this->m_data, multiprecision::detail::digits10_2_2(Digits10 ? Digits10 : this->get_default_precision()));$/;"	p	namespace:boost::multiprecision	signature:(this->m_data, multiprecision::detail::digits10_2_2(Digits10 ? Digits10 : this->get_default_precision()))
boost::multiprecision::mpf_set	/usr/include/boost/multiprecision/gmp.hpp	/^   mpf_set(this->m_data, o.data());$/;"	p	namespace:boost::multiprecision	signature:(this->m_data, o.data())
boost::multiprecision::mpfr_allocation_type	/usr/include/boost/multiprecision/mpfr.hpp	/^enum mpfr_allocation_type$/;"	g	namespace:boost::multiprecision
boost::multiprecision::multiply	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   multiply(number<B, ET>& result, const I& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, ET>& result, const I& a, const I& b)
boost::multiprecision::multiply	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline number<B1, ET1>& multiply(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
boost::multiprecision::multiply	/usr/include/boost/multiprecision/integer.hpp	/^   multiply(Integer& result, const I2& a, const I2& b)$/;"	f	namespace:boost::multiprecision	signature:(Integer& result, const I2& a, const I2& b)
boost::multiprecision::number	/usr/include/boost/multiprecision/number.hpp	/^class number$/;"	c	namespace:boost::multiprecision
boost::multiprecision::number::assign	/usr/include/boost/multiprecision/number.hpp	/^   number& assign(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
boost::multiprecision::number::backend_type	/usr/include/boost/multiprecision/number.hpp	/^   typedef Backend backend_type;$/;"	t	class:boost::multiprecision::number	access:public
boost::multiprecision::number::compare	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE typename enable_if<is_arithmetic<V>, int>::type compare(const V& o)const$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& o) const
boost::multiprecision::number::convert_to	/usr/include/boost/multiprecision/number.hpp	/^   T convert_to()const$/;"	f	class:boost::multiprecision::number	access:public	signature:() const
boost::multiprecision::number::convert_to_imp	/usr/include/boost/multiprecision/number.hpp	/^   void convert_to_imp(T* result)const$/;"	f	class:boost::multiprecision::number	access:private	signature:(T* result) const
boost::multiprecision::number::convert_to_imp	/usr/include/boost/multiprecision/number.hpp	/^   void convert_to_imp(number<B2, ET>* result)const$/;"	f	class:boost::multiprecision::number	access:private	signature:(number<B2, ET>* result) const
boost::multiprecision::number::convert_to_imp	/usr/include/boost/multiprecision/number.hpp	/^   void convert_to_imp(std::string* result)const$/;"	f	class:boost::multiprecision::number	access:private	signature:(std::string* result) const
boost::multiprecision::number::declval	/usr/include/boost/multiprecision/number.hpp	/^      BOOST_NOEXCEPT_IF(noexcept(std::declval<Backend>().compare(std::declval<Backend>())))$/;"	f	class:boost::multiprecision::number	access:public	signature:()
boost::multiprecision::number::default_precision	/usr/include/boost/multiprecision/number.hpp	/^   static void default_precision(unsigned digits10)$/;"	f	class:boost::multiprecision::number	access:public	signature:(unsigned digits10)
boost::multiprecision::number::do_add	/usr/include/boost/multiprecision/number.hpp	/^   void do_add(const Exp& e, const detail::add_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::add_immediates&)
boost::multiprecision::number::do_add	/usr/include/boost/multiprecision/number.hpp	/^   void do_add(const Exp& e, const detail::minus&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::minus&)
boost::multiprecision::number::do_add	/usr/include/boost/multiprecision/number.hpp	/^   void do_add(const Exp& e, const detail::negate&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::negate&)
boost::multiprecision::number::do_add	/usr/include/boost/multiprecision/number.hpp	/^   void do_add(const Exp& e, const detail::plus&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::plus&)
boost::multiprecision::number::do_add	/usr/include/boost/multiprecision/number.hpp	/^   void do_add(const Exp& e, const detail::subtract_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::subtract_immediates&)
boost::multiprecision::number::do_add	/usr/include/boost/multiprecision/number.hpp	/^   void do_add(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
boost::multiprecision::number::do_add	/usr/include/boost/multiprecision/number.hpp	/^   void do_add(const Exp& e, const unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const unknown&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::add_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::add_immediates&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::bitwise_and&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_and&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::bitwise_and_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_and_immediates&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::bitwise_complement&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_complement&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::bitwise_or&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_or&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::bitwise_or_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_or_immediates&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::bitwise_xor&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_xor&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::bitwise_xor_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_xor_immediates&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::complement_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::complement_immediates&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::divide_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::divide_immediates&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::divides&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::divides&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::function&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::function&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::minus&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::minus&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::modulus&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::modulus&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::modulus_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::modulus_immediates&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::multiplies&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiplies&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::multiply_add&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiply_add&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::multiply_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiply_immediates&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::multiply_subtract&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiply_subtract&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::negate&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::negate&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::plus&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::plus&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::shift_left&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::shift_left&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::shift_right&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::shift_right&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::subtract_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::subtract_immediates&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e, const mpl::false_&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e, const mpl::false_&)
boost::multiprecision::number::do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e, const mpl::true_&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e, const mpl::true_&)
boost::multiprecision::number::do_assign_function	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function(const Exp& e, const mpl::int_<1>&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const mpl::int_<1>&)
boost::multiprecision::number::do_assign_function	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function(const Exp& e, const mpl::int_<2>&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const mpl::int_<2>&)
boost::multiprecision::number::do_assign_function	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function(const Exp& e, const mpl::int_<3>&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const mpl::int_<3>&)
boost::multiprecision::number::do_assign_function	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function(const Exp& e, const mpl::int_<4>&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const mpl::int_<4>&)
boost::multiprecision::number::do_assign_function_1	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_1(const F& f, const Exp& val, const Tag&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp& val, const Tag&)
boost::multiprecision::number::do_assign_function_1	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_1(const F& f, const Exp& val, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp& val, const detail::terminal&)
boost::multiprecision::number::do_assign_function_2	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_2(const F& f, const Exp1& val1, const Exp2& val2, const Tag1&, const Tag2&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Tag1&, const Tag2&)
boost::multiprecision::number::do_assign_function_2	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_2(const F& f, const Exp1& val1, const Exp2& val2, const Tag1&, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Tag1&, const detail::terminal&)
boost::multiprecision::number::do_assign_function_2	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_2(const F& f, const Exp1& val1, const Exp2& val2, const detail::terminal&, const Tag2&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const detail::terminal&, const Tag2&)
boost::multiprecision::number::do_assign_function_2	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_2(const F& f, const Exp1& val1, const Exp2& val2, const detail::terminal&, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const detail::terminal&, const detail::terminal&)
boost::multiprecision::number::do_assign_function_3a	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_3a(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag1&, const Tag2& t2, const Tag3& t3)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag1&, const Tag2& t2, const Tag3& t3)
boost::multiprecision::number::do_assign_function_3a	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_3a(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&, const Tag2& t2, const Tag3& t3)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&, const Tag2& t2, const Tag3& t3)
boost::multiprecision::number::do_assign_function_3b	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_3b(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag2& \/*t2*\/, const Tag3& t3)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag2& , const Tag3& t3)
boost::multiprecision::number::do_assign_function_3b	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_3b(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&, const Tag3& t3)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&, const Tag3& t3)
boost::multiprecision::number::do_assign_function_3c	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_3c(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag3& \/*t3*\/)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag3& )
boost::multiprecision::number::do_assign_function_3c	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_3c(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&)
boost::multiprecision::number::do_assign_left_shift	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_left_shift(const Exp& e, const Val& val, const Tag&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const Val& val, const Tag&)
boost::multiprecision::number::do_assign_left_shift	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_left_shift(const Exp& e, const Val& val, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const Val& val, const detail::terminal&)
boost::multiprecision::number::do_assign_right_shift	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_right_shift(const Exp& e, const Val& val, const Tag&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const Val& val, const Tag&)
boost::multiprecision::number::do_assign_right_shift	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_right_shift(const Exp& e, const Val& val, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const Val& val, const detail::terminal&)
boost::multiprecision::number::do_bitwise_and	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_and(const Exp& e, const detail::bitwise_and&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_and&)
boost::multiprecision::number::do_bitwise_and	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_and(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
boost::multiprecision::number::do_bitwise_and	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_and(const Exp& e, const unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const unknown&)
boost::multiprecision::number::do_bitwise_or	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_or(const Exp& e, const detail::bitwise_or&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_or&)
boost::multiprecision::number::do_bitwise_or	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_or(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
boost::multiprecision::number::do_bitwise_or	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_or(const Exp& e, const unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const unknown&)
boost::multiprecision::number::do_bitwise_xor	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_xor(const Exp& e, const detail::bitwise_xor&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_xor&)
boost::multiprecision::number::do_bitwise_xor	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_xor(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
boost::multiprecision::number::do_bitwise_xor	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_xor(const Exp& e, const unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const unknown&)
boost::multiprecision::number::do_divide	/usr/include/boost/multiprecision/number.hpp	/^   void do_divide(const Exp& e, const detail::divides&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::divides&)
boost::multiprecision::number::do_divide	/usr/include/boost/multiprecision/number.hpp	/^   void do_divide(const Exp& e, const detail::multiplies&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiplies&)
boost::multiprecision::number::do_divide	/usr/include/boost/multiprecision/number.hpp	/^   void do_divide(const Exp& e, const detail::negate&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::negate&)
boost::multiprecision::number::do_divide	/usr/include/boost/multiprecision/number.hpp	/^   void do_divide(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
boost::multiprecision::number::do_divide	/usr/include/boost/multiprecision/number.hpp	/^   void do_divide(const Exp& e, const unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const unknown&)
boost::multiprecision::number::do_divides	/usr/include/boost/multiprecision/number.hpp	/^   void do_divides(const Exp& e, const detail::divide_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::divide_immediates&)
boost::multiprecision::number::do_divides	/usr/include/boost/multiprecision/number.hpp	/^   void do_divides(const Exp& e, const detail::multiply_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiply_immediates&)
boost::multiprecision::number::do_modulus	/usr/include/boost/multiprecision/number.hpp	/^   void do_modulus(const Exp& e, const Unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const Unknown&)
boost::multiprecision::number::do_modulus	/usr/include/boost/multiprecision/number.hpp	/^   void do_modulus(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
boost::multiprecision::number::do_multiplies	/usr/include/boost/multiprecision/number.hpp	/^   void do_multiplies(const Exp& e, const detail::divide_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::divide_immediates&)
boost::multiprecision::number::do_multiplies	/usr/include/boost/multiprecision/number.hpp	/^   void do_multiplies(const Exp& e, const detail::divides&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::divides&)
boost::multiprecision::number::do_multiplies	/usr/include/boost/multiprecision/number.hpp	/^   void do_multiplies(const Exp& e, const detail::multiplies&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiplies&)
boost::multiprecision::number::do_multiplies	/usr/include/boost/multiprecision/number.hpp	/^   void do_multiplies(const Exp& e, const detail::multiply_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiply_immediates&)
boost::multiprecision::number::do_multiplies	/usr/include/boost/multiprecision/number.hpp	/^   void do_multiplies(const Exp& e, const detail::negate&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::negate&)
boost::multiprecision::number::do_multiplies	/usr/include/boost/multiprecision/number.hpp	/^   void do_multiplies(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
boost::multiprecision::number::do_multiplies	/usr/include/boost/multiprecision/number.hpp	/^   void do_multiplies(const Exp& e, const unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const unknown&)
boost::multiprecision::number::do_subtract	/usr/include/boost/multiprecision/number.hpp	/^   void do_subtract(const Exp& e, const detail::add_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::add_immediates&)
boost::multiprecision::number::do_subtract	/usr/include/boost/multiprecision/number.hpp	/^   void do_subtract(const Exp& e, const detail::minus&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::minus&)
boost::multiprecision::number::do_subtract	/usr/include/boost/multiprecision/number.hpp	/^   void do_subtract(const Exp& e, const detail::negate&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::negate&)
boost::multiprecision::number::do_subtract	/usr/include/boost/multiprecision/number.hpp	/^   void do_subtract(const Exp& e, const detail::plus&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::plus&)
boost::multiprecision::number::do_subtract	/usr/include/boost/multiprecision/number.hpp	/^   void do_subtract(const Exp& e, const detail::subtract_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::subtract_immediates&)
boost::multiprecision::number::do_subtract	/usr/include/boost/multiprecision/number.hpp	/^   void do_subtract(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
boost::multiprecision::number::do_subtract	/usr/include/boost/multiprecision/number.hpp	/^   void do_subtract(const Exp& e, const unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const unknown&)
boost::multiprecision::number::is_zero	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE bool is_zero()const$/;"	f	class:boost::multiprecision::number	access:public	signature:() const
boost::multiprecision::number::m_backend	/usr/include/boost/multiprecision/number.hpp	/^   Backend m_backend;$/;"	m	class:boost::multiprecision::number	access:private
boost::multiprecision::number::noexcept	/usr/include/boost/multiprecision/number.hpp	/^         >::type* = 0) BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Other&>(std::declval<Other>()))))$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
boost::multiprecision::number::noexcept	/usr/include/boost/multiprecision/number.hpp	/^      BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Backend&>(std::declval<Backend>())))) : m_backend(val.backend()) {}$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
boost::multiprecision::number::noexcept	/usr/include/boost/multiprecision/number.hpp	/^      BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Other&>(std::declval<Other>()))))$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
boost::multiprecision::number::noexcept	/usr/include/boost/multiprecision/number.hpp	/^      BOOST_NOEXCEPT_IF(noexcept(std::declval<Backend>() = static_cast<const Backend&>(std::declval<Backend>())))$/;"	p	class:boost::multiprecision::number	access:public	signature:(std::declval<Backend>(
boost::multiprecision::number::noexcept	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number() BOOST_NOEXCEPT_IF(noexcept(Backend())) {}$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
boost::multiprecision::number::noexcept	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const number& e) BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Backend&>(std::declval<Backend>())))) : m_backend(e.m_backend){}$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
boost::multiprecision::number::number	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const V& v, typename enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename enable_if_c< is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && !detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value >::type* = 0)
boost::multiprecision::number::number	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const number& e, unsigned digits10)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const number& e, unsigned digits10)
boost::multiprecision::number::number	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE number(V v1, V v2, typename enable_if<mpl::or_<boost::is_arithmetic<V>, is_same<std::string, V>, is_convertible<V, const char*> > >::type* = 0)$/;"	f	class:boost::multiprecision::number	access:public	signature:(V v1, V v2, typename enable_if<mpl::or_<boost::is_arithmetic<V>, is_same<std::string, V>, is_convertible<V, const char*> > >::type* = 0)
boost::multiprecision::number::number	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE number(const V& v, typename enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename enable_if_c< (boost::is_arithmetic<V>::value || is_same<std::string, V>::value || is_convertible<V, const char*>::value) && !is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && !detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value >::type* = 0)
boost::multiprecision::number::number	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE number(const number<Other, ET>& v1, const number<Other, ET>& v2, typename enable_if<boost::is_convertible<Other, Backend> >::type* = 0)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const number<Other, ET>& v1, const number<Other, ET>& v2, typename enable_if<boost::is_convertible<Other, Backend> >::type* = 0)
boost::multiprecision::number::number	/usr/include/boost/multiprecision/number.hpp	/^   explicit BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const V& v, typename enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename enable_if_c< detail::is_explicitly_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && (detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value || !is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value) >::type* = 0)
boost::multiprecision::number::number	/usr/include/boost/multiprecision/number.hpp	/^   explicit BOOST_MP_FORCEINLINE number(const V& v, typename enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename enable_if_c< (boost::is_arithmetic<V>::value || is_same<std::string, V>::value || is_convertible<V, const char*>::value) && !detail::is_explicitly_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value >::type* = 0)
boost::multiprecision::number::number	/usr/include/boost/multiprecision/number.hpp	/^   explicit number(const number<Other, ET>& val, typename enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const number<Other, ET>& val, typename enable_if_c< (!detail::is_explicitly_convertible<Other, Backend>::value) >::type* = 0)
boost::multiprecision::number::operator =	/usr/include/boost/multiprecision/number.hpp	/^   typename enable_if<is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>, number&>::type operator=(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
boost::multiprecision::number::operator T	/usr/include/boost/multiprecision/number.hpp	/^   explicit operator T ()const$/;"	f	class:boost::multiprecision::number	access:public	signature:() const
boost::multiprecision::number::operator T	/usr/include/boost/multiprecision/number.hpp	/^   explicit operator T()const$/;"	f	class:boost::multiprecision::number	access:public	signature:() const
boost::multiprecision::number::operator bool	/usr/include/boost/multiprecision/number.hpp	/^   explicit operator bool()const$/;"	f	class:boost::multiprecision::number	access:public	signature:() const
boost::multiprecision::number::operator unmentionable_type	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE operator unmentionable_type()const$/;"	f	class:boost::multiprecision::number	access:public	signature:() const
boost::multiprecision::number::precision	/usr/include/boost/multiprecision/number.hpp	/^   void precision(unsigned digits10)$/;"	f	class:boost::multiprecision::number	access:public	signature:(unsigned digits10)
boost::multiprecision::number::self_type	/usr/include/boost/multiprecision/number.hpp	/^   typedef number<Backend, ExpressionTemplates> self_type;$/;"	t	class:boost::multiprecision::number	access:private
boost::multiprecision::number::sign	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE int sign()const$/;"	f	class:boost::multiprecision::number	access:public	signature:() const
boost::multiprecision::number::str	/usr/include/boost/multiprecision/number.hpp	/^   std::string str(std::streamsize digits = 0, std::ios_base::fmtflags f = std::ios_base::fmtflags(0))const$/;"	f	class:boost::multiprecision::number	access:public	signature:(std::streamsize digits = 0, std::ios_base::fmtflags f = std::ios_base::fmtflags(0)) const
boost::multiprecision::number_category	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^struct number_category<concepts::number_backend_float_architype> : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^struct number_category<backends::cpp_dec_float<Digits10, ExponentType, Allocator> > : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct number_category : public mpl::int_<std::numeric_limits<Num>::is_integer ? number_kind_integer : (std::numeric_limits<Num>::max_exponent ? number_kind_floating_point : number_kind_unknown)> {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct number_category<detail::expression<tag, A1, A2, A3, A4> > : public number_category<typename detail::expression<tag, A1, A2, A3, A4>::result_type>{};$/;"	s	namespace:boost::multiprecision	inherits:number_category
boost::multiprecision::number_category	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct number_category<number<Backend, ExpressionTemplates> > : public number_category<Backend>{};$/;"	s	namespace:boost::multiprecision	inherits:number_category
boost::multiprecision::number_category	/usr/include/boost/multiprecision/gmp.hpp	/^struct number_category<backends::gmp_float<digits10> > : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	/usr/include/boost/multiprecision/gmp.hpp	/^struct number_category<backends::gmp_int> : public mpl::int_<number_kind_integer>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	/usr/include/boost/multiprecision/gmp.hpp	/^struct number_category<backends::gmp_rational> : public mpl::int_<number_kind_rational>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	/usr/include/boost/multiprecision/mpfr.hpp	/^struct number_category<backends::mpfr_float_backend<digits10, AllocationType> > : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	/usr/include/boost/multiprecision/rational_adapter.hpp	/^struct number_category<backends::rational_adapter<IntBackend> > : public mpl::int_<number_kind_rational>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category	/usr/include/boost/multiprecision/tommath.hpp	/^struct number_category<tommath_int> : public mpl::int_<number_kind_integer>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
boost::multiprecision::number_category_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^enum number_category_type$/;"	g	namespace:boost::multiprecision
boost::multiprecision::number_kind_fixed_point	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   number_kind_fixed_point = 3$/;"	e	enum:boost::multiprecision::number_category_type
boost::multiprecision::number_kind_floating_point	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   number_kind_floating_point = 1,$/;"	e	enum:boost::multiprecision::number_category_type
boost::multiprecision::number_kind_integer	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   number_kind_integer = 0,$/;"	e	enum:boost::multiprecision::number_category_type
boost::multiprecision::number_kind_rational	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   number_kind_rational = 2,$/;"	e	enum:boost::multiprecision::number_category_type
boost::multiprecision::number_kind_unknown	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   number_kind_unknown = -1,$/;"	e	enum:boost::multiprecision::number_category_type
boost::multiprecision::numerator	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline number<IntBackend, ET> numerator(const number<rational_adapter<IntBackend>, ET>& val)$/;"	f	namespace:boost::multiprecision	signature:(const number<rational_adapter<IntBackend>, ET>& val)
boost::multiprecision::operator !=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator != (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
boost::multiprecision::operator !=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator != (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator !=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator != (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
boost::multiprecision::operator !=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator != (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
boost::multiprecision::operator !=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator != (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
boost::multiprecision::operator !=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool operator != (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
boost::multiprecision::operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator %	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator % (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator %	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator % (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator %	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator % (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator %	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator % (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator %	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator % (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator & (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator & (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator & (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator & (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator & (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator & (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator & (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator & (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator * (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator * (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator * (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator * (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^inline const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v) { return v; }$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^inline const number<B, ExpressionTemplates>& operator + (const number<B, ExpressionTemplates>& v) { return v; }$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ExpressionTemplates>& v)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator + (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator + (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator + (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator + (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^inline detail::expression<detail::negate, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v) $/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^inline detail::expression<detail::negate, number<B, et_on> > operator - (const number<B, et_on>& v) $/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& v)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator - (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator - (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator - (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator - (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (const number<B, et_off>& v) $/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& v)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (number<B, et_off>&& v) $/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& v)
boost::multiprecision::operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if<is_signed_number<B>, number<B, et_off> >::type operator - (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator \/ (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator \/ (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator \/ (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator \/ (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator /	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator \/ (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator <	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator < (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
boost::multiprecision::operator <	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator < (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator <	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator < (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
boost::multiprecision::operator <	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator < (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
boost::multiprecision::operator <	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator < (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
boost::multiprecision::operator <	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool operator < (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator <<	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator << (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)
boost::multiprecision::operator <<	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator << (const number<B, et_on>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const I& b)
boost::multiprecision::operator <<	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator << (const number<B, et_off>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const I& b)
boost::multiprecision::operator <<	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator << (number<B, et_off>&& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const I& b)
boost::multiprecision::operator <<	/usr/include/boost/multiprecision/number.hpp	/^inline std::ostream& operator << (std::ostream& os, const number<Backend, ExpressionTemplates>& r)$/;"	f	namespace:boost::multiprecision	signature:(std::ostream& os, const number<Backend, ExpressionTemplates>& r)
boost::multiprecision::operator <=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator <= (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
boost::multiprecision::operator <=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator <= (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator <=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator <= (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
boost::multiprecision::operator <=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator <= (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
boost::multiprecision::operator <=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator <= (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
boost::multiprecision::operator <=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool operator <= (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator =	/usr/include/boost/multiprecision/cpp_int.hpp	/^      operator=(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other)$/;"	f	namespace:boost::multiprecision	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other)
boost::multiprecision::operator =	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE cpp_int_backend& operator = (Arithmetic val)$/;"	f	namespace:boost::multiprecision	access:public	signature:(Arithmetic val)
boost::multiprecision::operator =	/usr/include/boost/multiprecision/cpp_int.hpp	/^   cpp_int_backend& operator = (const char* s)$/;"	f	namespace:boost::multiprecision	access:public	signature:(const char* s)
boost::multiprecision::operator ==	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator == (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
boost::multiprecision::operator ==	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator == (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator ==	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator == (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
boost::multiprecision::operator ==	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator == (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
boost::multiprecision::operator ==	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator == (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
boost::multiprecision::operator ==	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool operator == (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator >	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator > (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
boost::multiprecision::operator >	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator > (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator >	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
boost::multiprecision::operator >	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
boost::multiprecision::operator >	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator > (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
boost::multiprecision::operator >	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool operator > (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator >=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator >= (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
boost::multiprecision::operator >=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator >= (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator >=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator >= (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
boost::multiprecision::operator >=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator >= (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
boost::multiprecision::operator >=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator >= (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
boost::multiprecision::operator >=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool operator >= (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
boost::multiprecision::operator >>	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator >> (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)
boost::multiprecision::operator >>	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator >> (const number<B, et_on>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const I& b)
boost::multiprecision::operator >>	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator >> (const number<B, et_off>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const I& b)
boost::multiprecision::operator >>	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator >> (number<B, et_off>&& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const I& b)
boost::multiprecision::operator >>	/usr/include/boost/multiprecision/number.hpp	/^inline std::istream& operator >> (std::istream& is, number<Backend, ExpressionTemplates>& r)$/;"	f	namespace:boost::multiprecision	signature:(std::istream& is, number<Backend, ExpressionTemplates>& r)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator ^ (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator ^ (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator ^ (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator ^ (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator ^ (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator ^ (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator ^ (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator ^ (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator | (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator | (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator | (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator | (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator | (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator | (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator | (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
boost::multiprecision::operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator | (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
boost::multiprecision::operator ~	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^inline detail::expression<detail::bitwise_complement, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > operator ~ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v) { return detail::expression<detail::bitwise_complement, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(v); }$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)
boost::multiprecision::operator ~	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^inline detail::expression<detail::complement_immediates, number<B, et_on> > operator ~ (const number<B, et_on>& v) { return detail::expression<detail::complement_immediates, number<B, et_on> >(v); }$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& v)
boost::multiprecision::operator ~	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator ~ (const number<B, et_off>& v) $/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& v)
boost::multiprecision::operator ~	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator ~ (number<B, et_off>&& v) $/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& v)
boost::multiprecision::powm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   powm(const T& b, const U& p, const V& mod)$/;"	f	namespace:boost::multiprecision	signature:(const T& b, const U& p, const V& mod)
boost::multiprecision::round	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline number<T, ExpressionTemplates> round(const number<T, ExpressionTemplates>& v, const Policy&)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy&)
boost::multiprecision::round	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename detail::expression<tag, A1, A2, A3, A4>::result_type round(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::signed_double_limb_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^typedef boost::int128_type signed_double_limb_type;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::signed_limb_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^typedef detail::largest_signed_type<64>::type signed_limb_type;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::signed_magnitude	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   signed_magnitude = 1,$/;"	e	enum:boost::multiprecision::cpp_integer_type
boost::multiprecision::signed_packed	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   signed_packed = 3,$/;"	e	enum:boost::multiprecision::cpp_integer_type
boost::multiprecision::str	/usr/include/boost/multiprecision/cpp_int.hpp	/^   std::string str(std::streamsize \/*digits*\/, std::ios_base::fmtflags f)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(std::streamsize , std::ios_base::fmtflags f) const
boost::multiprecision::subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   subtract(number<B, ET>& result, const I& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, ET>& result, const I& a, const I& b)
boost::multiprecision::subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline number<B1, ET1>& subtract(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
boost::multiprecision::subtract	/usr/include/boost/multiprecision/integer.hpp	/^   subtract(Integer& result, const I2& a, const I2& b)$/;"	f	namespace:boost::multiprecision	signature:(Integer& result, const I2& a, const I2& b)
boost::multiprecision::swap	/usr/include/boost/multiprecision/number.hpp	/^BOOST_MP_FORCEINLINE void swap(number<Backend, ExpressionTemplates>& a, number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& a, number<Backend, ExpressionTemplates>& b)
boost::multiprecision::tom_int	/usr/include/boost/multiprecision/tommath.hpp	/^typedef number<tommath_int >                     tom_int;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::tom_rational	/usr/include/boost/multiprecision/tommath.hpp	/^typedef number<tommath_rational>                 tom_rational;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::tommath_rational	/usr/include/boost/multiprecision/tommath.hpp	/^typedef rational_adapter<tommath_int>               tommath_rational;$/;"	t	namespace:boost::multiprecision
boost::multiprecision::trunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline number<Backend, ExpressionTemplates> trunc(const number<Backend, ExpressionTemplates>& v, const Policy&)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& v, const Policy&)
boost::multiprecision::trunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename detail::expression<tag, A1, A2, A3, A4>::result_type trunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
boost::multiprecision::unchecked	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   unchecked = 0$/;"	e	enum:boost::multiprecision::cpp_int_check_type
boost::multiprecision::unsigned_magnitude	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   unsigned_magnitude = 0,$/;"	e	enum:boost::multiprecision::cpp_integer_type
boost::multiprecision::unsigned_packed	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   unsigned_packed = 2$/;"	e	enum:boost::multiprecision::cpp_integer_type
boost::numerator	/usr/include/boost/multiprecision/number.hpp	/^inline multiprecision::number<T, ExpressionTemplates> numerator(const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a)
boost::numeric	/usr/include/boost/multiprecision/number.hpp	/^namespace numeric { namespace ublas {$/;"	n	namespace:boost
boost::numeric::ublas	/usr/include/boost/multiprecision/number.hpp	/^namespace numeric { namespace ublas {$/;"	n	namespace:boost::numeric
boost::numeric::ublas::operator ==	/usr/include/boost/multiprecision/number.hpp	/^inline bool operator == (const sparse_vector_element<V>& a, const ::boost::multiprecision::number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::numeric::ublas	signature:(const sparse_vector_element<V>& a, const ::boost::multiprecision::number<Backend, ExpressionTemplates>& b)
boost::operator !=	/usr/include/boost/multiprecision/number.hpp	/^typename enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator != (const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)
boost::operator !=	/usr/include/boost/multiprecision/number.hpp	/^typename enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator != (const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)
boost::operator ==	/usr/include/boost/multiprecision/number.hpp	/^typename enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator == (const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)
boost::operator ==	/usr/include/boost/multiprecision/number.hpp	/^typename enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator == (const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)
boost::operator >>	/usr/include/boost/multiprecision/number.hpp	/^inline std::istream& operator >> (std::istream& is, rational<multiprecision::number<Backend, ExpressionTemplates> >& r)$/;"	f	namespace:boost	signature:(std::istream& is, rational<multiprecision::number<Backend, ExpressionTemplates> >& r)
boost::random	/usr/include/boost/multiprecision/random.hpp	/^namespace boost{ namespace random{ namespace detail{$/;"	n	namespace:boost
boost::random	/usr/include/boost/multiprecision/random.hpp	/^namespace random{$/;"	n	namespace:boost
boost::random::detail	/usr/include/boost/multiprecision/random.hpp	/^namespace boost{ namespace random{ namespace detail{$/;"	n	namespace:boost::random
boost::random::detail	/usr/include/boost/multiprecision/random.hpp	/^namespace detail{$/;"	n	namespace:boost::random
boost::random::detail::generate_uniform_int	/usr/include/boost/multiprecision/random.hpp	/^   generate_uniform_int($/;"	f	namespace:boost::random::detail	signature:( Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value, boost::mpl::true_ )
boost::random::detail::generate_uniform_int	/usr/include/boost/multiprecision/random.hpp	/^   generate_uniform_int(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value)$/;"	f	namespace:boost::random::detail	signature:(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value)
boost::random::detail::generate_uniform_int	/usr/include/boost/multiprecision/random.hpp	/^   generate_uniform_int(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value);$/;"	p	namespace:boost::random::detail	signature:(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value)
boost::random::detail::select_uniform_01	/usr/include/boost/multiprecision/random.hpp	/^struct select_uniform_01<boost::multiprecision::number<Backend, ExpressionTemplates> >$/;"	s	namespace:boost::random::detail
boost::random::detail::select_uniform_01::apply	/usr/include/boost/multiprecision/random.hpp	/^  struct apply$/;"	s	struct:boost::random::detail::select_uniform_01	access:public
boost::random::detail::select_uniform_01::apply::type	/usr/include/boost/multiprecision/random.hpp	/^    typedef new_uniform_01<boost::multiprecision::number<Backend, ExpressionTemplates> > type;$/;"	t	struct:boost::random::detail::select_uniform_01::apply	access:public
boost::random::detail::subtract	/usr/include/boost/multiprecision/random.hpp	/^struct subtract<boost::multiprecision::number<Backend, ExpressionTemplates>, true> $/;"	s	namespace:boost::random::detail
boost::random::detail::subtract::operator ()	/usr/include/boost/multiprecision/random.hpp	/^  result_type operator()(result_type const& x, result_type const& y) { return x - y; }$/;"	f	struct:boost::random::detail::subtract	access:public	signature:(result_type const& x, result_type const& y)
boost::random::detail::subtract::result_type	/usr/include/boost/multiprecision/random.hpp	/^  typedef boost::multiprecision::number<Backend, ExpressionTemplates> result_type;$/;"	t	struct:boost::random::detail::subtract	access:public
boost::random::independent_bits_engine	/usr/include/boost/multiprecision/random.hpp	/^class independent_bits_engine<Engine, w, boost::multiprecision::number<Backend, ExpressionTemplates> >$/;"	c	namespace:boost::random
boost::random::independent_bits_engine::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/random.hpp	/^    static result_type max BOOST_PREVENT_MACRO_SUBSTITUTION ()$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
boost::random::independent_bits_engine::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/random.hpp	/^    static result_type min BOOST_PREVENT_MACRO_SUBSTITUTION ()$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
boost::random::independent_bits_engine::BOOST_RANDOM_DETAIL_ARITHMETIC_CONSTRUCTOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ARITHMETIC_CONSTRUCTOR(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, result_type, seed_arg)
boost::random::independent_bits_engine::BOOST_RANDOM_DETAIL_ARITHMETIC_SEED	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ARITHMETIC_SEED(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, result_type, seed_arg)
boost::random::independent_bits_engine::BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(independent_bits_engine, x, y)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, x, y)
boost::random::independent_bits_engine::BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, independent_bits_engine, r)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(is, independent_bits_engine, r)
boost::random::independent_bits_engine::BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, independent_bits_engine, r)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(os, independent_bits_engine, r)
boost::random::independent_bits_engine::BOOST_RANDOM_DETAIL_SEED_SEQ_CONSTRUCTOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_SEED_SEQ_CONSTRUCTOR(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, SeedSeq, seq)
boost::random::independent_bits_engine::BOOST_RANDOM_DETAIL_SEED_SEQ_SEED	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_SEED_SEQ_SEED(independent_bits_engine,$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(independent_bits_engine, SeedSeq, seq)
boost::random::independent_bits_engine::_base	/usr/include/boost/multiprecision/random.hpp	/^    Engine _base;$/;"	m	class:boost::random::independent_bits_engine	access:private
boost::random::independent_bits_engine::base	/usr/include/boost/multiprecision/random.hpp	/^    const base_type& base() const { return _base; }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:() const
boost::random::independent_bits_engine::base_result	/usr/include/boost/multiprecision/random.hpp	/^    typedef typename base_type::result_type base_result;$/;"	t	class:boost::random::independent_bits_engine	access:private
boost::random::independent_bits_engine::base_type	/usr/include/boost/multiprecision/random.hpp	/^    typedef Engine base_type;$/;"	t	class:boost::random::independent_bits_engine	access:public
boost::random::independent_bits_engine::base_unsigned	/usr/include/boost/multiprecision/random.hpp	/^    typedef typename make_unsigned<base_result>::type base_unsigned;$/;"	t	class:boost::random::independent_bits_engine	access:private
boost::random::independent_bits_engine::calc_params	/usr/include/boost/multiprecision/random.hpp	/^    void calc_params($/;"	f	class:boost::random::independent_bits_engine	access:private	signature:( std::size_t n, base_unsigned range, std::size_t& w0, std::size_t& n0, base_unsigned& y0, base_unsigned& y1, base_unsigned& y0_mask, base_unsigned& y1_mask)
boost::random::independent_bits_engine::discard	/usr/include/boost/multiprecision/random.hpp	/^    void discard(boost::uintmax_t z)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(boost::uintmax_t z)
boost::random::independent_bits_engine::generate	/usr/include/boost/multiprecision/random.hpp	/^    void generate(Iter first, Iter last)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(Iter first, Iter last)
boost::random::independent_bits_engine::independent_bits_engine	/usr/include/boost/multiprecision/random.hpp	/^    independent_bits_engine() { }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
boost::random::independent_bits_engine::independent_bits_engine	/usr/include/boost/multiprecision/random.hpp	/^    independent_bits_engine(It& first, It last) : _base(first, last) { }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(It& first, It last)
boost::random::independent_bits_engine::independent_bits_engine	/usr/include/boost/multiprecision/random.hpp	/^    independent_bits_engine(const base_type& base_arg) : _base(base_arg) {}$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(const base_type& base_arg)
boost::random::independent_bits_engine::operator ()	/usr/include/boost/multiprecision/random.hpp	/^    result_type operator()()$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
boost::random::independent_bits_engine::result_type	/usr/include/boost/multiprecision/random.hpp	/^    typedef boost::multiprecision::number<Backend, ExpressionTemplates> result_type;$/;"	t	class:boost::random::independent_bits_engine	access:public
boost::random::independent_bits_engine::seed	/usr/include/boost/multiprecision/random.hpp	/^    template<class It> void seed(It& first, It last)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(It& first, It last)
boost::random::independent_bits_engine::seed	/usr/include/boost/multiprecision/random.hpp	/^    void seed() { _base.seed(); }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
boost::random::uniform_smallint	/usr/include/boost/multiprecision/random.hpp	/^class uniform_smallint<boost::multiprecision::number<Backend, ExpressionTemplates> >$/;"	c	namespace:boost::random
boost::random::uniform_smallint::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/random.hpp	/^    result_type max BOOST_PREVENT_MACRO_SUBSTITUTION () const { return _max; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
boost::random::uniform_smallint::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/multiprecision/random.hpp	/^    result_type min BOOST_PREVENT_MACRO_SUBSTITUTION () const { return _min; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
boost::random::uniform_smallint::BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(uniform_smallint, lhs, rhs)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(uniform_smallint, lhs, rhs)
boost::random::uniform_smallint::BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, uniform_smallint, ud)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(is, uniform_smallint, ud)
boost::random::uniform_smallint::BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^    BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, uniform_smallint, ud)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(os, uniform_smallint, ud)
boost::random::uniform_smallint::_max	/usr/include/boost/multiprecision/random.hpp	/^    result_type _max;$/;"	m	class:boost::random::uniform_smallint	access:private
boost::random::uniform_smallint::_min	/usr/include/boost/multiprecision/random.hpp	/^    result_type _min;$/;"	m	class:boost::random::uniform_smallint	access:private
boost::random::uniform_smallint::a	/usr/include/boost/multiprecision/random.hpp	/^    result_type a() const { return _min; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
boost::random::uniform_smallint::b	/usr/include/boost/multiprecision/random.hpp	/^    result_type b() const { return _max; }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
boost::random::uniform_smallint::generate	/usr/include/boost/multiprecision/random.hpp	/^    result_type generate(Engine& eng, boost::mpl::false_) const$/;"	f	class:boost::random::uniform_smallint	access:private	signature:(Engine& eng, boost::mpl::false_) const
boost::random::uniform_smallint::generate	/usr/include/boost/multiprecision/random.hpp	/^    result_type generate(Engine& eng, boost::mpl::true_) const$/;"	f	class:boost::random::uniform_smallint	access:private	signature:(Engine& eng, boost::mpl::true_) const
boost::random::uniform_smallint::input_type	/usr/include/boost/multiprecision/random.hpp	/^    typedef boost::multiprecision::number<Backend, ExpressionTemplates> input_type;$/;"	t	class:boost::random::uniform_smallint	access:public
boost::random::uniform_smallint::operator ()	/usr/include/boost/multiprecision/random.hpp	/^    result_type operator()(Engine& eng) const$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(Engine& eng) const
boost::random::uniform_smallint::operator ()	/usr/include/boost/multiprecision/random.hpp	/^    result_type operator()(Engine& eng, const param_type& parm) const$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(Engine& eng, const param_type& parm) const
boost::random::uniform_smallint::param	/usr/include/boost/multiprecision/random.hpp	/^    param_type param() const { return param_type(_min, _max); }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
boost::random::uniform_smallint::param	/usr/include/boost/multiprecision/random.hpp	/^    void param(const param_type& parm)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(const param_type& parm)
boost::random::uniform_smallint::param_type	/usr/include/boost/multiprecision/random.hpp	/^    class param_type$/;"	c	class:boost::random::uniform_smallint	access:public
boost::random::uniform_smallint::param_type::BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^        BOOST_RANDOM_DETAIL_EQUALITY_OPERATOR(param_type, lhs, rhs)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(param_type, lhs, rhs)
boost::random::uniform_smallint::param_type::BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^        BOOST_RANDOM_DETAIL_ISTREAM_OPERATOR(is, param_type, parm)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(is, param_type, parm)
boost::random::uniform_smallint::param_type::BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR	/usr/include/boost/multiprecision/random.hpp	/^        BOOST_RANDOM_DETAIL_OSTREAM_OPERATOR(os, param_type, parm)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(os, param_type, parm)
boost::random::uniform_smallint::param_type::_max	/usr/include/boost/multiprecision/random.hpp	/^        result_type _max;$/;"	m	class:boost::random::uniform_smallint::param_type	access:private
boost::random::uniform_smallint::param_type::_min	/usr/include/boost/multiprecision/random.hpp	/^        result_type _min;$/;"	m	class:boost::random::uniform_smallint::param_type	access:private
boost::random::uniform_smallint::param_type::a	/usr/include/boost/multiprecision/random.hpp	/^        result_type a() const { return _min; }$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:() const
boost::random::uniform_smallint::param_type::b	/usr/include/boost/multiprecision/random.hpp	/^        result_type b() const { return _max; }$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:() const
boost::random::uniform_smallint::param_type::distribution_type	/usr/include/boost/multiprecision/random.hpp	/^        typedef uniform_smallint distribution_type;$/;"	t	class:boost::random::uniform_smallint::param_type	access:public
boost::random::uniform_smallint::param_type::param_type	/usr/include/boost/multiprecision/random.hpp	/^        param_type(result_type const& min_arg = 0, result_type const& max_arg = 9)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(result_type const& min_arg = 0, result_type const& max_arg = 9)
boost::random::uniform_smallint::reset	/usr/include/boost/multiprecision/random.hpp	/^    void reset() { }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:()
boost::random::uniform_smallint::result_type	/usr/include/boost/multiprecision/random.hpp	/^    typedef boost::multiprecision::number<Backend, ExpressionTemplates> result_type;$/;"	t	class:boost::random::uniform_smallint	access:public
boost::random::uniform_smallint::uniform_smallint	/usr/include/boost/multiprecision/random.hpp	/^    explicit uniform_smallint(const param_type& parm)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(const param_type& parm)
boost::random::uniform_smallint::uniform_smallint	/usr/include/boost/multiprecision/random.hpp	/^    explicit uniform_smallint(result_type const& min_arg = 0, result_type const& max_arg = 9)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(result_type const& min_arg = 0, result_type const& max_arg = 9)
calc_e	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^void calc_e(T& result, unsigned digits)$/;"	f	signature:(T& result, unsigned digits)
calc_log2	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^void calc_log2(T& num, unsigned digits)$/;"	f	signature:(T& num, unsigned digits)
calc_params	/usr/include/boost/multiprecision/random.hpp	/^    void calc_params($/;"	f	class:boost::random::independent_bits_engine	access:private	signature:( std::size_t n, base_unsigned range, std::size_t& w0, std::size_t& n0, base_unsigned& y0, base_unsigned& y1, base_unsigned& y0_mask, base_unsigned& y1_mask)
calc_pi	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^void calc_pi(T& result, unsigned digits)$/;"	f	signature:(T& result, unsigned digits)
calculate_inv	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& calculate_inv (void)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
calculate_inv	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::calculate_inv()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:()
calculate_next_larger_type	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^struct calculate_next_larger_type$/;"	s	namespace:boost::multiprecision::default_ops
calculate_sqrt	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& calculate_sqrt(void)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
calculate_sqrt	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::calculate_sqrt(void)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void)
canonical	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical$/;"	s	namespace:boost::multiprecision::detail
canonical_imp	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical_imp$/;"	s	namespace:boost::multiprecision::detail
canonical_imp	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<0> >$/;"	s	namespace:boost::multiprecision::detail
canonical_imp	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<1> >$/;"	s	namespace:boost::multiprecision::detail
canonical_imp	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<2> >$/;"	s	namespace:boost::multiprecision::detail
canonical_imp	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical_imp<Val, Backend, mpl::int_<3> >$/;"	s	namespace:boost::multiprecision::detail
canonical_imp	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical_imp<number<B, et_off>, Backend, Tag>$/;"	s	namespace:boost::multiprecision::detail
canonical_imp	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct canonical_imp<number<B, et_on>, Backend, Tag>$/;"	s	namespace:boost::multiprecision::detail
cap	/usr/include/boost/multiprecision/cpp_int.hpp	/^      unsigned cap = capacity();$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
capacity	/usr/include/boost/multiprecision/cpp_int.hpp	/^      unsigned capacity;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base::limb_data	access:public
cast_to_unsigned	/usr/include/boost/multiprecision/miller_rabin.hpp	/^   cast_to_unsigned(const I& val)$/;"	f	namespace:boost::multiprecision::detail	signature:(const I& val)
char_is_nonzero_predicate	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static bool char_is_nonzero_predicate(const char& c)  { return (c != static_cast<char>('0')); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const char& c)
check_in_range	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^void check_in_range(const CppInt& val, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends	signature:(const CppInt& val, const mpl::int_<checked>&)
check_in_range	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool check_in_range(const T& t)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& t)
check_in_range	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool check_in_range(const terminal<T>&)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const terminal<T>&)
check_is_negative	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^inline void check_is_negative(const mpl::false_&)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpl::false_&)
check_shift_range	/usr/include/boost/multiprecision/detail/number_base.hpp	/^void check_shift_range(V val, const mpl::false_&, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::detail	signature:(V val, const mpl::false_&, const mpl::true_&)
check_shift_range	/usr/include/boost/multiprecision/detail/number_base.hpp	/^void check_shift_range(V val, const mpl::true_&, const mpl::false_&)$/;"	f	namespace:boost::multiprecision::detail	signature:(V val, const mpl::true_&, const mpl::false_&)
check_shift_range	/usr/include/boost/multiprecision/detail/number_base.hpp	/^void check_shift_range(V val, const mpl::true_&, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::detail	signature:(V val, const mpl::true_&, const mpl::true_&)
check_small_factors	/usr/include/boost/multiprecision/miller_rabin.hpp	/^bool check_small_factors(const I& n)$/;"	f	namespace:boost::multiprecision::detail	signature:(const I& n)
check_tommath_result	/usr/include/boost/multiprecision/tommath.hpp	/^inline void check_tommath_result(unsigned v)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(unsigned v)
checked	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   checked = 1,$/;"	e	enum:boost::multiprecision::cpp_int_check_type
checked_add	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_add(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
checked_add	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_add(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
checked_add_imp	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_add_imp(A a, A b, const mpl::false_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::false_&)
checked_add_imp	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_add_imp(A a, A b, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::true_&)
checked_cpp_int	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<0, 0, signed_magnitude, checked> >  checked_cpp_int;$/;"	t
checked_cpp_rational	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_rational_backend>                 checked_cpp_rational;$/;"	t
checked_cpp_rational_backend	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef rational_adapter<cpp_int_backend<0, 0, signed_magnitude, checked> >  checked_cpp_rational_backend;$/;"	t
checked_divide	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_divide(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
checked_divide	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_divide(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
checked_int1024_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<1024, 1024, signed_magnitude, checked, void> >  checked_int1024_t;$/;"	t
checked_int128_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<128, 128, signed_magnitude, checked, void> >    checked_int128_t;$/;"	t
checked_int256_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<256, 256, signed_magnitude, checked, void> >    checked_int256_t;$/;"	t
checked_int512_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<512, 512, signed_magnitude, checked, void> >    checked_int512_t;$/;"	t
checked_left_shift	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_left_shift(A a, unsigned long long shift, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, unsigned long long shift, const mpl::int_<checked>&)
checked_left_shift	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_left_shift(A a, unsigned long long shift, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, unsigned long long shift, const mpl::int_<unchecked>&)
checked_multiply	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_multiply(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
checked_multiply	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_multiply(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
checked_subtract	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract(A a, A b, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<checked>&)
checked_subtract	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract(A a, A b, const mpl::int_<unchecked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::int_<unchecked>&)
checked_subtract_imp	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract_imp(A a, A b, const mpl::false_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::false_&)
checked_subtract_imp	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline A checked_subtract_imp(A a, A b, const mpl::true_&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(A a, A b, const mpl::true_&)
checked_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef mpl::int_<Checked>                                    checked_type;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
checked_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef mpl::int_<Checked>              checked_type;$/;"	t	struct:boost::multiprecision::cpp_int_base	access:public
checked_uint1024_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<1024, 1024, unsigned_magnitude, checked, void> > checked_uint1024_t;$/;"	t
checked_uint128_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<128, 128, unsigned_magnitude, checked, void> >   checked_uint128_t;$/;"	t
checked_uint256_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<256, 256, unsigned_magnitude, checked, void> >   checked_uint256_t;$/;"	t
checked_uint512_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<512, 512, unsigned_magnitude, checked, void> >   checked_uint512_t;$/;"	t
cmp_data	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   int cmp_data(const array_type& vd) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const array_type& vd) const
cmp_data	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^int cpp_dec_float<Digits10, ExponentType, Allocator>::cmp_data(const array_type& vd) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const array_type& vd) const
combine_expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct combine_expression$/;"	s	namespace:boost::multiprecision::detail
combine_expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct combine_expression<T1, number<T2, ExpressionTemplates> >$/;"	s	namespace:boost::multiprecision::detail
combine_expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct combine_expression<number<T, ExpressionTemplates>, number<T, ExpressionTemplates> >$/;"	s	namespace:boost::multiprecision::detail
combine_expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct combine_expression<number<T1, ExpressionTemplates1>, number<T2, ExpressionTemplates2> >$/;"	s	namespace:boost::multiprecision::detail
combine_expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct combine_expression<number<T1, ExpressionTemplates>, T2>$/;"	s	namespace:boost::multiprecision::detail
compare	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(const number_backend_float_architype& o)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const number_backend_float_architype& o) const
compare	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(long double d)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long double d) const
compare	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(long long i)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long long i) const
compare	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   int compare(unsigned long long i)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(unsigned long long i) const
compare	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   int compare(const V& v)const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const V& v) const
compare	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   int compare(const cpp_dec_float& v)const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v) const
compare	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^int cpp_dec_float<Digits10, ExponentType, Allocator>::compare(const cpp_dec_float& v) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float& v) const
compare	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE typename enable_if<is_arithmetic<Arithmetic>, int>::type compare(Arithmetic i)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(Arithmetic i) const
compare	/usr/include/boost/multiprecision/gmp.hpp	/^   int compare(V v)const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(V v) const
compare	/usr/include/boost/multiprecision/gmp.hpp	/^   int compare(const gmp_int& o)const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_int& o) const
compare	/usr/include/boost/multiprecision/gmp.hpp	/^   int compare(long i)const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(long i) const
compare	/usr/include/boost/multiprecision/gmp.hpp	/^   int compare(unsigned long i)const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(unsigned long i) const
compare	/usr/include/boost/multiprecision/gmp.hpp	/^   typename enable_if<is_arithmetic<V>, int>::type compare(V v)const$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(V v) const
compare	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE typename enable_if<is_arithmetic<V>, int>::type compare(const V& o)const$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& o) const
compare	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   int compare(const rational_adapter& o)const$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const rational_adapter& o) const
compare	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typename enable_if<is_arithmetic<Arithmatic>, int>::type compare(Arithmatic i)const$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(Arithmatic i) const
compare	/usr/include/boost/multiprecision/tommath.hpp	/^   int compare(V v)const$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(V v) const
compare	/usr/include/boost/multiprecision/tommath.hpp	/^   int compare(const tommath_int& o)const$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const tommath_int& o) const
compare_imp	/usr/include/boost/multiprecision/cpp_int.hpp	/^   int compare_imp(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::false_&, const mpl::true_&)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::false_&, const mpl::true_&) const
compare_imp	/usr/include/boost/multiprecision/cpp_int.hpp	/^   int compare_imp(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::true_&, const mpl::false_&)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::true_&, const mpl::false_&) const
complement_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct complement_immediates{};$/;"	s	namespace:boost::multiprecision::detail
component_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct component_type<detail::expression<tag, A1, A2, A3, A4> > : public component_type<typename detail::expression<tag, A1, A2, A3, A4>::result_type>{};$/;"	s	namespace:boost::multiprecision	inherits:component_type
component_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct component_type<number<T, ExpressionTemplates> > : public component_type<T>{};$/;"	s	namespace:boost::multiprecision	inherits:component_type
component_type	/usr/include/boost/multiprecision/gmp.hpp	/^struct component_type<number<gmp_rational> >$/;"	s
component_type	/usr/include/boost/multiprecision/rational_adapter.hpp	/^struct component_type<rational_adapter<T> >$/;"	s	namespace:boost::multiprecision
component_type::type	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef number<gmp_int> type;$/;"	t	struct:component_type	access:public
concepts	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^namespace concepts{$/;"	n	namespace:boost::multiprecision
const_limb_pointer	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef const limb_type*                const_limb_pointer;$/;"	t	struct:boost::multiprecision::cpp_int_base	access:public
const_limb_pointer	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef typename allocator_type::const_pointer                const_limb_pointer;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
constant_initializer	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^struct constant_initializer$/;"	s
constant_initializer::constant_initializer::init	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^typename constant_initializer<T, F>::initializer const constant_initializer<T, F>::init;$/;"	m	class:constant_initializer::constant_initializer
constant_initializer::do_nothing	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^   static void do_nothing()$/;"	f	struct:constant_initializer	access:public	signature:()
constant_initializer::init	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^   static const initializer init;$/;"	m	struct:constant_initializer	access:private
constant_initializer::initializer	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^   struct initializer$/;"	s	struct:constant_initializer	access:private
constant_initializer::initializer::do_nothing	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^      void do_nothing()const{}$/;"	f	struct:constant_initializer::initializer	access:public	signature:() const
constant_initializer::initializer::initializer	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^      initializer()$/;"	f	struct:constant_initializer::initializer	access:public	signature:()
convert_to	/usr/include/boost/multiprecision/number.hpp	/^   T convert_to()const$/;"	f	class:boost::multiprecision::number	access:public	signature:() const
convert_to_imp	/usr/include/boost/multiprecision/number.hpp	/^   void convert_to_imp(T* result)const$/;"	f	class:boost::multiprecision::number	access:private	signature:(T* result) const
convert_to_imp	/usr/include/boost/multiprecision/number.hpp	/^   void convert_to_imp(number<B2, ET>* result)const$/;"	f	class:boost::multiprecision::number	access:private	signature:(number<B2, ET>* result) const
convert_to_imp	/usr/include/boost/multiprecision/number.hpp	/^   void convert_to_imp(std::string* result)const$/;"	f	class:boost::multiprecision::number	access:private	signature:(std::string* result) const
cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float()   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(I i, typename enable_if<is_signed<I> >::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(I i, typename enable_if<is_signed<I> >::type* = 0)
cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(I i, typename enable_if<is_unsigned<I> >::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(I i, typename enable_if<is_unsigned<I> >::type* = 0)
cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const F val, typename enable_if<is_floating_point<F> >::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const F val, typename enable_if<is_floating_point<F> >::type* = 0)
cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const char* s) : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const char* s)
cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const cpp_dec_float& f)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& f)
cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const cpp_dec_float<D, ET, A>& f, typename enable_if_c<D <= Digits10>::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float<D, ET, A>& f, typename enable_if_c<D <= Digits10>::type* = 0)
cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(const double val, ExponentType exponent);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const double val, ExponentType exponent)
cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float(fpclass_type c)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(fpclass_type c)
cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   explicit cpp_dec_float(const cpp_dec_float<D, ET, A>& f, typename disable_if_c<D <= Digits10>::type* = 0)   : $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float<D, ET, A>& f, typename disable_if_c<D <= Digits10>::type* = 0)
cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^class cpp_dec_float$/;"	c	namespace:boost::multiprecision::backends
cpp_dec_float	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float(const double mantissa, const ExponentType exponent)   $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const double mantissa, const ExponentType exponent)
cpp_dec_float_100	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^typedef number<cpp_dec_float<100> > cpp_dec_float_100;$/;"	t	namespace:boost::multiprecision
cpp_dec_float_50	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^typedef number<cpp_dec_float<50> > cpp_dec_float_50;$/;"	t	namespace:boost::multiprecision
cpp_dec_float_NaN	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      cpp_dec_float_NaN$/;"	e	enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type
cpp_dec_float_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10          = ((cpp_dec_float_digits10_setting < cpp_dec_float_digits10_limit_lo) ? cpp_dec_float_digits10_limit_lo : ((cpp_dec_float_digits10_setting > cpp_dec_float_digits10_limit_hi) ? cpp_dec_float_digits10_limit_hi : cpp_dec_float_digits10_setting));$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10 = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	struct:boost::math::policies::precision	access:public
cpp_dec_float_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_digits10_limit_hi	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10_limit_hi = boost::integer_traits<boost::int32_t>::const_max - 100;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_digits10_limit_hi	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10_limit_hi;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_digits10_limit_lo	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10_limit_lo = 9L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_digits10_limit_lo	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10_limit_lo;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_digits10_setting	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_digits10_setting = Digits10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
cpp_dec_float_digits10_setting	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10_setting;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_elem_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_digits10 = 8L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
cpp_dec_float_elem_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_digits10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_elem_mask	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_mask     = 100000000L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
cpp_dec_float_elem_mask	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_mask;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_elem_number	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_number = static_cast<boost::int32_t>(((cpp_dec_float_elem_number_request < 2L) ? 2L : cpp_dec_float_elem_number_request) + 3L);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
cpp_dec_float_elem_number	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_number;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_elem_number_request	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_elem_number_request = static_cast<boost::int32_t>((cpp_dec_float_digits10 \/ cpp_dec_float_elem_digits10) + (((cpp_dec_float_digits10 % cpp_dec_float_elem_digits10) != 0) ? 1 : 0));$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
cpp_dec_float_elem_number_request	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_elem_number_request;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_finite	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      cpp_dec_float_finite,$/;"	e	enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type
cpp_dec_float_inf	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      cpp_dec_float_inf,$/;"	e	enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type
cpp_dec_float_max_exp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_max_exp           = static_cast<ExponentType>((cpp_dec_float_max_exp10 \/ 301LL) * 1000LL);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_max_exp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_max_exp10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_max_exp10         = (static_cast<ExponentType>(1) << (std::numeric_limits<ExponentType>::digits - 5));$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_max_exp10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_min_exp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_min_exp           = static_cast<ExponentType>((cpp_dec_float_min_exp10 \/ 301LL) * 1000LL);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_min_exp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_min_exp10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const ExponentType cpp_dec_float_min_exp10         = -cpp_dec_float_max_exp10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_min_exp10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const ExponentType cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_radix	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_radix             = 10L;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_dec_float_radix	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^const boost::int32_t cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_radix;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
cpp_dec_float_total_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const boost::int32_t cpp_dec_float_total_digits10 = static_cast<boost::int32_t>(cpp_dec_float_elem_number * cpp_dec_float_elem_digits10);$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:public
cpp_int	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<> >                   cpp_int;$/;"	t
cpp_int_backend	/usr/include/boost/multiprecision/cpp_int.hpp	/^   explicit cpp_int_backend(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other,$/;"	f	namespace:boost::multiprecision	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other, typename enable_if_c< (!((is_signed_number<cpp_int_backend<MinBits, MaxBits, SignType, Allocator> >::value || !is_signed_number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2> >::value) && (!is_void<Allocator>::value || (is_void<Allocator2>::value && (MinBits >= MinBits2)))) && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2> >::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Allocator> >::value) >::type* = 0)
cpp_int_backend	/usr/include/boost/multiprecision/cpp_int.hpp	/^   explicit cpp_int_backend(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other,$/;"	f	namespace:boost::multiprecision	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other, typename enable_if_c< (!((is_signed_number<cpp_int_backend<MinBits, MaxBits, SignType, Allocator> >::value || !is_signed_number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2> >::value)) && (!is_void<Allocator>::value || (is_void<Allocator2>::value && (MinBits >= MinBits2))) && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2> >::value && !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Allocator> >::value) >::type* = 0)
cpp_int_backend	/usr/include/boost/multiprecision/cpp_int.hpp	/^   explicit cpp_int_backend(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other,$/;"	f	namespace:boost::multiprecision	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other, typename enable_if_c< (!((is_signed_number<cpp_int_backend<MinBits, MaxBits, SignType, Allocator> >::value || !is_signed_number<cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2> >::value)) && (!is_void<Allocator>::value || (is_void<Allocator2>::value && (MinBits >= MinBits2))) && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2> >::value && is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Allocator> >::value) >::type* = 0)
cpp_int_base	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE cpp_int_base(const cpp_int_base& o) : allocator_type(o), m_limbs(0), m_internal(true)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_base& o)
cpp_int_base	/usr/include/boost/multiprecision/cpp_int.hpp	/^   cpp_int_base(cpp_int_base&& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_base&& o)
cpp_int_base	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false> : private Allocator::template rebind<limb_type>::other$/;"	s	namespace:boost::multiprecision::backends	inherits:Allocator::,rebind::other
cpp_int_base	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct cpp_int_base<MinBits, MaxBits, unsigned_magnitude, Checked, Allocator, false> : private Allocator::template rebind<limb_type>::other$/;"	s	namespace:boost::multiprecision	inherits:Allocator::,rebind::other
cpp_int_base	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct cpp_int_base<MinBits, MinBits, signed_magnitude, Checked, void, false>$/;"	s	namespace:boost::multiprecision
cpp_int_check_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^enum cpp_int_check_type$/;"	g	namespace:boost::multiprecision
cpp_integer_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^enum cpp_integer_type$/;"	g	namespace:boost::multiprecision
cpp_rational	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_rational_backend>                 cpp_rational;$/;"	t
cpp_rational_backend	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef rational_adapter<cpp_int_backend<> >         cpp_rational_backend;$/;"	t
data	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   T* data()$/;"	f	struct:boost::multiprecision::backends::detail::dynamic_array	access:public	signature:()
data	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   array_type      data;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
data	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   const T* data()const$/;"	f	struct:boost::multiprecision::backends::detail::dynamic_array	access:public	signature:() const
data	/usr/include/boost/multiprecision/cpp_int.hpp	/^      limb_pointer data;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base::limb_data	access:public
data	/usr/include/boost/multiprecision/gmp.hpp	/^   const mpz_t& data()const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:() const
data	/usr/include/boost/multiprecision/gmp.hpp	/^   mpz_t& data()$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:()
data	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   const rational_type& data()const { return m_value; }$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:() const
data	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_type& data() { return m_value; }$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:()
data	/usr/include/boost/multiprecision/tommath.hpp	/^   ::mp_int& data() $/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
data	/usr/include/boost/multiprecision/tommath.hpp	/^   const ::mp_int& data()const $/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:() const
data_elem_is_non_nine_predicate	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static bool data_elem_is_non_nine_predicate(const boost::uint32_t& d)  { return (d != static_cast<boost::uint32_t>(cpp_dec_float::cpp_dec_float_elem_mask - 1)); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const boost::uint32_t& d)
data_elem_is_non_zero_predicate	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static bool data_elem_is_non_zero_predicate(const boost::uint32_t& d)  { return (d != static_cast<boost::uint32_t>(0u)); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const boost::uint32_t& d)
data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type() : first(0) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:()
data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type() : m_first_limb(0) {}$/;"	f	union:boost::multiprecision::cpp_int_base::data_type	access:public	signature:()
data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(double_limb_type i) : double_first(i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(double_limb_type i)
data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(double_limb_type i) : m_double_first_limb(i) {}$/;"	f	union:boost::multiprecision::cpp_int_base::data_type	access:public	signature:(double_limb_type i)
data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(limb_type i) : first(i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(limb_type i)
data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(limb_type i) : m_first_limb(i) {}$/;"	f	union:boost::multiprecision::cpp_int_base::data_type	access:public	signature:(limb_type i)
data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(signed_double_limb_type i) : double_first(i < 0 ? -i : i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(signed_double_limb_type i)
data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^      BOOST_CONSTEXPR data_type(signed_limb_type i) : first(i < 0 ? -i : i) {}$/;"	f	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public	signature:(signed_limb_type i)
data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^   union data_type$/;"	u	struct:boost::multiprecision::backends::cpp_int_base	access:private
data_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^   union data_type{$/;"	u	struct:boost::multiprecision::cpp_int_base	access:private
declval	/usr/include/boost/multiprecision/number.hpp	/^      BOOST_NOEXCEPT_IF(noexcept(std::declval<Backend>().compare(std::declval<Backend>())))$/;"	f	class:boost::multiprecision::number	access:public	signature:()
default_ops	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^namespace boost{ namespace multiprecision{ namespace default_ops{$/;"	n	namespace:boost::multiprecision
default_ops	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^namespace default_ops$/;"	n	namespace:boost::multiprecision
default_ops	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^namespace default_ops{$/;"	n	namespace:boost::multiprecision
default_precision	/usr/include/boost/multiprecision/number.hpp	/^   static void default_precision(unsigned digits10)$/;"	f	class:boost::multiprecision::number	access:public	signature:(unsigned digits10)
denominator	/usr/include/boost/multiprecision/gmp.hpp	/^inline number<gmp_int, ET> denominator(const number<gmp_rational, ET>& val)$/;"	f	signature:(const number<gmp_rational, ET>& val)
denominator	/usr/include/boost/multiprecision/number.hpp	/^inline multiprecision::number<T, ExpressionTemplates> denominator(const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a)
denominator	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline number<IntBackend, ET> denominator(const number<rational_adapter<IntBackend>, ET>& val)$/;"	f	namespace:boost::multiprecision	signature:(const number<rational_adapter<IntBackend>, ET>& val)
denorm_min	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> denorm_min   (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::zero(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
denorm_min	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type denorm_min() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
denorm_min	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type denorm_min() { return base_type::denorm_min(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
denorm_min	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type denorm_min() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned depth = 0;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_depth > right_depth ? (left_depth > middle_depth ? left_depth : middle_depth) : (right_depth > middle_depth ? right_depth : middle_depth);$/;"	m	struct:boost::multiprecision::detail::expression	access:public
depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_depth > right_depth ? left_depth : right_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_max_depth > right_max_depth ? left_max_depth : right_max_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned depth = left_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
detail	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
detail	/usr/include/boost/multiprecision/cpp_int.hpp	/^namespace detail{$/;"	n
detail	/usr/include/boost/multiprecision/cpp_int.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
detail	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{$/;"	n	namespace:boost::multiprecision::backends
detail	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^namespace detail{$/;"	n	namespace:std
detail	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^namespace detail{$/;"	n	namespace:boost::math
detail	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	/usr/include/boost/multiprecision/detail/digits.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
detail	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^namespace detail{$/;"	n
detail	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
detail	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	/usr/include/boost/multiprecision/detail/number_base.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	/usr/include/boost/multiprecision/gmp.hpp	/^namespace detail{$/;"	n
detail	/usr/include/boost/multiprecision/gmp.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
detail	/usr/include/boost/multiprecision/integer.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	/usr/include/boost/multiprecision/miller_rabin.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	/usr/include/boost/multiprecision/mpfr.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
detail	/usr/include/boost/multiprecision/number.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	/usr/include/boost/multiprecision/random.hpp	/^namespace boost{ namespace random{ namespace detail{$/;"	n	namespace:boost::random
detail	/usr/include/boost/multiprecision/random.hpp	/^namespace detail{$/;"	n	namespace:boost::random
detail	/usr/include/boost/multiprecision/rational_adapter.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision
detail	/usr/include/boost/multiprecision/tommath.hpp	/^namespace detail{$/;"	n	namespace:boost::multiprecision::backends
detail	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
detail	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost::multiprecision
detail::double_precision_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct double_precision_type<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:detail
detail::double_precision_type::type	/usr/include/boost/multiprecision/cpp_int.hpp	/^   >::type type;$/;"	t	struct:detail::double_precision_type	access:public
detail::is_explicitly_convertible	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_explicitly_convertible<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> > : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
detail::is_explicitly_convertible	/usr/include/boost/multiprecision/gmp.hpp	/^struct is_explicitly_convertible<canonical<mpf_t, gmp_int>::type, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
detail::is_explicitly_convertible	/usr/include/boost/multiprecision/gmp.hpp	/^struct is_explicitly_convertible<canonical<mpq_t, gmp_int>::type, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
detail::is_explicitly_convertible	/usr/include/boost/multiprecision/gmp.hpp	/^struct is_explicitly_convertible<gmp_float<D1>, gmp_float<D2> > : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
detail::is_explicitly_convertible	/usr/include/boost/multiprecision/gmp.hpp	/^struct is_explicitly_convertible<gmp_float<Digits10>, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
detail::is_explicitly_convertible	/usr/include/boost/multiprecision/gmp.hpp	/^struct is_explicitly_convertible<gmp_rational, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
detail::pow_imp	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^inline void pow_imp(T& result, const T& t, const U& p, const mpl::false_&)$/;"	f	namespace:detail	signature:(T& result, const T& t, const U& p, const mpl::false_&)
detail::pow_imp	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^inline void pow_imp(T& result, const T& t, const U& p, const mpl::true_&)$/;"	f	namespace:detail	signature:(T& result, const T& t, const U& p, const mpl::true_&)
detail::sinhcosh	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^   void sinhcosh(const T& x, T* p_sinh, T* p_cosh)$/;"	f	namespace:detail	signature:(const T& x, T* p_sinh, T* p_cosh)
detail::small_sinh_series	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^   void small_sinh_series(T x, T& result)$/;"	f	namespace:detail	signature:(T x, T& result)
digits	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     digits            = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	class:std::numeric_limits	access:public
digits	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::digits;$/;"	m	class:std::numeric_limits
digits	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int digits = boost::multiprecision::backends::max_precision<backend_type>::value == UINT_MAX ? INT_MAX : boost::multiprecision::backends::max_precision<backend_type>::value;$/;"	m	class:std::numeric_limits	access:public
digits	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::digits;$/;"	m	class:std::numeric_limits
digits	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int digits = INT_MAX;$/;"	m	class:std::numeric_limits	access:public
digits	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::digits;$/;"	m	class:std::numeric_limits
digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     digits10          = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	class:std::numeric_limits	access:public
digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::digits10;$/;"	m	class:std::numeric_limits
digits10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int digits10 = (INT_MAX \/ 1000) * 301L;$/;"	m	class:std::numeric_limits	access:public
digits10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::digits10;$/;"	m	class:std::numeric_limits
digits10	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int digits10 = (INT_MAX \/ 1000) * 301L;$/;"	m	class:std::numeric_limits	access:public
digits10	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::digits10;$/;"	m	class:std::numeric_limits
digits10_2_2	/usr/include/boost/multiprecision/detail/digits.hpp	/^inline unsigned long digits10_2_2(unsigned long d10)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long d10)
digits2	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct digits2$/;"	s	namespace:boost::multiprecision::detail
digits2	/usr/include/boost/multiprecision/mpfr.hpp	/^   static const unsigned digits2 = (digits10 * 1000uL) \/ 301uL + ((digits10 * 1000uL) % 301 ? 2u : 1u);$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
digits2_2_10	/usr/include/boost/multiprecision/detail/digits.hpp	/^inline unsigned long digits2_2_10(unsigned long d2)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned long d2)
digits_2	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef digits2<((cpp_dec_float_digits10 + 1LL) * 1000LL) \/ 301LL> digits_2;$/;"	t	struct:boost::math::policies::precision	access:public
digits_per_block_10	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^static const limb_type digits_per_block_10 = 18;$/;"	m	namespace:boost::multiprecision
discard	/usr/include/boost/multiprecision/random.hpp	/^    void discard(boost::uintmax_t z)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(boost::uintmax_t z)
distribution_type	/usr/include/boost/multiprecision/random.hpp	/^        typedef uniform_smallint distribution_type;$/;"	t	class:boost::random::uniform_smallint::param_type	access:public
div_loop_n	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static boost::uint32_t div_loop_n (boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
div_loop_n	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^boost::uint32_t cpp_dec_float<Digits10, ExponentType, Allocator>::div_loop_n(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
div_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& div_unsigned_long_long(const unsigned long long n);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
div_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::div_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const unsigned long long n)
divide_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct divide_immediates{};$/;"	s	namespace:boost::multiprecision::detail
divide_qr	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   divide_qr(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>& y,$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const multiprecision::detail::expression<tagb, A1b, A2b, A3b, A4b>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
divide_qr	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   divide_qr(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const number<Backend, ExpressionTemplates>& y,$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, const number<Backend, ExpressionTemplates>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
divide_qr	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   divide_qr(const number<Backend, ExpressionTemplates>& x, const multiprecision::detail::expression<tag, A1, A2, A3, A4>& y,$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, const multiprecision::detail::expression<tag, A1, A2, A3, A4>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
divide_qr	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   divide_qr(const number<Backend, ExpressionTemplates>& x, const number<Backend, ExpressionTemplates>& y,$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, const number<Backend, ExpressionTemplates>& y, number<Backend, ExpressionTemplates>& q, number<Backend, ExpressionTemplates>& r)
divide_qr	/usr/include/boost/multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value>::type divide_qr(const Integer& x, const Integer& y, Integer& q, Integer& r)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& x, const Integer& y, Integer& q, Integer& r)
divide_unsigned_helper	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^void divide_unsigned_helper($/;"	f	namespace:boost::multiprecision::backends	signature:( CppInt1* result, const CppInt2& x, const CppInt3& y, CppInt1& r)
divide_unsigned_helper	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^void divide_unsigned_helper($/;"	f	namespace:boost::multiprecision::backends	signature:( CppInt1* result, const CppInt2& x, limb_type y, CppInt1& r)
divides	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct divides{};$/;"	s	namespace:boost::multiprecision::detail
do_add	/usr/include/boost/multiprecision/number.hpp	/^   void do_add(const Exp& e, const detail::add_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::add_immediates&)
do_add	/usr/include/boost/multiprecision/number.hpp	/^   void do_add(const Exp& e, const detail::minus&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::minus&)
do_add	/usr/include/boost/multiprecision/number.hpp	/^   void do_add(const Exp& e, const detail::negate&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::negate&)
do_add	/usr/include/boost/multiprecision/number.hpp	/^   void do_add(const Exp& e, const detail::plus&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::plus&)
do_add	/usr/include/boost/multiprecision/number.hpp	/^   void do_add(const Exp& e, const detail::subtract_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::subtract_immediates&)
do_add	/usr/include/boost/multiprecision/number.hpp	/^   void do_add(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
do_add	/usr/include/boost/multiprecision/number.hpp	/^   void do_add(const Exp& e, const unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const unknown&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::add_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::add_immediates&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::bitwise_and&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_and&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::bitwise_and_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_and_immediates&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::bitwise_complement&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_complement&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::bitwise_or&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_or&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::bitwise_or_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_or_immediates&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::bitwise_xor&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_xor&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::bitwise_xor_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_xor_immediates&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::complement_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::complement_immediates&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::divide_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::divide_immediates&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::divides&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::divides&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::function&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::function&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::minus&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::minus&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::modulus&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::modulus&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::modulus_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::modulus_immediates&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::multiplies&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiplies&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::multiply_add&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiply_add&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::multiply_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiply_immediates&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::multiply_subtract&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiply_subtract&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::negate&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::negate&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::plus&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::plus&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::shift_left&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::shift_left&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::shift_right&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::shift_right&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::subtract_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::subtract_immediates&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e, const mpl::false_&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e, const mpl::false_&)
do_assign	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e, const mpl::true_&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e, const mpl::true_&)
do_assign_arithmetic	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typename disable_if<is_unsigned<A> >::type do_assign_arithmetic(A val, const mpl::true_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(A val, const mpl::true_&)
do_assign_arithmetic	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typename enable_if<is_unsigned<A> >::type do_assign_arithmetic(A val, const mpl::true_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(A val, const mpl::true_&)
do_assign_arithmetic	/usr/include/boost/multiprecision/cpp_int.hpp	/^   void do_assign_arithmetic(double_limb_type i, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(double_limb_type i, const mpl::false_&)
do_assign_arithmetic	/usr/include/boost/multiprecision/cpp_int.hpp	/^   void do_assign_arithmetic(long double a, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(long double a, const mpl::false_&)
do_assign_arithmetic	/usr/include/boost/multiprecision/cpp_int.hpp	/^   void do_assign_arithmetic(signed_double_limb_type i, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(signed_double_limb_type i, const mpl::false_&)
do_assign_function	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function(const Exp& e, const mpl::int_<1>&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const mpl::int_<1>&)
do_assign_function	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function(const Exp& e, const mpl::int_<2>&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const mpl::int_<2>&)
do_assign_function	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function(const Exp& e, const mpl::int_<3>&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const mpl::int_<3>&)
do_assign_function	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function(const Exp& e, const mpl::int_<4>&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const mpl::int_<4>&)
do_assign_function_1	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_1(const F& f, const Exp& val, const Tag&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp& val, const Tag&)
do_assign_function_1	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_1(const F& f, const Exp& val, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp& val, const detail::terminal&)
do_assign_function_2	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_2(const F& f, const Exp1& val1, const Exp2& val2, const Tag1&, const Tag2&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Tag1&, const Tag2&)
do_assign_function_2	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_2(const F& f, const Exp1& val1, const Exp2& val2, const Tag1&, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Tag1&, const detail::terminal&)
do_assign_function_2	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_2(const F& f, const Exp1& val1, const Exp2& val2, const detail::terminal&, const Tag2&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const detail::terminal&, const Tag2&)
do_assign_function_2	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_2(const F& f, const Exp1& val1, const Exp2& val2, const detail::terminal&, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const detail::terminal&, const detail::terminal&)
do_assign_function_3a	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_3a(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag1&, const Tag2& t2, const Tag3& t3)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag1&, const Tag2& t2, const Tag3& t3)
do_assign_function_3a	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_3a(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&, const Tag2& t2, const Tag3& t3)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&, const Tag2& t2, const Tag3& t3)
do_assign_function_3b	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_3b(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag2& \/*t2*\/, const Tag3& t3)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag2& , const Tag3& t3)
do_assign_function_3b	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_3b(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&, const Tag3& t3)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&, const Tag3& t3)
do_assign_function_3c	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_3c(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag3& \/*t3*\/)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const Tag3& )
do_assign_function_3c	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_function_3c(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const F& f, const Exp1& val1, const Exp2& val2, const Exp3& val3, const detail::terminal&)
do_assign_left_shift	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_left_shift(const Exp& e, const Val& val, const Tag&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const Val& val, const Tag&)
do_assign_left_shift	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_left_shift(const Exp& e, const Val& val, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const Val& val, const detail::terminal&)
do_assign_right_shift	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_right_shift(const Exp& e, const Val& val, const Tag&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const Val& val, const Tag&)
do_assign_right_shift	/usr/include/boost/multiprecision/number.hpp	/^   void do_assign_right_shift(const Exp& e, const Val& val, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const Val& val, const detail::terminal&)
do_assign_string	/usr/include/boost/multiprecision/cpp_int.hpp	/^   void do_assign_string(const char* s, const mpl::false_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(const char* s, const mpl::false_&)
do_assign_string	/usr/include/boost/multiprecision/cpp_int.hpp	/^   void do_assign_string(const char* s, const mpl::true_&)$/;"	f	namespace:boost::multiprecision	access:private	signature:(const char* s, const mpl::true_&)
do_bitwise_and	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_and(const Exp& e, const detail::bitwise_and&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_and&)
do_bitwise_and	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_and(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
do_bitwise_and	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_and(const Exp& e, const unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const unknown&)
do_bitwise_or	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_or(const Exp& e, const detail::bitwise_or&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_or&)
do_bitwise_or	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_or(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
do_bitwise_or	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_or(const Exp& e, const unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const unknown&)
do_bitwise_xor	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_xor(const Exp& e, const detail::bitwise_xor&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::bitwise_xor&)
do_bitwise_xor	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_xor(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
do_bitwise_xor	/usr/include/boost/multiprecision/number.hpp	/^   void do_bitwise_xor(const Exp& e, const unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const unknown&)
do_divide	/usr/include/boost/multiprecision/number.hpp	/^   void do_divide(const Exp& e, const detail::divides&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::divides&)
do_divide	/usr/include/boost/multiprecision/number.hpp	/^   void do_divide(const Exp& e, const detail::multiplies&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiplies&)
do_divide	/usr/include/boost/multiprecision/number.hpp	/^   void do_divide(const Exp& e, const detail::negate&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::negate&)
do_divide	/usr/include/boost/multiprecision/number.hpp	/^   void do_divide(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
do_divide	/usr/include/boost/multiprecision/number.hpp	/^   void do_divide(const Exp& e, const unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const unknown&)
do_divides	/usr/include/boost/multiprecision/number.hpp	/^   void do_divides(const Exp& e, const detail::divide_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::divide_immediates&)
do_divides	/usr/include/boost/multiprecision/number.hpp	/^   void do_divides(const Exp& e, const detail::multiply_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiply_immediates&)
do_get_string	/usr/include/boost/multiprecision/cpp_int.hpp	/^   std::string do_get_string(std::ios_base::fmtflags f, const mpl::false_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::false_&) const
do_get_string	/usr/include/boost/multiprecision/cpp_int.hpp	/^   std::string do_get_string(std::ios_base::fmtflags f, const mpl::true_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::true_&) const
do_get_trivial_string	/usr/include/boost/multiprecision/cpp_int.hpp	/^   std::string do_get_trivial_string(std::ios_base::fmtflags f, const mpl::false_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::false_&) const
do_get_trivial_string	/usr/include/boost/multiprecision/cpp_int.hpp	/^   std::string do_get_trivial_string(std::ios_base::fmtflags f, const mpl::true_&)const$/;"	f	namespace:boost::multiprecision	access:private	signature:(std::ios_base::fmtflags f, const mpl::true_&) const
do_modulus	/usr/include/boost/multiprecision/number.hpp	/^   void do_modulus(const Exp& e, const Unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const Unknown&)
do_modulus	/usr/include/boost/multiprecision/number.hpp	/^   void do_modulus(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
do_multiplies	/usr/include/boost/multiprecision/number.hpp	/^   void do_multiplies(const Exp& e, const detail::divide_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::divide_immediates&)
do_multiplies	/usr/include/boost/multiprecision/number.hpp	/^   void do_multiplies(const Exp& e, const detail::divides&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::divides&)
do_multiplies	/usr/include/boost/multiprecision/number.hpp	/^   void do_multiplies(const Exp& e, const detail::multiplies&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiplies&)
do_multiplies	/usr/include/boost/multiprecision/number.hpp	/^   void do_multiplies(const Exp& e, const detail::multiply_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::multiply_immediates&)
do_multiplies	/usr/include/boost/multiprecision/number.hpp	/^   void do_multiplies(const Exp& e, const detail::negate&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::negate&)
do_multiplies	/usr/include/boost/multiprecision/number.hpp	/^   void do_multiplies(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
do_multiplies	/usr/include/boost/multiprecision/number.hpp	/^   void do_multiplies(const Exp& e, const unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const unknown&)
do_nothing	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^         void do_nothing(){}$/;"	f	struct:boost::multiprecision::backends::cpp_dec_float::initializer	access:public	signature:()
do_nothing	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^      void do_nothing()const{}$/;"	f	struct:std::numeric_limits::inititializer	access:public	signature:() const
do_nothing	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^      void do_nothing()const{}$/;"	f	struct:constant_initializer::initializer	access:public	signature:() const
do_nothing	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^   static void do_nothing()$/;"	f	struct:constant_initializer	access:public	signature:()
do_subtract	/usr/include/boost/multiprecision/number.hpp	/^   void do_subtract(const Exp& e, const detail::add_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::add_immediates&)
do_subtract	/usr/include/boost/multiprecision/number.hpp	/^   void do_subtract(const Exp& e, const detail::minus&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::minus&)
do_subtract	/usr/include/boost/multiprecision/number.hpp	/^   void do_subtract(const Exp& e, const detail::negate&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::negate&)
do_subtract	/usr/include/boost/multiprecision/number.hpp	/^   void do_subtract(const Exp& e, const detail::plus&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::plus&)
do_subtract	/usr/include/boost/multiprecision/number.hpp	/^   void do_subtract(const Exp& e, const detail::subtract_immediates&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::subtract_immediates&)
do_subtract	/usr/include/boost/multiprecision/number.hpp	/^   void do_subtract(const Exp& e, const detail::terminal&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const detail::terminal&)
do_subtract	/usr/include/boost/multiprecision/number.hpp	/^   void do_subtract(const Exp& e, const unknown&)$/;"	f	class:boost::multiprecision::number	access:private	signature:(const Exp& e, const unknown&)
double_first	/usr/include/boost/multiprecision/cpp_int.hpp	/^      double_limb_type double_first;$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
double_integer	/usr/include/boost/multiprecision/integer.hpp	/^struct double_integer$/;"	s	namespace:boost::multiprecision::detail
double_limb_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^typedef boost::uint128_type double_limb_type;$/;"	t	namespace:boost::multiprecision
double_max	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& double_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
double_min	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& double_min()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
double_precision_type	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct double_precision_type<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:detail
double_precision_type	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^struct double_precision_type$/;"	s	namespace:boost::multiprecision::detail
dummy_size	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^struct dummy_size{};$/;"	s	namespace:boost::multiprecision::detail
dynamic_array	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   dynamic_array()$/;"	f	struct:boost::multiprecision::backends::detail::dynamic_array	access:public	signature:()
dynamic_array	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^struct dynamic_array : public std::vector<T, typename rebind<T, Allocator>::type>$/;"	s	namespace:boost::multiprecision::backends::detail	inherits:std::vector
enum_fpclass_type	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef enum enum_fpclass_type$/;"	g	class:boost::multiprecision::backends::cpp_dec_float	access:private
eps	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& eps()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
epsilon	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> epsilon      (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::eps(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
epsilon	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type epsilon() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
epsilon	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type epsilon() { return base_type::epsilon(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
epsilon	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type epsilon() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
et_off	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   et_off  = 0,$/;"	e	enum:boost::multiprecision::expression_template_option
et_on	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   et_on   = 1$/;"	e	enum:boost::multiprecision::expression_template_option
eval_abs	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_abs(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x) $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
eval_abs	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_abs(T& result, const T& arg)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg)
eval_abs	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_abs(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
eval_abs	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_abs(gmp_int& result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& val)
eval_abs	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_abs(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
eval_abs	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_abs(tommath_int& result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& val)
eval_acos	/usr/include/boost/multiprecision/detail/functions/trig.hpp	/^inline void eval_acos(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_add	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_add(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
eval_add	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_add(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
eval_add	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_add(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
eval_add	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_add(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
eval_add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_add(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_add(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_add(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
eval_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_add(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
eval_add	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_add(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
eval_add	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline void eval_add(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)
eval_add	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_add(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
eval_add	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_add(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
eval_add	/usr/include/boost/multiprecision/tommath.hpp	/^void eval_add(tommath_int& t, const tommath_int& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
eval_add_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_add_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_add_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_add_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_add_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_add_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_add_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_add_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_add_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_add_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_asin	/usr/include/boost/multiprecision/detail/functions/trig.hpp	/^void eval_asin(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_atan	/usr/include/boost/multiprecision/detail/functions/trig.hpp	/^void eval_atan(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_atan2	/usr/include/boost/multiprecision/detail/functions/trig.hpp	/^inline typename enable_if<is_arithmetic<A>, void>::type eval_atan2(T& result, const A& x, const T& a)$/;"	f	signature:(T& result, const A& x, const T& a)
eval_atan2	/usr/include/boost/multiprecision/detail/functions/trig.hpp	/^inline typename enable_if<is_arithmetic<A>, void>::type eval_atan2(T& result, const T& x, const A& a)$/;"	f	signature:(T& result, const T& x, const A& a)
eval_atan2	/usr/include/boost/multiprecision/detail/functions/trig.hpp	/^void eval_atan2(T& result, const T& y, const T& x)$/;"	f	signature:(T& result, const T& y, const T& x)
eval_bit_flip	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_bit_flip(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)
eval_bit_flip	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bit_flip(T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val, unsigned index)
eval_bit_set	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_bit_set(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& val, unsigned index)
eval_bit_set	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bit_set(T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val, unsigned index)
eval_bit_test	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool eval_bit_test(const T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val, unsigned index)
eval_bit_unset	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bit_unset(T& val, unsigned index)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val, unsigned index)
eval_bitwise_and	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_bitwise_and(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_bitwise_and	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_and(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_and	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_bitwise_and(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_and	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_bitwise_and(gmp_int& result, const gmp_int& u, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u, const gmp_int& v)
eval_bitwise_and	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_bitwise_and(gmp_int& result, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& v)
eval_bitwise_and	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_bitwise_and(tommath_int& result, const tommath_int& u, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& u, const tommath_int& v)
eval_bitwise_and	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_bitwise_and(tommath_int& result, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& v)
eval_bitwise_and_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_bitwise_and_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_bitwise_and_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_bitwise_and_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_bitwise_and_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_and_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_bitwise_and_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_and_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_bitwise_and_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_and_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_or	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_bitwise_or(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_bitwise_or	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_or(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_or	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_bitwise_or(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_or	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_bitwise_or(gmp_int& result, const gmp_int& u, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u, const gmp_int& v)
eval_bitwise_or	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_bitwise_or(gmp_int& result, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& v)
eval_bitwise_or	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_bitwise_or(tommath_int& result, const tommath_int& u, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& u, const tommath_int& v)
eval_bitwise_or	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_bitwise_or(tommath_int& result, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& v)
eval_bitwise_or_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_bitwise_or_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_bitwise_or_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_bitwise_or_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_bitwise_or_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_or_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_bitwise_or_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_or_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_bitwise_or_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_or_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_xor	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_bitwise_xor(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_bitwise_xor	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_xor(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_xor	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_bitwise_xor(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_bitwise_xor	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_bitwise_xor(gmp_int& result, const gmp_int& u, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u, const gmp_int& v)
eval_bitwise_xor	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_bitwise_xor(gmp_int& result, const gmp_int& v)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& v)
eval_bitwise_xor	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_bitwise_xor(tommath_int& result, const tommath_int& u, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& u, const tommath_int& v)
eval_bitwise_xor	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_bitwise_xor(tommath_int& result, const tommath_int& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& v)
eval_bitwise_xor_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_bitwise_xor_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_bitwise_xor_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_bitwise_xor_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_bitwise_xor_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_bitwise_xor_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_bitwise_xor_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_xor_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_bitwise_xor_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_bitwise_xor_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_ceil	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_ceil(number_backend_float_architype& result, const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg)
eval_ceil	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_ceil(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
eval_ceil	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_ceil();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
eval_ceil	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_ceil(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
eval_ceil	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_ceil(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
eval_complement	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_complement(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_complement	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_complement(gmp_int& result, const gmp_int& u)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& u)
eval_convert_to	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_convert_to(long double* result, number_backend_float_architype& val)$/;"	f	namespace:boost::multiprecision::concepts	signature:(long double* result, number_backend_float_architype& val)
eval_convert_to	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_convert_to(long long* result, const number_backend_float_architype& val)$/;"	f	namespace:boost::multiprecision::concepts	signature:(long long* result, const number_backend_float_architype& val)
eval_convert_to	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_convert_to(unsigned long long* result, const number_backend_float_architype& val)$/;"	f	namespace:boost::multiprecision::concepts	signature:(unsigned long long* result, const number_backend_float_architype& val)
eval_convert_to	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_convert_to(long double* result, cpp_dec_float<Digits10, ExponentType, Allocator>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(long double* result, cpp_dec_float<Digits10, ExponentType, Allocator>& val)
eval_convert_to	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_convert_to(long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)  $/;"	f	namespace:boost::multiprecision::backends	signature:(long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
eval_convert_to	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_convert_to(unsigned long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)  $/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned long long* result, const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
eval_convert_to	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_convert_to(R* result, const B& backend)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(R* result, const B& backend)
eval_convert_to	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_convert_to(std::string* result, const B& backend)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(std::string* result, const B& backend)
eval_convert_to	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_convert_to(terminal<R>* result, const B& backend)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(terminal<R>* result, const B& backend)
eval_convert_to	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_convert_to(double* result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(double* result, const gmp_int& val)
eval_convert_to	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_convert_to(long long* result, const gmp_float<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(long long* result, const gmp_float<digits10>& val)
eval_convert_to	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_convert_to(long* result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(long* result, const gmp_int& val)
eval_convert_to	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_convert_to(unsigned long long* result, const gmp_float<digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(unsigned long long* result, const gmp_float<digits10>& val)
eval_convert_to	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_convert_to(unsigned long* result, const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(unsigned long* result, const gmp_int& val)
eval_convert_to	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_convert_to(long long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(long long* result, const mpfr_float_backend<digits10, AllocationType>& val)
eval_convert_to	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_convert_to(long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(long* result, const mpfr_float_backend<digits10, AllocationType>& val)
eval_convert_to	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_convert_to(unsigned long long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned long long* result, const mpfr_float_backend<digits10, AllocationType>& val)
eval_convert_to	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_convert_to(unsigned long* result, const mpfr_float_backend<digits10, AllocationType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned long* result, const mpfr_float_backend<digits10, AllocationType>& val)
eval_convert_to	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline void eval_convert_to(R* result, const rational_adapter<IntBackend>& backend)$/;"	f	namespace:boost::multiprecision::backends	signature:(R* result, const rational_adapter<IntBackend>& backend)
eval_convert_to	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_convert_to(A* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(A* result, const tommath_int& val)
eval_convert_to	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_convert_to(char* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(char* result, const tommath_int& val)
eval_convert_to	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_convert_to(signed char* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(signed char* result, const tommath_int& val)
eval_convert_to	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_convert_to(unsigned char* result, const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(unsigned char* result, const tommath_int& val)
eval_cos	/usr/include/boost/multiprecision/detail/functions/trig.hpp	/^void eval_cos(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_cosh	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^inline void eval_cosh(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_decrement	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_decrement(T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val)
eval_divide	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_divide(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
eval_divide	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_divide(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
eval_divide	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_divide(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
eval_divide	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_divide(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
eval_divide	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o)
eval_divide	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b)
eval_divide	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, limb_type& b)
eval_divide	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, signed_limb_type& b)
eval_divide	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& b)
eval_divide	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, limb_type b)
eval_divide	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_divide($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, signed_limb_type b)
eval_divide	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_divide(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_divide	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_divide(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_divide	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_divide(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
eval_divide	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_divide(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
eval_divide	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_divide(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
eval_divide	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline void eval_divide(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)
eval_divide	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_divide(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
eval_divide	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_divide(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
eval_divide_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_divide_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_divide_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_divide_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_divide_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_divide_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_divide_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_divide_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_divide_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_divide_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_divide_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_divide_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_eq	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool eval_eq(const B& a, const A& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const A& b)
eval_eq	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool eval_eq(const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const B& b)
eval_eq	/usr/include/boost/multiprecision/gmp.hpp	/^inline typename enable_if<is_arithmetic<T>, bool>::type eval_eq(const gmp_int& a, const T& b)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& a, const T& b)
eval_exp	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^void eval_exp(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_fabs	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_fabs(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x) $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
eval_fabs	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_fabs(T& result, const T& arg)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg)
eval_fabs	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_fabs(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
eval_fabs	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_fabs(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
eval_floor	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_floor(number_backend_float_architype& result, const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg)
eval_floor	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_floor(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
eval_floor	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_floor();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
eval_floor	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_floor(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
eval_floor	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_floor(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
eval_fmod	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_arithmetic<A>, void>::type eval_fmod(T& result, const A& x, const T& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const A& x, const T& a)
eval_fmod	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_arithmetic<A>, void>::type eval_fmod(T& result, const T& x, const A& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& x, const A& a)
eval_fmod	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_fmod(T& result, const T& a, const T& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a, const T& b)
eval_fpclassify	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline int eval_fpclassify(const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(const number_backend_float_architype& arg)
eval_fpclassify	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline int eval_fpclassify(const cpp_dec_float<Digits10, ExponentType, Allocator>& x) $/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
eval_fpclassify	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int eval_fpclassify(const Backend& arg)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const Backend& arg)
eval_frexp	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_frexp(number_backend_float_architype& result, const number_backend_float_architype& arg, int* exp)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg, int* exp)
eval_frexp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline typename disable_if<is_same<ExponentType, int> >::type eval_frexp(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, int* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, int* e)
eval_frexp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_frexp(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ExponentType* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ExponentType* e)
eval_frexp	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_frexp();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
eval_frexp	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_frexp(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, int* e)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, int* e)
eval_frexp	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_frexp(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long* e)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long* e)
eval_frexp	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_frexp(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, int* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, int* e)
eval_frexp	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_frexp(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long* e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long* e)
eval_gcd	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_gcd($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a, limb_type v)
eval_gcd	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_gcd(T& result, const Arithmetic& a, const T& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const Arithmetic& a, const T& b)
eval_gcd	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_gcd(T& result, const T& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a, const Arithmetic& b)
eval_gcd	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_gcd(B& result, const B& a, const B& b);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
eval_gcd	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^inline void eval_gcd(B& result, const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
eval_gcd	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_gcd(gmp_int& result, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& a, const gmp_int& b)
eval_gcd	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_gcd(tommath_int& result, const tommath_int& a, const tommath_int& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& a, const tommath_int& b)
eval_get_sign	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline int eval_get_sign(const cpp_dec_float<Digits10, ExponentType, Allocator>& val) $/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
eval_get_sign	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int eval_get_sign(const T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val)
eval_get_sign	/usr/include/boost/multiprecision/gmp.hpp	/^inline int eval_get_sign(const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& val)
eval_get_sign	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline int eval_get_sign(const rational_adapter<IntBackend>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const rational_adapter<IntBackend>& val)
eval_get_sign	/usr/include/boost/multiprecision/tommath.hpp	/^inline int eval_get_sign(const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
eval_get_sign	/usr/include/boost/multiprecision/tommath.hpp	/^int eval_get_sign(const tommath_int& val);$/;"	p	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
eval_gt	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool eval_gt(const B& a, const A& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const A& b)
eval_gt	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool eval_gt(const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const B& b)
eval_gt	/usr/include/boost/multiprecision/gmp.hpp	/^inline typename enable_if<is_arithmetic<T>, bool>::type eval_gt(const gmp_int& a, const T& b)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& a, const T& b)
eval_increment	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_increment(T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& val)
eval_integer_modulus	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_integer_modulus(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& x, Integer val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& x, Integer val)
eval_integer_modulus	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^inline Integer eval_integer_modulus(const Backend& x, Integer val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const Backend& x, Integer val)
eval_integer_modulus	/usr/include/boost/multiprecision/tommath.hpp	/^inline typename enable_if<is_signed<Integer>, Integer>::type eval_integer_modulus(const tommath_int& x, Integer val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& x, Integer val)
eval_integer_modulus	/usr/include/boost/multiprecision/tommath.hpp	/^inline typename enable_if<is_unsigned<Integer>, Integer>::type eval_integer_modulus(const tommath_int& x, Integer val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& x, Integer val)
eval_is_zero	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline bool eval_is_zero(const cpp_dec_float<Digits10, ExponentType, Allocator>& val) $/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& val)
eval_is_zero	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline bool eval_is_zero(const T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val)
eval_is_zero	/usr/include/boost/multiprecision/gmp.hpp	/^inline bool eval_is_zero(const gmp_int& val)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& val)
eval_is_zero	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline bool eval_is_zero(const rational_adapter<IntBackend>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const rational_adapter<IntBackend>& val)
eval_is_zero	/usr/include/boost/multiprecision/tommath.hpp	/^inline bool eval_is_zero(const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
eval_lcm	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_lcm(T& result, const Arithmetic& a, const T& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const Arithmetic& a, const T& b)
eval_lcm	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if<is_integral<Arithmetic> >::type eval_lcm(T& result, const T& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a, const Arithmetic& b)
eval_lcm	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_lcm(B& result, const B& a, const B& b);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
eval_lcm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^inline void eval_lcm(B& result, const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(B& result, const B& a, const B& b)
eval_lcm	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_lcm(gmp_int& result, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& result, const gmp_int& a, const gmp_int& b)
eval_lcm	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_lcm(tommath_int& result, const tommath_int& a, const tommath_int& b)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& a, const tommath_int& b)
eval_ldexp	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_ldexp(number_backend_float_architype& result, const number_backend_float_architype& arg, int exp)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg, int exp)
eval_ldexp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_ldexp(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ArgType e)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x, ArgType e)
eval_ldexp	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_ldexp();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
eval_ldexp	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_ldexp(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long e)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val, long e)
eval_ldexp	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_ldexp(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val, long e)
eval_left_shift	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_left_shift(T& result, const T& arg, const V val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg, const V val)
eval_left_shift	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_left_shift(gmp_int& t, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, UI i)
eval_left_shift	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_left_shift(gmp_int& t, const gmp_int& v, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& v, UI i)
eval_left_shift	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_left_shift(tommath_int& t, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, UI i)
eval_left_shift	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_left_shift(tommath_int& t, const tommath_int& v, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& v, UI i)
eval_log	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^void eval_log(T& result, const T& arg)$/;"	f	signature:(T& result, const T& arg)
eval_log10	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^void eval_log10(T& result, const T& arg)$/;"	f	signature:(T& result, const T& arg)
eval_lsb	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^   eval_lsb(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)$/;"	f	namespace:boost::multiprecision::backends	signature:(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a)
eval_lsb	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline unsigned eval_lsb(const T& val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const T& val)
eval_lsb	/usr/include/boost/multiprecision/tommath.hpp	/^inline unsigned eval_lsb(const tommath_int& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& val)
eval_lt	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool eval_lt(const B& a, const A& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const A& b)
eval_lt	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool eval_lt(const B& a, const B& b)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const B& a, const B& b)
eval_lt	/usr/include/boost/multiprecision/gmp.hpp	/^inline typename enable_if<is_arithmetic<T>, bool>::type eval_lt(const gmp_int& a, const T& b)$/;"	f	namespace:boost::multiprecision	signature:(const gmp_int& a, const T& b)
eval_modulus	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& o)
eval_modulus	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, const cpp_int_backend<MinBits3, MaxBits3, SignType3, Checked3, Allocator3>& b)
eval_modulus	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, limb_type b)
eval_modulus	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& a, signed_limb_type b)
eval_modulus	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& b)
eval_modulus	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, limb_type b)
eval_modulus	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^   eval_modulus($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, signed_limb_type b)
eval_modulus	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_modulus(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_modulus	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_modulus(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_modulus	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_modulus(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_modulus	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
eval_modulus	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
eval_modulus	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
eval_modulus	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
eval_modulus	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
eval_modulus	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_modulus(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
eval_modulus	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_modulus(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
eval_modulus	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_modulus(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
eval_modulus_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_modulus_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_modulus_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_modulus_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_modulus_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_modulus_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_modulus_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_modulus_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_modulus_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_modulus_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_modulus_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_modulus_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_multiply(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
eval_multiply	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_multiply(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
eval_multiply	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_multiply(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
eval_multiply	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_multiply(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
eval_multiply	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^   eval_multiply($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> const& a, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> const& b)
eval_multiply	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^   eval_multiply($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, double_limb_type a, double_limb_type b)
eval_multiply	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^   eval_multiply($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, signed_double_limb_type a, signed_double_limb_type b)
eval_multiply	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_multiply(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_multiply	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_multiply(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_multiply(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
eval_multiply	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
eval_multiply	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_multiply(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
eval_multiply	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline void eval_multiply(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)
eval_multiply	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_multiply(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
eval_multiply	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_multiply(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
eval_multiply	/usr/include/boost/multiprecision/tommath.hpp	/^void eval_multiply(tommath_int& t, const tommath_int& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
eval_multiply_add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply_add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
eval_multiply_add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply_add	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_add(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
eval_multiply_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply_add(gmp_int& t, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, const gmp_int& b)
eval_multiply_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply_add(gmp_int& t, const gmp_int& a, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, long i)
eval_multiply_add	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply_add(gmp_int& t, const gmp_int& a, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, unsigned long i)
eval_multiply_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_multiply_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_multiply_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_multiply_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_multiply_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value>::type eval_multiply_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_multiply_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_multiply_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_multiply_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_multiply_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply_subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply_subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename disable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
eval_multiply_subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_multiply_subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<!is_same<T, U>::value && is_same<T, V>::value>::type eval_multiply_subtract(T& t, const U& u, const V& v, const X& x)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v, const X& x)
eval_multiply_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply_subtract(gmp_int& t, const gmp_int& a, const gmp_int& b)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, const gmp_int& b)
eval_multiply_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply_subtract(gmp_int& t, const gmp_int& a, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, long i)
eval_multiply_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_multiply_subtract(gmp_int& t, const gmp_int& a, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& a, unsigned long i)
eval_pow	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^inline typename enable_if<is_arithmetic<A>, void>::type eval_pow(T& result, const A& x, const T& a)$/;"	f	signature:(T& result, const A& x, const T& a)
eval_pow	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^inline typename enable_if<is_floating_point<A>, void>::type eval_pow(T& result, const T& x, const A& a)$/;"	f	signature:(T& result, const T& x, const A& a)
eval_pow	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^inline typename enable_if<is_integral<U> >::type eval_pow(T& result, const T& t, const U& p)$/;"	f	signature:(T& result, const T& t, const U& p)
eval_pow	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^inline void eval_pow(T& result, const T& x, const T& a)$/;"	f	signature:(T& result, const T& x, const T& a)
eval_pow	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_pow(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& b, const mpfr_float_backend<Digits10, AllocateType>& e)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& b, const mpfr_float_backend<Digits10, AllocateType>& e)
eval_powm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_signed<Integer1> >::type eval_powm(Backend& result, const Backend& a, Integer1 b, Integer2 c)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend& result, const Backend& a, Integer1 b, Integer2 c)
eval_powm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_signed<Integer> >::type eval_powm(Backend& result, const Backend& a, Integer b, const Backend& c)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend& result, const Backend& a, Integer b, const Backend& c)
eval_powm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_unsigned<Integer1> >::type eval_powm(Backend& result, const Backend& a, Integer1 b, Integer2 c)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend& result, const Backend& a, Integer1 b, Integer2 c)
eval_powm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^typename enable_if<is_unsigned<Integer> >::type eval_powm(Backend& result, const Backend& a, Integer b, const Backend& c)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend& result, const Backend& a, Integer b, const Backend& c)
eval_powm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^void eval_powm(Backend& result, const Backend& a, const Backend& p, Integer c)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend& result, const Backend& a, const Backend& p, Integer c)
eval_powm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^void eval_powm(Backend& result, const Backend& a, const Backend& p, const Backend& c)$/;"	f	namespace:boost::multiprecision::detail	signature:(Backend& result, const Backend& a, const Backend& p, const Backend& c)
eval_powm	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_powm(tommath_int& result, const tommath_int& base, const tommath_int& p, const tommath_int& m)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& result, const tommath_int& base, const tommath_int& p, const tommath_int& m)
eval_qr	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^inline void eval_qr(const Backend& x, const Backend& y, Backend& q, Backend& r)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(const Backend& x, const Backend& y, Backend& q, Backend& r)
eval_qr	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_qr(const tommath_int& x, const tommath_int& y, $/;"	f	namespace:boost::multiprecision::backends	signature:(const tommath_int& x, const tommath_int& y, tommath_int& q, tommath_int& r)
eval_right_shift	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_right_shift(T& result, const T& arg, const V val)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& arg, const V val)
eval_right_shift	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_right_shift(gmp_int& t, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, UI i)
eval_right_shift	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_right_shift(gmp_int& t, const gmp_int& v, UI i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& v, UI i)
eval_right_shift	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_right_shift(tommath_int& t, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, UI i)
eval_right_shift	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_right_shift(tommath_int& t, const tommath_int& v, UI i)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& v, UI i)
eval_round	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_round(T& result, const T& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a)
eval_sin	/usr/include/boost/multiprecision/detail/functions/trig.hpp	/^void eval_sin(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_sinh	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^inline void eval_sinh(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_sqrt	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_sqrt(number_backend_float_architype& result, const number_backend_float_architype& arg)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& arg)
eval_sqrt	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_sqrt(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
eval_sqrt	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_sqrt();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
eval_sqrt	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_sqrt(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
eval_sqrt	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_sqrt(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
eval_subtract	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^inline void eval_subtract(number_backend_float_architype& result, const number_backend_float_architype& o)$/;"	f	namespace:boost::multiprecision::concepts	signature:(number_backend_float_architype& result, const number_backend_float_architype& o)
eval_subtract	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_subtract(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& o)
eval_subtract	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_subtract(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const unsigned long long& o)
eval_subtract	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_subtract(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)  $/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, long long o)
eval_subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   eval_subtract(T& result, V const& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, V const& v)
eval_subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_subtract(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^void eval_subtract(T& t, const U& u, const V& v);$/;"	p	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, const gmp_float<D3>& y)
eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, const gmp_float<D2>& x, long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, long y)
eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, const gmp_float<D2>& x, unsigned long y)
eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, long x, const gmp_float<D2>& y)
eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& a, unsigned long x, const gmp_float<D2>& y)
eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<D1>& result, const gmp_float<D2>& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<D1>& result, const gmp_float<D2>& o)
eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<digits10>& result, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, long i)
eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_float<digits10>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<digits10>& result, unsigned long i)
eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& o)
eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& p, const gmp_int& o)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, const gmp_int& o)
eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& p, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, long i)
eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, const gmp_int& p, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, const gmp_int& p, unsigned long i)
eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, long i)
eval_subtract	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_subtract(gmp_int& t, unsigned long i)$/;"	f	namespace:boost::multiprecision	signature:(gmp_int& t, unsigned long i)
eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, const mpfr_float_backend<D3>& y)
eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, long y)
eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, const mpfr_float_backend<D2, A2>& x, unsigned long y)
eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, long x, const mpfr_float_backend<D2, A2>& y)
eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& a, unsigned long x, const mpfr_float_backend<D2, A2>& y)
eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<D1, A1>& result, const mpfr_float_backend<D2, A2>& o)
eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<digits10, AllocationType>& result, long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, long i)
eval_subtract	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_subtract(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<digits10, AllocationType>& result, unsigned long i)
eval_subtract	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline void eval_subtract(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(rational_adapter<IntBackend>& result, const rational_adapter<IntBackend>& o)
eval_subtract	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_subtract(tommath_int& t, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& o)
eval_subtract	/usr/include/boost/multiprecision/tommath.hpp	/^inline void eval_subtract(tommath_int& t, const tommath_int& p, const tommath_int& o)$/;"	f	namespace:boost::multiprecision::backends	signature:(tommath_int& t, const tommath_int& p, const tommath_int& o)
eval_subtract_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && !is_convertible<U, T>::value>::type eval_subtract_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_subtract_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_convertible<U, T>::value>::type eval_subtract_default(T& t, const T& u, const U& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const U& v)
eval_subtract_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_signed_number<T>::value>::type eval_subtract_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_subtract_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename enable_if_c<is_convertible<U, number<T, et_on> >::value && is_unsigned_number<T>::value>::type eval_subtract_default(T& t, const U& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const T& v)
eval_subtract_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_subtract_default(T& t, const T& u, const T& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const T& u, const T& v)
eval_subtract_default	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_subtract_default(T& t, const U& u, const V& v)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& t, const U& u, const V& v)
eval_tan	/usr/include/boost/multiprecision/detail/functions/trig.hpp	/^void eval_tan(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_tanh	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^inline void eval_tanh(T& result, const T& x)$/;"	f	signature:(T& result, const T& x)
eval_trunc	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^inline void eval_trunc(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_dec_float<Digits10, ExponentType, Allocator>& result, const cpp_dec_float<Digits10, ExponentType, Allocator>& x)
eval_trunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline void eval_trunc(T& result, const T& a)$/;"	f	namespace:boost::multiprecision::default_ops	signature:(T& result, const T& a)
eval_trunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^typename enable_if_c<sizeof(T) == 0>::type eval_trunc();$/;"	p	namespace:boost::multiprecision::default_ops	signature:()
eval_trunc	/usr/include/boost/multiprecision/gmp.hpp	/^inline void eval_trunc(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)$/;"	f	namespace:boost::multiprecision	signature:(gmp_float<Digits10>& result, const gmp_float<Digits10>& val)
eval_trunc	/usr/include/boost/multiprecision/mpfr.hpp	/^inline void eval_trunc(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)$/;"	f	namespace:boost::multiprecision::backends	signature:(mpfr_float_backend<Digits10, AllocateType>& result, const mpfr_float_backend<Digits10, AllocateType>& val)
exp	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   ExponentType    exp;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
exponent_type	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef int                                  exponent_type;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
exponent_type	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef ExponentType                   exponent_type;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
exponent_type	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef long                                      exponent_type;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
exponent_type	/usr/include/boost/multiprecision/mpfr.hpp	/^   typedef long                                           exponent_type;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   explicit expression(const Arg1& a) : arg(a) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a)
expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   expression(const Arg1& a1, const Arg2& a2) : arg1(a1), arg2(a2) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a1, const Arg2& a2)
expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   expression(const Arg1& a1, const Arg2& a2, const Arg3& a3) : arg1(a1), arg2(a2), arg3(a3) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a1, const Arg2& a2, const Arg3& a3)
expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   expression(const Arg1& a1, const Arg2& a2, const Arg3& a3, const Arg4& a4) : arg1(a1), arg2(a2), arg3(a3), arg4(a4) {}$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:(const Arg1& a1, const Arg2& a2, const Arg3& a3, const Arg4& a4)
expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression$/;"	s	namespace:boost::multiprecision::detail
expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression<tag, Arg1, Arg2, Arg3, void>$/;"	s	namespace:boost::multiprecision::detail
expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression<tag, Arg1, Arg2, void, void>$/;"	s	namespace:boost::multiprecision::detail
expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression<tag, Arg1, void, void, void>$/;"	s	namespace:boost::multiprecision::detail
expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression<terminal, Arg1, void, void, void>$/;"	s	namespace:boost::multiprecision::detail
expression_storage	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression_storage$/;"	s	namespace:boost::multiprecision::detail
expression_storage	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression_storage<T*>$/;"	s	namespace:boost::multiprecision::detail
expression_storage	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression_storage<const T*>$/;"	s	namespace:boost::multiprecision::detail
expression_storage	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression_storage<expression<tag, A1, A2, A3, A4> >$/;"	s	namespace:boost::multiprecision::detail
expression_template_default	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct expression_template_default<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, void> >$/;"	s
expression_template_default	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct expression_template_default$/;"	s	namespace:boost::multiprecision
expression_template_default	/usr/include/boost/multiprecision/rational_adapter.hpp	/^struct expression_template_default<backends::rational_adapter<IntBackend> > : public expression_template_default<IntBackend> {};$/;"	s	namespace:boost::multiprecision	inherits:expression_template_default
expression_template_default::value	/usr/include/boost/multiprecision/cpp_int.hpp	/^   static const expression_template_option value = et_off;$/;"	m	struct:expression_template_default	access:public
expression_template_option	/usr/include/boost/multiprecision/detail/number_base.hpp	/^enum expression_template_option$/;"	g	namespace:boost::multiprecision
extract_double	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   double             extract_double            (void) const;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
extract_double	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^double cpp_dec_float<Digits10, ExponentType, Allocator>::extract_double(void) const$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
extract_integer_part	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float      extract_integer_part      (void) const  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
extract_integer_part	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator> cpp_dec_float<Digits10, ExponentType, Allocator>::extract_integer_part(void) const  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
extract_long_double	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   long double        extract_long_double       (void) const;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
extract_long_double	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^long double cpp_dec_float<Digits10, ExponentType, Allocator>::extract_long_double(void) const$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
extract_parts	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   void               extract_parts             (double& mantissa, ExponentType& exponent) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(double& mantissa, ExponentType& exponent) const
extract_parts	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^void cpp_dec_float<Digits10, ExponentType, Allocator>::extract_parts(double& mantissa, ExponentType& exponent) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(double& mantissa, ExponentType& exponent) const
extract_signed_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   signed long long   extract_signed_long_long  (void) const  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
extract_signed_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^signed long long cpp_dec_float<Digits10, ExponentType, Allocator>::extract_signed_long_long(void) const  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
extract_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   unsigned long long extract_unsigned_long_long(void) const  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
extract_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^unsigned long long cpp_dec_float<Digits10, ExponentType, Allocator>::extract_unsigned_long_long(void) const  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(void) const
find_lsb	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(limb_type mask, const Tag&)$/;"	f	namespace:boost::multiprecision::backends	signature:(limb_type mask, const Tag&)
find_lsb	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(limb_type mask, const mpl::int_<32>&)$/;"	f	namespace:boost::multiprecision::backends	signature:(limb_type mask, const mpl::int_<32>&)
find_lsb	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^BOOST_FORCEINLINE unsigned find_lsb(limb_type mask, const mpl::int_<64>&)$/;"	f	namespace:boost::multiprecision::backends	signature:(limb_type mask, const mpl::int_<64>&)
find_lsb	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^inline unsigned find_lsb(Unsigned mask, const Tag&)$/;"	f	namespace:boost::multiprecision::backends	signature:(Unsigned mask, const Tag&)
find_lsb_imp	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^BOOST_FORCEINLINE unsigned find_lsb_imp(limb_type mask, mpl::false_ const&)$/;"	f	namespace:boost::multiprecision::backends	signature:(limb_type mask, mpl::false_ const&)
find_lsb_imp	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^BOOST_FORCEINLINE unsigned find_lsb_imp(limb_type mask, mpl::true_ const&)$/;"	f	namespace:boost::multiprecision::backends	signature:(limb_type mask, mpl::true_ const&)
first	/usr/include/boost/multiprecision/cpp_int.hpp	/^      limb_type first;$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
float_types	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef mpl::list<long double>               float_types;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
float_types	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef mpl::list<long double>         float_types;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
float_types	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef mpl::list<double, long double>                 float_types;$/;"	t	struct:boost::multiprecision::gmp_int	access:public
float_types	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef mpl::list<double, long double>            float_types;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
float_types	/usr/include/boost/multiprecision/mpfr.hpp	/^   typedef mpl::list<double, long double>                 float_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
float_types	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef typename IntBackend::float_types     float_types;$/;"	t	struct:boost::multiprecision::backends::rational_adapter	access:public
float_types	/usr/include/boost/multiprecision/tommath.hpp	/^   typedef mpl::list<long double>                           float_types;$/;"	t	struct:boost::multiprecision::backends::tommath_int	access:public
format_float_string	/usr/include/boost/multiprecision/detail/number_base.hpp	/^void format_float_string(S& str, boost::intmax_t my_exp, boost::intmax_t digits, std::ios_base::fmtflags f, bool iszero)$/;"	f	namespace:boost::multiprecision::detail	signature:(S& str, boost::intmax_t my_exp, boost::intmax_t digits, std::ios_base::fmtflags f, bool iszero)
fpclass	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   fpclass_type    fpclass;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
fpclass_type	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   fpclass_type;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	typeref:enum:boost::multiprecision::backends::cpp_dec_float::enum_fpclass_type	access:private
from_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   void from_unsigned_long_long(const unsigned long long u) ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const unsigned long long u)
from_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^void cpp_dec_float<Digits10, ExponentType, Allocator>::from_unsigned_long_long(const unsigned long long u) $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const unsigned long long u)
function	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct function{};$/;"	s	namespace:boost::multiprecision::detail
generate	/usr/include/boost/multiprecision/random.hpp	/^    result_type generate(Engine& eng, boost::mpl::false_) const$/;"	f	class:boost::random::uniform_smallint	access:private	signature:(Engine& eng, boost::mpl::false_) const
generate	/usr/include/boost/multiprecision/random.hpp	/^    result_type generate(Engine& eng, boost::mpl::true_) const$/;"	f	class:boost::random::uniform_smallint	access:private	signature:(Engine& eng, boost::mpl::true_) const
generate	/usr/include/boost/multiprecision/random.hpp	/^    void generate(Iter first, Iter last)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(Iter first, Iter last)
generate_uniform_int	/usr/include/boost/multiprecision/random.hpp	/^   generate_uniform_int($/;"	f	namespace:boost::random::detail	signature:( Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value, boost::mpl::true_ )
generate_uniform_int	/usr/include/boost/multiprecision/random.hpp	/^   generate_uniform_int(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value)$/;"	f	namespace:boost::random::detail	signature:(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value)
generate_uniform_int	/usr/include/boost/multiprecision/random.hpp	/^   generate_uniform_int(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value);$/;"	p	namespace:boost::random::detail	signature:(Engine& eng, const boost::multiprecision::number<Backend, ExpressionTemplates>& min_value, const boost::multiprecision::number<Backend, ExpressionTemplates>& max_value)
generic_interconvert	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& \/*to_type*\/, const mpl::int_<number_kind_floating_point>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_floating_point>& )
generic_interconvert	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& \/*to_type*\/, const mpl::int_<number_kind_integer>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_integer>& )
generic_interconvert	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_floating_point>& \/*to_type*\/, const mpl::int_<number_kind_rational>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_floating_point>& , const mpl::int_<number_kind_rational>& )
generic_interconvert	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_integer>& \/*to_type*\/, const mpl::int_<number_kind_integer>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_integer>& , const mpl::int_<number_kind_integer>& )
generic_interconvert	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_rational>& \/*to_type*\/, const mpl::int_<number_kind_integer>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_rational>& , const mpl::int_<number_kind_integer>& )
generic_interconvert	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^void generic_interconvert(To& to, const From& from, const mpl::int_<number_kind_rational>& \/*to_type*\/, const mpl::int_<number_kind_rational>& \/*from_type*\/)$/;"	f	namespace:boost::multiprecision::detail	signature:(To& to, const From& from, const mpl::int_<number_kind_rational>& , const mpl::int_<number_kind_rational>& )
get_constant_e	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^const T& get_constant_e()$/;"	f	signature:()
get_constant_ln2	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^const T& get_constant_ln2()$/;"	f	signature:()
get_constant_log10	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^const T& get_constant_log10()$/;"	f	signature:()
get_constant_pi	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^const T& get_constant_pi()$/;"	f	signature:()
get_default_precision	/usr/include/boost/multiprecision/mpfr.hpp	/^inline long get_default_precision() { return 50; }$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
get_max	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::false_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::false_&)
get_max	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::false_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::true_&)
get_max	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::true_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::false_&)
get_max	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::true_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::true_&)
get_min	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::false_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::false_&)
get_min	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::false_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::true_&)
get_min	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::true_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::false_&)
get_min	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::true_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::true_&)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   explicit gmp_float(const gmp_float<D>& o, typename disable_if_c<D <= digits10>::type* = 0);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_float<D>& o, typename disable_if_c<D <= digits10>::type* = 0)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float()$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:()
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float()$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:()
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_float& o) : detail::gmp_float_imp<0>(o) {}$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float& o)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_float& o) : detail::gmp_float_imp<digits10>(o) {}$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_float& o)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_float& o, unsigned digits10)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float& o, unsigned digits10)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_float<D>& o)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float<D>& o)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_float<D>& o, typename enable_if_c<D <= digits10>::type* = 0);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_float<D>& o, typename enable_if_c<D <= digits10>::type* = 0)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_int& o);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_int& o)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const gmp_rational& o)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_rational& o)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const mpf_t val)$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const mpf_t val)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpf_t val)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const mpq_t val)$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const mpq_t val)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpq_t val)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const mpz_t val)$/;"	f	struct:boost::multiprecision::backends::gmp_float	access:public	signature:(const mpz_t val)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpz_t val)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_float<0>::gmp_float(const gmp_int& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_int& o)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_float<0>::gmp_float(const gmp_rational& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_rational& o)
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^struct gmp_float : public detail::gmp_float_imp<digits10>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::gmp_float_imp
gmp_float	/usr/include/boost/multiprecision/gmp.hpp	/^struct gmp_float<0> : public detail::gmp_float_imp<0>$/;"	s	namespace:boost::multiprecision	inherits:detail::gmp_float_imp
gmp_float_imp	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp(const gmp_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(const gmp_float_imp& o)
gmp_float_imp	/usr/include/boost/multiprecision/gmp.hpp	/^struct gmp_float_imp$/;"	s	namespace:boost::multiprecision::backends::detail
gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   explicit gmp_int(const gmp_float<Digits10>& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_float<Digits10>& o)
gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   explicit gmp_int(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_rational& o)
gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   explicit gmp_int(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpf_t val)
gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   explicit gmp_int(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpq_t val)
gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int()$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:()
gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int(const gmp_int& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_int& o)
gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpz_t val)
gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_int::gmp_int(const gmp_rational& o)$/;"	f	class:boost::gmp_int	signature:(const gmp_rational& o)
gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^struct gmp_int$/;"	s	namespace:boost::multiprecision
half	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& half()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
has_denorm	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR std::float_denorm_style has_denorm        = std::denorm_absent;$/;"	m	class:std::numeric_limits	access:public
has_denorm	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST float_denorm_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_denorm;$/;"	m	class:std::numeric_limits
has_denorm	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR float_denorm_style has_denorm = denorm_absent;$/;"	m	class:std::numeric_limits	access:public
has_denorm	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST float_denorm_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_denorm;$/;"	m	class:std::numeric_limits
has_denorm	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR float_denorm_style has_denorm = denorm_absent;$/;"	m	class:std::numeric_limits	access:public
has_denorm	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST float_denorm_style numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_denorm;$/;"	m	class:std::numeric_limits
has_denorm_loss	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_denorm_loss   = false;$/;"	m	class:std::numeric_limits	access:public
has_denorm_loss	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_denorm_loss;$/;"	m	class:std::numeric_limits
has_denorm_loss	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_denorm_loss = false;$/;"	m	class:std::numeric_limits	access:public
has_denorm_loss	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_denorm_loss;$/;"	m	class:std::numeric_limits
has_denorm_loss	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_denorm_loss = false;$/;"	m	class:std::numeric_limits	access:public
has_denorm_loss	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_denorm_loss;$/;"	m	class:std::numeric_limits
has_enough_bits	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^struct has_enough_bits$/;"	s	namespace:boost::multiprecision::default_ops
has_enough_bits	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct has_enough_bits$/;"	s	namespace:boost::multiprecision::detail
has_generic_interconversion	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^struct has_generic_interconversion$/;"	s	namespace:boost::multiprecision::detail
has_infinity	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_infinity      = true;$/;"	m	class:std::numeric_limits	access:public
has_infinity	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_infinity;$/;"	m	class:std::numeric_limits
has_infinity	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_infinity = false;$/;"	m	class:std::numeric_limits	access:public
has_infinity	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_infinity;$/;"	m	class:std::numeric_limits
has_infinity	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_infinity = false;$/;"	m	class:std::numeric_limits	access:public
has_infinity	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_infinity;$/;"	m	class:std::numeric_limits
has_quiet_NaN	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_quiet_NaN     = true;$/;"	m	class:std::numeric_limits	access:public
has_quiet_NaN	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_quiet_NaN;$/;"	m	class:std::numeric_limits
has_quiet_NaN	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_quiet_NaN = false;$/;"	m	class:std::numeric_limits	access:public
has_quiet_NaN	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_quiet_NaN;$/;"	m	class:std::numeric_limits
has_quiet_NaN	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_quiet_NaN = false;$/;"	m	class:std::numeric_limits	access:public
has_quiet_NaN	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_quiet_NaN;$/;"	m	class:std::numeric_limits
has_signaling_NaN	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_signaling_NaN = false;$/;"	m	class:std::numeric_limits	access:public
has_signaling_NaN	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_signaling_NaN;$/;"	m	class:std::numeric_limits
has_signaling_NaN	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_signaling_NaN = false;$/;"	m	class:std::numeric_limits	access:public
has_signaling_NaN	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_signaling_NaN;$/;"	m	class:std::numeric_limits
has_signaling_NaN	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_signaling_NaN = false;$/;"	m	class:std::numeric_limits	access:public
has_signaling_NaN	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_signaling_NaN;$/;"	m	class:std::numeric_limits
hyp0F0	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^void hyp0F0(T& H0F0, const T& x)$/;"	f	signature:(T& H0F0, const T& x)
hyp0F1	/usr/include/boost/multiprecision/detail/functions/trig.hpp	/^void hyp0F1(T& result, const T& b, const T& x)$/;"	f	signature:(T& result, const T& b, const T& x)
hyp1F0	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^void hyp1F0(T& H1F0, const T& a, const T& x)$/;"	f	signature:(T& H1F0, const T& a, const T& x)
hyp2F1	/usr/include/boost/multiprecision/detail/functions/trig.hpp	/^void hyp2F1(T& result, const T& a, const T& b, const T& c, const T& x)$/;"	f	signature:(T& result, const T& a, const T& b, const T& c, const T& x)
if_c	/usr/include/boost/multiprecision/integer.hpp	/^   typedef typename mpl::if_c<$/;"	t	class:boost::multiprecision::detail::double_integer::mpl	access:public
independent_bits_engine	/usr/include/boost/multiprecision/random.hpp	/^    independent_bits_engine() { }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
independent_bits_engine	/usr/include/boost/multiprecision/random.hpp	/^    independent_bits_engine(It& first, It last) : _base(first, last) { }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(It& first, It last)
independent_bits_engine	/usr/include/boost/multiprecision/random.hpp	/^    independent_bits_engine(const base_type& base_arg) : _base(base_arg) {}$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(const base_type& base_arg)
independent_bits_engine	/usr/include/boost/multiprecision/random.hpp	/^class independent_bits_engine<Engine, w, boost::multiprecision::number<Backend, ExpressionTemplates> >$/;"	c	namespace:boost::random
inf	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& inf()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
infinity	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> infinity     (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::inf(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
infinity	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type infinity() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
infinity	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type infinity() { return base_type::infinity(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
infinity	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type infinity() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
init	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      static initializer init;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
init	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^typename cpp_dec_float<Digits10, ExponentType, Allocator>::initializer cpp_dec_float<Digits10, ExponentType, Allocator>::init;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float
init	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static const inititializer init;$/;"	m	class:std::numeric_limits	access:private
init	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^const typename numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::inititializer numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::init;$/;"	m	class:std::numeric_limits
init	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^   static const initializer init;$/;"	m	struct:constant_initializer	access:private
init	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^typename constant_initializer<T, F>::initializer const constant_initializer<T, F>::init;$/;"	m	class:constant_initializer::constant_initializer
initializer	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^         initializer()$/;"	f	struct:boost::multiprecision::backends::cpp_dec_float::initializer	access:public	signature:()
initializer	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      struct initializer$/;"	s	class:boost::multiprecision::backends::cpp_dec_float	access:private
initializer	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^      initializer()$/;"	f	struct:constant_initializer::initializer	access:public	signature:()
initializer	/usr/include/boost/multiprecision/detail/functions/constants.hpp	/^   struct initializer$/;"	s	struct:constant_initializer	access:private
inititializer	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^      inititializer()$/;"	f	struct:std::numeric_limits::inititializer	access:public	signature:()
inititializer	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   struct inititializer$/;"	s	class:std::numeric_limits	access:private
input_type	/usr/include/boost/multiprecision/random.hpp	/^    typedef boost::multiprecision::number<Backend, ExpressionTemplates> input_type;$/;"	t	class:boost::random::uniform_smallint	access:public
int1024_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<1024, 1024, signed_magnitude, unchecked, void> >  int1024_t;$/;"	t
int128_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<128, 128, signed_magnitude, unchecked, void> >    int128_t;$/;"	t
int256_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<256, 256, signed_magnitude, unchecked, void> >    int256_t;$/;"	t
int512_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<512, 512, signed_magnitude, unchecked, void> >    int512_t;$/;"	t
int_t_digits	/usr/include/boost/multiprecision/integer.hpp	/^   static const unsigned int_t_digits =$/;"	m	struct:boost::multiprecision::detail::double_integer	access:public
integer_gcd_reduce	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^inline double_limb_type integer_gcd_reduce(double_limb_type u, double_limb_type v)$/;"	f	namespace:boost::multiprecision::backends	signature:(double_limb_type u, double_limb_type v)
integer_gcd_reduce	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^inline limb_type integer_gcd_reduce(limb_type u, limb_type v)$/;"	f	namespace:boost::multiprecision::backends	signature:(limb_type u, limb_type v)
integer_modulus	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   integer_modulus(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, Integer val)$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x, Integer val)
integer_modulus	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   integer_modulus(const number<Backend, ExpressionTemplates>& x, Integer val)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x, Integer val)
integer_modulus	/usr/include/boost/multiprecision/integer.hpp	/^typename enable_if_c<is_integral<I1>::value && is_integral<I2>::value, I2>::type integer_modulus(const I1& x, I2 val)$/;"	f	namespace:boost::multiprecision	signature:(const I1& x, I2 val)
integer_traits	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^class integer_traits<multiprecision::double_limb_type>$/;"	c	namespace:boost	inherits:std::numeric_limits,detail::integer_traits_base
integer_traits	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^class integer_traits<multiprecision::signed_double_limb_type>$/;"	c	namespace:boost	inherits:std::numeric_limits,detail::integer_traits_base
integer_type	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef number<IntBackend>                integer_type;$/;"	t	struct:boost::multiprecision::backends::rational_adapter	access:public
internal_limb_count	/usr/include/boost/multiprecision/cpp_int.hpp	/^const unsigned cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::internal_limb_count;$/;"	m	class:boost::multiprecision::cpp_int_base
iround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int iround(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
iround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int iround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
iround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int iround(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
iround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int iround(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
is_bounded	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_bounded        = true;$/;"	m	class:std::numeric_limits	access:public
is_bounded	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_bounded;$/;"	m	class:std::numeric_limits
is_bounded	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_bounded = boost::multiprecision::backends::is_fixed_precision<backend_type>::value;$/;"	m	class:std::numeric_limits	access:public
is_bounded	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_bounded;$/;"	m	class:std::numeric_limits
is_bounded	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_bounded = false;$/;"	m	class:std::numeric_limits	access:public
is_bounded	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_bounded;$/;"	m	class:std::numeric_limits
is_compatible_arithmetic_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_compatible_arithmetic_type$/;"	s	namespace:boost::multiprecision	inherits:mpl::bool_
is_exact	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_exact          = false;$/;"	m	class:std::numeric_limits	access:public
is_exact	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_exact;$/;"	m	class:std::numeric_limits
is_exact	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_exact = true;$/;"	m	class:std::numeric_limits	access:public
is_exact	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_exact;$/;"	m	class:std::numeric_limits
is_exact	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_exact = true;$/;"	m	class:std::numeric_limits	access:public
is_exact	/usr/include/boost/multiprecision/rational_adapter.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adapter<IntBackend>, ExpressionTemplates> >::is_exact;$/;"	m	class:std::numeric_limits
is_exact	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_exact = true;$/;"	m	class:std::numeric_limits	access:public
is_exact	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_exact;$/;"	m	class:std::numeric_limits
is_explicitly_convertible	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^struct is_explicitly_convertible<cpp_dec_float<D1, E1, A1>, cpp_dec_float<D2, E2, A2> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::true_
is_explicitly_convertible	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_explicitly_convertible<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> > : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
is_explicitly_convertible	/usr/include/boost/multiprecision/gmp.hpp	/^struct is_explicitly_convertible<canonical<mpf_t, gmp_int>::type, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
is_explicitly_convertible	/usr/include/boost/multiprecision/gmp.hpp	/^struct is_explicitly_convertible<canonical<mpq_t, gmp_int>::type, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
is_explicitly_convertible	/usr/include/boost/multiprecision/gmp.hpp	/^struct is_explicitly_convertible<gmp_float<D1>, gmp_float<D2> > : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
is_explicitly_convertible	/usr/include/boost/multiprecision/gmp.hpp	/^struct is_explicitly_convertible<gmp_float<Digits10>, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
is_explicitly_convertible	/usr/include/boost/multiprecision/gmp.hpp	/^struct is_explicitly_convertible<gmp_rational, gmp_int> : public mpl::true_ {};$/;"	s	namespace:detail	inherits:mpl::true_
is_explicitly_convertible	/usr/include/boost/multiprecision/rational_adapter.hpp	/^struct is_explicitly_convertible<U, rational_adapter<IntBackend> > : public is_explicitly_convertible<U, IntBackend> {};$/;"	s	namespace:boost::multiprecision::detail	inherits:is_explicitly_convertible
is_explicitly_convertible	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^struct is_explicitly_convertible : public is_explicitly_convertible_imp<From, To>::type$/;"	s	namespace:boost::multiprecision::detail	inherits:is_explicitly_convertible_imp::type
is_explicitly_convertible_imp	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^struct is_explicitly_convertible_imp$/;"	s	namespace:boost::multiprecision::detail
is_fixed_precision	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_fixed_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends	inherits:mpl::bool_
is_iec559	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_iec559         = false;$/;"	m	class:std::numeric_limits	access:public
is_iec559	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_iec559;$/;"	m	class:std::numeric_limits
is_iec559	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_iec559 = false;$/;"	m	class:std::numeric_limits	access:public
is_iec559	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_iec559;$/;"	m	class:std::numeric_limits
is_iec559	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_iec559 = false;$/;"	m	class:std::numeric_limits	access:public
is_iec559	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_iec559;$/;"	m	class:std::numeric_limits
is_implicit_cpp_int_conversion	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_implicit_cpp_int_conversion<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >$/;"	s	namespace:boost::multiprecision::backends
is_integer	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_integer        = false;$/;"	m	class:std::numeric_limits	access:public
is_integer	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_integer;$/;"	m	class:std::numeric_limits
is_integer	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_integer = true;$/;"	m	class:std::numeric_limits	access:public
is_integer	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_integer;$/;"	m	class:std::numeric_limits
is_integer	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_integer = false;$/;"	m	class:std::numeric_limits	access:public
is_integer	/usr/include/boost/multiprecision/rational_adapter.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adapter<IntBackend>, ExpressionTemplates> >::is_integer;$/;"	m	class:std::numeric_limits
is_integer	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_integer = true;$/;"	m	class:std::numeric_limits	access:public
is_integer	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_integer;$/;"	m	class:std::numeric_limits
is_lossy_conversion	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^struct is_lossy_conversion$/;"	s	namespace:boost::multiprecision::detail
is_modulo	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_modulo         = false;$/;"	m	class:std::numeric_limits	access:public
is_modulo	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_modulo;$/;"	m	class:std::numeric_limits
is_modulo	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_modulo = (boost::multiprecision::backends::is_fixed_precision<backend_type>::value && (Checked == boost::multiprecision::unchecked));$/;"	m	class:std::numeric_limits	access:public
is_modulo	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_modulo;$/;"	m	class:std::numeric_limits
is_modulo	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_modulo = false;$/;"	m	class:std::numeric_limits	access:public
is_modulo	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_modulo;$/;"	m	class:std::numeric_limits
is_non_throwing_cpp_int	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_non_throwing_cpp_int : public mpl::false_{};$/;"	s	namespace:boost::multiprecision::backends	inherits:mpl::false_
is_non_throwing_cpp_int	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_non_throwing_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, unchecked, void> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision::backends	inherits:mpl::true_
is_number	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_number : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::false_
is_number	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_number<number<Backend, ExpressionTemplates> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::true_
is_number_expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_number_expression : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::false_
is_number_expression	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_number_expression<detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > : public mpl::true_ {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::true_
is_restricted_conversion	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^struct is_restricted_conversion$/;"	s	namespace:boost::multiprecision::detail
is_signed	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_signed         = true;$/;"	m	class:std::numeric_limits	access:public
is_signed	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_signed;$/;"	m	class:std::numeric_limits
is_signed	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_signed = boost::multiprecision::is_signed_number<backend_type>::value;$/;"	m	class:std::numeric_limits	access:public
is_signed	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_signed;$/;"	m	class:std::numeric_limits
is_signed	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_signed = true;$/;"	m	class:std::numeric_limits	access:public
is_signed	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_signed;$/;"	m	class:std::numeric_limits
is_signed_number	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_signed_number : public mpl::bool_<!is_unsigned_number<T>::value> {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::bool_
is_small_prime	/usr/include/boost/multiprecision/miller_rabin.hpp	/^inline bool is_small_prime(unsigned n)$/;"	f	namespace:boost::multiprecision::detail	signature:(unsigned n)
is_specialized	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_specialized    = true;$/;"	m	class:std::numeric_limits	access:public
is_specialized	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_specialized = true;$/;"	m	class:std::numeric_limits	access:public
is_specialized	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_specialized = true;$/;"	m	class:std::numeric_limits	access:public
is_trivial_cpp_int	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_trivial_cpp_int$/;"	s	namespace:boost::multiprecision::backends
is_trivial_cpp_int	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends
is_trivial_cpp_int	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_trivial_cpp_int<cpp_int_base<MinBits, MaxBits, SignType, Checked, Allocator, true> >$/;"	s	namespace:boost::multiprecision::backends
is_unsigned_number	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct is_unsigned_number<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision	inherits:mpl::bool_
is_unsigned_number	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_unsigned_number : public mpl::false_{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::false_
is_unsigned_number	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct is_unsigned_number<number<Backend, ExpressionTemplates> > : public is_unsigned_number<Backend> {};$/;"	s	namespace:boost::multiprecision	inherits:is_unsigned_number
is_valid_bitwise_op	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^void is_valid_bitwise_op($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& result, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& o, const mpl::int_<checked>&)
is_valid_bitwise_op	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^void is_valid_bitwise_op($/;"	f	namespace:boost::multiprecision::backends	signature:( cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>&, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& , const mpl::int_<unchecked>&)
is_valid_mixed_compare	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::false_
is_valid_mixed_compare	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<expression<tag, Arg1, Arg2, Arg3, Arg4>, number<B, ET> > $/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::bool_
is_valid_mixed_compare	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<number<B, ET>, Val> : public is_convertible<Val, number<B, ET> > {};$/;"	s	namespace:boost::multiprecision::detail	inherits:is_convertible
is_valid_mixed_compare	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<number<B, ET>, expression<tag, Arg1, Arg2, Arg3, Arg4> > $/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::bool_
is_valid_mixed_compare	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^struct is_valid_mixed_compare<number<B, ET>, number<B, ET> > : public mpl::false_ {};$/;"	s	namespace:boost::multiprecision::detail	inherits:mpl::false_
is_zero	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE bool is_zero()const$/;"	f	class:boost::multiprecision::number	access:public	signature:() const
isfinite	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool isfinite(void) const  { return (fpclass == cpp_dec_float_finite); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
isinf	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool isinf   (void) const  { return (fpclass == cpp_dec_float_inf); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
isint	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool isint  (void) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
isint	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^bool cpp_dec_float<Digits10, ExponentType, Allocator>::isint() const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:() const
isnan	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool isnan   (void) const  { return (fpclass == cpp_dec_float_NaN); }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
isneg	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool isneg  (void) const  { return neg; }$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
isone	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool isone  (void) const ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
isone	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^bool cpp_dec_float<Digits10, ExponentType, Allocator>::isone() const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:() const
iszero	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool iszero (void) const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void) const
iter_type	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   >::type iter_type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
iter_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   >::type iter_type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
itrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int itrunc(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
itrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int itrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
itrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int itrunc(const number<Backend, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& v)
itrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline int itrunc(const number<Backend, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& v, const Policy& pol)
la	/usr/include/boost/multiprecision/cpp_int.hpp	/^      limb_type la[internal_limb_count];$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
lanczos	/usr/include/boost/multiprecision/detail/big_lanczos.hpp	/^namespace lanczos{$/;"	n	namespace:boost::math
lanczos	/usr/include/boost/multiprecision/detail/big_lanczos.hpp	/^struct lanczos<multiprecision::number<Backend, ExpressionTemplates>, Policy>$/;"	s	namespace:boost::math::lanczos
largest_signed_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^struct largest_signed_type$/;"	s	namespace:boost::multiprecision::detail
largest_unsigned_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^struct largest_unsigned_type$/;"	s	namespace:boost::multiprecision::detail
ld	/usr/include/boost/multiprecision/cpp_int.hpp	/^      limb_data ld;$/;"	m	union:boost::multiprecision::backends::cpp_int_base::data_type	access:public
left	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   left_type left()const { return left_type(arg); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
left	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   left_type left()const { return left_type(arg1); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
left_depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned left_depth = left_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
left_max_depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned left_max_depth = left_depth > left_middle_depth ? left_depth : left_middle_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
left_middle	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   left_middle_type left_middle()const { return left_middle_type(arg2); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
left_middle_depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned left_middle_depth = left_middle_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
left_middle_result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename left_middle_type::result_type left_middle_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
left_middle_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg2>::type left_middle_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
left_result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename left_type::result_type left_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
left_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg1>::type left_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
limb_bits	/usr/include/boost/multiprecision/cpp_int.hpp	/^const unsigned cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::limb_bits;$/;"	m	class:boost::multiprecision::cpp_int_base
limb_count	/usr/include/boost/multiprecision/mpfr.hpp	/^   static const unsigned limb_count = mpfr_custom_get_size(digits2) \/ sizeof(mp_limb_t);$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
limb_data	/usr/include/boost/multiprecision/cpp_int.hpp	/^   struct limb_data$/;"	s	struct:boost::multiprecision::backends::cpp_int_base	access:private
limb_pointer	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef limb_type*                      limb_pointer;$/;"	t	struct:boost::multiprecision::cpp_int_base	access:public
limb_pointer	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef typename allocator_type::pointer                      limb_pointer;$/;"	t	struct:boost::multiprecision::backends::cpp_int_base	access:public
limb_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^typedef detail::largest_unsigned_type<64>::type limb_type;$/;"	t	namespace:boost::multiprecision
limbs	/usr/include/boost/multiprecision/cpp_int.hpp	/^      std::copy(other.limbs(), other.limbs() + (std::min)(other.size(), this->size()), this->limbs());$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:()
list_type	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   >::type list_type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
llround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long llround(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
llround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long llround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
llround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long llround(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
llround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long llround(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
lltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
lltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
lltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
lltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long long lltrunc(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
long_double_max	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_double_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
long_double_min	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_double_min()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
long_long_max	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_long_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
long_long_min	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& long_long_min()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
lowest	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> lowest       (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::zero(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
lowest	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type lowest() { return (min)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
lowest	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type lowest() { return -(max)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
lowest	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type lowest() { return (min)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
lround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long lround(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
lround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long lround(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
lround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long lround(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
lround	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long lround(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
lsb	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   lsb(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x)$/;"	f	namespace:boost::multiprecision	signature:(const multiprecision::detail::expression<tag, A1, A2, A3, A4>& x)
lsb	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   lsb(const number<Backend, ExpressionTemplates>& x)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& x)
lsb	/usr/include/boost/multiprecision/integer.hpp	/^typename enable_if_c<is_integral<Integer>::value, unsigned>::type lsb(const Integer& val)$/;"	f	namespace:boost::multiprecision	signature:(const Integer& val)
ltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const detail::expression<tag, A1, A2, A3, A4>& v)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v)
ltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
ltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const number<T, ExpressionTemplates>& v)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v)
ltrunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline long ltrunc(const number<T, ExpressionTemplates>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy& pol)
m_backend	/usr/include/boost/multiprecision/number.hpp	/^   Backend m_backend;$/;"	m	class:boost::multiprecision::number	access:private
m_buffer	/usr/include/boost/multiprecision/mpfr.hpp	/^   mp_limb_t m_buffer[limb_count];$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:protected
m_data	/usr/include/boost/multiprecision/cpp_int.hpp	/^      limb_type          m_data[internal_limb_count];$/;"	m	union:boost::multiprecision::cpp_int_base::data_type	access:public
m_data	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base() BOOST_NOEXCEPT : m_data(), m_limbs(1), m_sign(false), m_internal(true) {}$/;"	p	namespace:boost::multiprecision::backends	signature:()
m_data	/usr/include/boost/multiprecision/cpp_int.hpp	/^   data_type   m_data;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
m_data	/usr/include/boost/multiprecision/gmp.hpp	/^   mpf_t m_data;$/;"	m	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:protected
m_data	/usr/include/boost/multiprecision/gmp.hpp	/^   mpz_t m_data;$/;"	m	struct:boost::multiprecision::gmp_int	access:protected
m_data	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_t m_data;$/;"	m	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:protected
m_data	/usr/include/boost/multiprecision/tommath.hpp	/^   ::mp_int m_data;$/;"	m	struct:boost::multiprecision::backends::tommath_int	access:protected
m_double_first_limb	/usr/include/boost/multiprecision/cpp_int.hpp	/^      double_limb_type   m_double_first_limb;$/;"	m	union:boost::multiprecision::cpp_int_base::data_type	access:public
m_first_limb	/usr/include/boost/multiprecision/cpp_int.hpp	/^      limb_type          m_first_limb;$/;"	m	union:boost::multiprecision::cpp_int_base::data_type	access:public
m_internal	/usr/include/boost/multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(1), m_sign(false), m_internal(true) { }$/;"	f	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(true)
m_internal	/usr/include/boost/multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(i > max_limb_value ? 2 : 1), m_sign(false), m_internal(true) { }$/;"	f	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(true)
m_internal	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base() BOOST_NOEXCEPT : m_data(), m_limbs(1), m_sign(false), m_internal(true) {}$/;"	f	namespace:boost::multiprecision::backends	signature:(true)
m_internal	/usr/include/boost/multiprecision/cpp_int.hpp	/^   bool        m_sign, m_internal;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
m_limbs	/usr/include/boost/multiprecision/cpp_int.hpp	/^   boost::uint16_t    m_limbs;$/;"	m	struct:boost::multiprecision::cpp_int_base	access:private
m_limbs	/usr/include/boost/multiprecision/cpp_int.hpp	/^   unsigned    m_limbs;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
m_sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(1), m_sign(false), m_internal(true) { }$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(false)
m_sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^      : m_data(i), m_limbs(i > max_limb_value ? 2 : 1), m_sign(false), m_internal(true) { }$/;"	p	struct:boost::multiprecision::backends::cpp_int_base	access:public	signature:(false)
m_sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^      : m_wrapper(i), m_limbs(1), m_sign(false) {}$/;"	f	struct:boost::multiprecision::cpp_int_base	access:public	signature:(false)
m_sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^      : m_wrapper(i), m_limbs(i > max_limb_value ? 2 : 1), m_sign(false) {}$/;"	f	struct:boost::multiprecision::cpp_int_base	access:public	signature:(false)
m_sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR cpp_int_base() BOOST_NOEXCEPT : m_data(), m_limbs(1), m_sign(false), m_internal(true) {}$/;"	p	namespace:boost::multiprecision::backends	signature:(false)
m_sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^   bool               m_sign;$/;"	m	struct:boost::multiprecision::cpp_int_base	access:private
m_sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^   bool        m_sign, m_internal;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:private
m_value	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   long double m_value;$/;"	m	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
m_value	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_type m_value;$/;"	m	struct:boost::multiprecision::backends::rational_adapter	access:private
m_wrapper	/usr/include/boost/multiprecision/cpp_int.hpp	/^   } m_wrapper;$/;"	m	struct:boost::multiprecision::cpp_int_base	typeref:union:boost::multiprecision::cpp_int_base::data_type	access:private
math	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace boost{ namespace math{$/;"	n	namespace:boost
math	/usr/include/boost/multiprecision/detail/big_lanczos.hpp	/^namespace boost{ namespace math{$/;"	n	namespace:boost
math	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^namespace math{$/;"	n	namespace:boost
math	/usr/include/boost/multiprecision/detail/number_base.hpp	/^namespace boost{ namespace math{ namespace tools{$/;"	n	namespace:boost
max	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> (max)        (void)  { return (boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::max)(); }$/;"	f	class:std::numeric_limits::boost::multiprecision	access:public	signature:(void)
max	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& (max)()$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
max	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type (max)() $/;"	f	class:std::numeric_limits	access:public	signature:()
max	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type (max)() { return (base_type::max)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
max	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type (max)() $/;"	f	class:std::numeric_limits	access:public	signature:()
max_block_10	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^static const limb_type max_block_10 = 1000000000000000000uLL;$/;"	m	namespace:boost::multiprecision
max_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     max_digits10      = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_total_digits10;$/;"	m	class:std::numeric_limits	access:public
max_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::max_digits10;$/;"	m	class:std::numeric_limits
max_digits10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int max_digits10 = digits10 + 2;$/;"	m	class:std::numeric_limits	access:public
max_digits10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::max_digits10;$/;"	m	class:std::numeric_limits
max_digits10	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int max_digits10 = digits10 + 2;$/;"	m	class:std::numeric_limits	access:public
max_digits10	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::max_digits10;$/;"	m	class:std::numeric_limits
max_exponent	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          max_exponent      = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp;      \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
max_exponent	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::max_exponent;$/;"	m	class:std::numeric_limits
max_exponent	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
max_exponent	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::max_exponent;$/;"	m	class:std::numeric_limits
max_exponent	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
max_exponent	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::max_exponent;$/;"	m	class:std::numeric_limits
max_exponent10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          max_exponent10    = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10;    \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
max_exponent10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::max_exponent10;$/;"	m	class:std::numeric_limits
max_exponent10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
max_exponent10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::max_exponent10;$/;"	m	class:std::numeric_limits
max_exponent10	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
max_exponent10	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::max_exponent10;$/;"	m	class:std::numeric_limits
max_limb_value	/usr/include/boost/multiprecision/cpp_int.hpp	/^const limb_type cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::max_limb_value;$/;"	m	class:boost::multiprecision::cpp_int_base
max_precision	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct max_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends
middle	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   middle_type middle()const { return middle_type(arg2); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
middle_depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned middle_depth = middle_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
middle_result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename middle_type::result_type middle_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
middle_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg2>::type middle_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
miller_rabin_test	/usr/include/boost/multiprecision/miller_rabin.hpp	/^   miller_rabin_test(const I& n, unsigned trials, Engine& gen)$/;"	f	namespace:boost::multiprecision	signature:(const I& n, unsigned trials, Engine& gen)
miller_rabin_test	/usr/include/boost/multiprecision/miller_rabin.hpp	/^   miller_rabin_test(const I& x, unsigned trials)$/;"	f	namespace:boost::multiprecision	signature:(const I& x, unsigned trials)
miller_rabin_test	/usr/include/boost/multiprecision/miller_rabin.hpp	/^bool miller_rabin_test(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials)
miller_rabin_test	/usr/include/boost/multiprecision/miller_rabin.hpp	/^bool miller_rabin_test(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials, Engine& gen)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4> & n, unsigned trials, Engine& gen)
min	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> (min)        (void)  { return (boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::min)(); }$/;"	f	class:std::numeric_limits::boost::multiprecision	access:public	signature:(void)
min	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& (min)()$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
min	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type (min)()$/;"	f	class:std::numeric_limits	access:public	signature:()
min	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type (min)() { return (base_type::min)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
min	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type (min)()$/;"	f	class:std::numeric_limits	access:public	signature:()
min_exponent	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          min_exponent      = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp;      \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
min_exponent	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::min_exponent;$/;"	m	class:std::numeric_limits
min_exponent	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
min_exponent	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::min_exponent;$/;"	m	class:std::numeric_limits
min_exponent	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
min_exponent	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::min_exponent;$/;"	m	class:std::numeric_limits
min_exponent10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          min_exponent10    = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10;    \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
min_exponent10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::min_exponent10;$/;"	m	class:std::numeric_limits
min_exponent10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
min_exponent10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::min_exponent10;$/;"	m	class:std::numeric_limits
min_exponent10	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
min_exponent10	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::min_exponent10;$/;"	m	class:std::numeric_limits
min_precision	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct min_precision<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >$/;"	s	namespace:boost::multiprecision::backends
minmax	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^inline void minmax(const T& a, const T& b, T& aa, T& bb)$/;"	f	namespace:boost::multiprecision	signature:(const T& a, const T& b, T& aa, T& bb)
minus	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct minus{};$/;"	s	namespace:boost::multiprecision::detail
modulus	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct modulus{};$/;"	s	namespace:boost::multiprecision::detail
modulus_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct modulus_immediates{};$/;"	s	namespace:boost::multiprecision::detail
mp_number_float_architype	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^typedef boost::multiprecision::number<number_backend_float_architype> mp_number_float_architype;$/;"	t	namespace:boost::multiprecision::concepts
mpf_float	/usr/include/boost/multiprecision/gmp.hpp	/^typedef number<gmp_float<0> >     mpf_float;$/;"	t
mpf_float_100	/usr/include/boost/multiprecision/gmp.hpp	/^typedef number<gmp_float<100> >   mpf_float_100;$/;"	t
mpf_float_1000	/usr/include/boost/multiprecision/gmp.hpp	/^typedef number<gmp_float<1000> >  mpf_float_1000;$/;"	t
mpf_float_50	/usr/include/boost/multiprecision/gmp.hpp	/^typedef number<gmp_float<50> >    mpf_float_50;$/;"	t
mpf_float_500	/usr/include/boost/multiprecision/gmp.hpp	/^typedef number<gmp_float<500> >   mpf_float_500;$/;"	t
mpf_init2	/usr/include/boost/multiprecision/gmp.hpp	/^      mpf_init2(this->m_data, multiprecision::detail::digits10_2_2(Digits10 ? Digits10 : this->get_default_precision()));$/;"	p	namespace:boost::multiprecision	signature:(this->m_data, multiprecision::detail::digits10_2_2(Digits10 ? Digits10 : this->get_default_precision()))
mpf_set	/usr/include/boost/multiprecision/gmp.hpp	/^   mpf_set(this->m_data, o.data());$/;"	p	namespace:boost::multiprecision	signature:(this->m_data, o.data())
mpfr_allocation_type	/usr/include/boost/multiprecision/mpfr.hpp	/^enum mpfr_allocation_type$/;"	g	namespace:boost::multiprecision
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   explicit mpfr_float_backend(const mpfr_float_backend<D, AT>& val, typename disable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D, AT>& val, typename disable_if_c<D <= digits10>::type* = 0)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend() : detail::mpfr_float_imp<0, allocate_dynamic>() {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:()
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend() : detail::mpfr_float_imp<digits10, AllocationType>() {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:()
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_float<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_float<D>& val, typename disable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val, typename disable_if_c<D <= digits10>::type* = 0)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_float<D>& val, typename enable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val, typename enable_if_c<D <= digits10>::type* = 0)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_int& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_int& val)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const gmp_rational& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_rational& val)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpf_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpf_t val)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend& o) : detail::mpfr_float_imp<0, allocate_dynamic>(o) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend& o) : detail::mpfr_float_imp<digits10, AllocationType>(o) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend& o, unsigned digits10)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o, unsigned digits10)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend<D, AT>& val, typename enable_if_c<D <= digits10>::type* = 0)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D, AT>& val, typename enable_if_c<D <= digits10>::type* = 0)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_float_backend<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D>& val)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpfr_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_t val)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpq_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpq_t val)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(const mpz_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpz_t val)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(mpfr_float_backend&& o) : detail::mpfr_float_imp<digits10, AllocationType>(static_cast<detail::mpfr_float_imp<digits10, AllocationType>&&>(o)) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(mpfr_float_backend&& o)
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^struct mpfr_float_backend : public detail::mpfr_float_imp<digits10, AllocationType>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::mpfr_float_imp
mpfr_float_backend	/usr/include/boost/multiprecision/mpfr.hpp	/^struct mpfr_float_backend<0, allocate_dynamic> : public detail::mpfr_float_imp<0, allocate_dynamic>$/;"	s	namespace:boost::multiprecision::backends	inherits:detail::mpfr_float_imp
mpfr_float_imp	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp()$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:()
mpfr_float_imp	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp(const mpfr_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(const mpfr_float_imp& o)
mpfr_float_imp	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp(unsigned prec)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(unsigned prec)
mpfr_float_imp	/usr/include/boost/multiprecision/mpfr.hpp	/^struct mpfr_float_imp<digits10, allocate_dynamic>$/;"	s	namespace:boost::multiprecision::backends::detail
mpfr_float_imp	/usr/include/boost/multiprecision/mpfr.hpp	/^struct mpfr_float_imp<digits10, allocate_stack>$/;"	s	namespace:boost::multiprecision::backends::detail
mpq_rational	/usr/include/boost/multiprecision/gmp.hpp	/^typedef number<gmp_rational >    mpq_rational;$/;"	t
mpz_int	/usr/include/boost/multiprecision/gmp.hpp	/^typedef number<gmp_int >         mpz_int;$/;"	t
mul_loop_n	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static boost::uint32_t mul_loop_n (boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
mul_loop_n	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^boost::uint32_t cpp_dec_float<Digits10, ExponentType, Allocator>::mul_loop_n(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::uint32_t* const u, boost::uint32_t n, const boost::int32_t p)
mul_loop_uv	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static boost::uint32_t mul_loop_uv(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)
mul_loop_uv	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^boost::uint32_t cpp_dec_float<Digits10, ExponentType, Allocator>::mul_loop_uv(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::uint32_t* const u, const boost::uint32_t* const v, const boost::int32_t p)
mul_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& mul_unsigned_long_long(const unsigned long long n);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
mul_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::mul_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const unsigned long long n)
multiplies	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct multiplies{};$/;"	s	namespace:boost::multiprecision::detail
multiply	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   multiply(number<B, ET>& result, const I& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, ET>& result, const I& a, const I& b)
multiply	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline number<B1, ET1>& multiply(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
multiply	/usr/include/boost/multiprecision/integer.hpp	/^   multiply(Integer& result, const I2& a, const I2& b)$/;"	f	namespace:boost::multiprecision	signature:(Integer& result, const I2& a, const I2& b)
multiply_add	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct multiply_add{};$/;"	s	namespace:boost::multiprecision::detail
multiply_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct multiply_immediates{};$/;"	s	namespace:boost::multiprecision::detail
multiply_subtract	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct multiply_subtract{};$/;"	s	namespace:boost::multiprecision::detail
multiprecision	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/cpp_int.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/cpp_int/add.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/cpp_int/bitwise.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{ namespace detail{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/cpp_int/comparison.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/cpp_int/divide.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/cpp_int/misc.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^namespace boost{ namespace multiprecision{ namespace default_ops{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/detail/digits.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/detail/generic_interconvert.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/detail/number_base.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/gmp.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/integer.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/miller_rabin.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/mpfr.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/number.hpp	/^namespace boost{ namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/rational_adapter.hpp	/^namespace multiprecision{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/tommath.hpp	/^namespace boost{ namespace multiprecision{ namespace backends{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
multiprecision	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^namespace boost{ namespace multiprecision{ namespace detail{$/;"	n	namespace:boost
nan	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& nan()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
neg	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool            neg;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
negate	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:()
negate	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   void negate()   $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
negate	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct negate{};$/;"	s	namespace:boost::multiprecision::detail
negate	/usr/include/boost/multiprecision/gmp.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:()
negate	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:()
negate	/usr/include/boost/multiprecision/tommath.hpp	/^   void negate()$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
new_size	/usr/include/boost/multiprecision/cpp_int.hpp	/^         new_size = max_limbs;$/;"	m	struct:boost::multiprecision::backends::cpp_int_base	access:public
noexcept	/usr/include/boost/multiprecision/number.hpp	/^         >::type* = 0) BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Other&>(std::declval<Other>()))))$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
noexcept	/usr/include/boost/multiprecision/number.hpp	/^      BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Backend&>(std::declval<Backend>())))) : m_backend(val.backend()) {}$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
noexcept	/usr/include/boost/multiprecision/number.hpp	/^      BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Other&>(std::declval<Other>()))))$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
noexcept	/usr/include/boost/multiprecision/number.hpp	/^      BOOST_NOEXCEPT_IF(noexcept(std::declval<Backend>() = static_cast<const Backend&>(std::declval<Backend>())))$/;"	p	class:boost::multiprecision::number	access:public	signature:(std::declval<Backend>(
noexcept	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number() BOOST_NOEXCEPT_IF(noexcept(Backend())) {}$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
noexcept	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const number& e) BOOST_NOEXCEPT_IF(noexcept(Backend(static_cast<const Backend&>(std::declval<Backend>())))) : m_backend(e.m_backend){}$/;"	f	class:boost::multiprecision::number	access:public	signature:(Backend(
number	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const V& v, typename enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename enable_if_c< is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && !detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value >::type* = 0)
number	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const number& e, unsigned digits10)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const number& e, unsigned digits10)
number	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE number(V v1, V v2, typename enable_if<mpl::or_<boost::is_arithmetic<V>, is_same<std::string, V>, is_convertible<V, const char*> > >::type* = 0)$/;"	f	class:boost::multiprecision::number	access:public	signature:(V v1, V v2, typename enable_if<mpl::or_<boost::is_arithmetic<V>, is_same<std::string, V>, is_convertible<V, const char*> > >::type* = 0)
number	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE number(const V& v, typename enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename enable_if_c< (boost::is_arithmetic<V>::value || is_same<std::string, V>::value || is_convertible<V, const char*>::value) && !is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && !detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value >::type* = 0)
number	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE number(const number<Other, ET>& v1, const number<Other, ET>& v2, typename enable_if<boost::is_convertible<Other, Backend> >::type* = 0)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const number<Other, ET>& v1, const number<Other, ET>& v2, typename enable_if<boost::is_convertible<Other, Backend> >::type* = 0)
number	/usr/include/boost/multiprecision/number.hpp	/^   explicit BOOST_MP_FORCEINLINE BOOST_CONSTEXPR number(const V& v, typename enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename enable_if_c< detail::is_explicitly_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && (detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value || !is_convertible<typename detail::canonical<V, Backend>::type, Backend>::value) >::type* = 0)
number	/usr/include/boost/multiprecision/number.hpp	/^   explicit BOOST_MP_FORCEINLINE number(const V& v, typename enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const V& v, typename enable_if_c< (boost::is_arithmetic<V>::value || is_same<std::string, V>::value || is_convertible<V, const char*>::value) && !detail::is_explicitly_convertible<typename detail::canonical<V, Backend>::type, Backend>::value && detail::is_restricted_conversion<typename detail::canonical<V, Backend>::type, Backend>::value >::type* = 0)
number	/usr/include/boost/multiprecision/number.hpp	/^   explicit number(const number<Other, ET>& val, typename enable_if_c<$/;"	f	class:boost::multiprecision::number	access:public	signature:(const number<Other, ET>& val, typename enable_if_c< (!detail::is_explicitly_convertible<Other, Backend>::value) >::type* = 0)
number	/usr/include/boost/multiprecision/number.hpp	/^class number$/;"	c	namespace:boost::multiprecision
number_backend_float_architype	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype()$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:()
number_backend_float_architype	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype(const number_backend_float_architype& o)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const number_backend_float_architype& o)
number_backend_float_architype	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^struct number_backend_float_architype$/;"	s	namespace:boost::multiprecision::concepts
number_category	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^struct number_category<concepts::number_backend_float_architype> : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^struct number_category<backends::cpp_dec_float<Digits10, ExponentType, Allocator> > : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	/usr/include/boost/multiprecision/cpp_int.hpp	/^struct number_category<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> > : public mpl::int_<number_kind_integer>{};$/;"	s	inherits:mpl::int_
number_category	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct number_category : public mpl::int_<std::numeric_limits<Num>::is_integer ? number_kind_integer : (std::numeric_limits<Num>::max_exponent ? number_kind_floating_point : number_kind_unknown)> {};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct number_category<detail::expression<tag, A1, A2, A3, A4> > : public number_category<typename detail::expression<tag, A1, A2, A3, A4>::result_type>{};$/;"	s	namespace:boost::multiprecision	inherits:number_category
number_category	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct number_category<number<Backend, ExpressionTemplates> > : public number_category<Backend>{};$/;"	s	namespace:boost::multiprecision	inherits:number_category
number_category	/usr/include/boost/multiprecision/gmp.hpp	/^struct number_category<backends::gmp_float<digits10> > : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	/usr/include/boost/multiprecision/gmp.hpp	/^struct number_category<backends::gmp_int> : public mpl::int_<number_kind_integer>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	/usr/include/boost/multiprecision/gmp.hpp	/^struct number_category<backends::gmp_rational> : public mpl::int_<number_kind_rational>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	/usr/include/boost/multiprecision/gmp.hpp	/^struct number_category<detail::canonical<mpf_t, gmp_float<0> >::type> : public mpl::int_<number_kind_floating_point>{};$/;"	s	inherits:mpl::int_
number_category	/usr/include/boost/multiprecision/gmp.hpp	/^struct number_category<detail::canonical<mpq_t, gmp_rational>::type> : public mpl::int_<number_kind_rational>{};$/;"	s	inherits:mpl::int_
number_category	/usr/include/boost/multiprecision/gmp.hpp	/^struct number_category<detail::canonical<mpz_t, gmp_int>::type> : public mpl::int_<number_kind_integer>{};$/;"	s	inherits:mpl::int_
number_category	/usr/include/boost/multiprecision/mpfr.hpp	/^struct number_category<backends::mpfr_float_backend<digits10, AllocationType> > : public mpl::int_<number_kind_floating_point>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	/usr/include/boost/multiprecision/rational_adapter.hpp	/^struct number_category<backends::rational_adapter<IntBackend> > : public mpl::int_<number_kind_rational>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category	/usr/include/boost/multiprecision/tommath.hpp	/^struct number_category<tommath_int> : public mpl::int_<number_kind_integer>{};$/;"	s	namespace:boost::multiprecision	inherits:mpl::int_
number_category_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^enum number_category_type$/;"	g	namespace:boost::multiprecision
number_kind_fixed_point	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   number_kind_fixed_point = 3$/;"	e	enum:boost::multiprecision::number_category_type
number_kind_floating_point	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   number_kind_floating_point = 1,$/;"	e	enum:boost::multiprecision::number_category_type
number_kind_integer	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   number_kind_integer = 0,$/;"	e	enum:boost::multiprecision::number_category_type
number_kind_rational	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   number_kind_rational = 2,$/;"	e	enum:boost::multiprecision::number_category_type
number_kind_unknown	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   number_kind_unknown = -1,$/;"	e	enum:boost::multiprecision::number_category_type
number_type	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::concepts::number_backend_float_architype, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
number_type	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   typedef boost::multiprecision::number<backend_type, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
number_type	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::rational_adapter<IntBackend> > number_type;$/;"	t	class:std::numeric_limits	access:private
number_type	/usr/include/boost/multiprecision/tommath.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
numerator	/usr/include/boost/multiprecision/gmp.hpp	/^inline number<gmp_int, ET> numerator(const number<gmp_rational, ET>& val)$/;"	f	signature:(const number<gmp_rational, ET>& val)
numerator	/usr/include/boost/multiprecision/number.hpp	/^inline multiprecision::number<T, ExpressionTemplates> numerator(const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a)
numerator	/usr/include/boost/multiprecision/rational_adapter.hpp	/^inline number<IntBackend, ET> numerator(const number<rational_adapter<IntBackend>, ET>& val)$/;"	f	namespace:boost::multiprecision	signature:(const number<rational_adapter<IntBackend>, ET>& val)
numeric	/usr/include/boost/multiprecision/number.hpp	/^namespace numeric { namespace ublas {$/;"	n	namespace:boost
numeric_limits	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::concepts::number_backend_float_architype, ExpressionTemplates> > : public std::numeric_limits<long double>$/;"	c	namespace:std	inherits:std::numeric_limits
numeric_limits	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   class numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >$/;"	c	namespace:std
numeric_limits	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >$/;"	c	namespace:std
numeric_limits	/usr/include/boost/multiprecision/rational_adapter.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adapter<IntBackend>, ExpressionTemplates> > : public std::numeric_limits<boost::multiprecision::number<IntBackend, ExpressionTemplates> >$/;"	c	namespace:std	inherits:std::numeric_limits
numeric_limits	/usr/include/boost/multiprecision/tommath.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >$/;"	c	namespace:std
one	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& one()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
operator !=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator != (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
operator !=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator != (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
operator !=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator != (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
operator !=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator != (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
operator !=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator != (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
operator !=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool operator != (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
operator !=	/usr/include/boost/multiprecision/number.hpp	/^typename enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator != (const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)
operator !=	/usr/include/boost/multiprecision/number.hpp	/^typename enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator != (const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)
operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator %	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator % (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator %	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator % (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator %	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator % (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator %	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator % (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator %	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator % (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator %	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator % (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator &	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator & (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator & (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator & (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator & (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator & (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator & (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator & (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator & (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator &	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator & (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
operator ()	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   void operator()(Backend& result, const Backend& arg)const$/;"	f	struct:boost::multiprecision::detail::abs_funct	access:public	signature:(Backend& result, const Backend& arg) const
operator ()	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   void operator()(T& result, const T& b, const U& p, const V& m)const$/;"	f	struct:boost::multiprecision::detail::powm_func	access:public	signature:(T& result, const T& b, const U& p, const V& m) const
operator ()	/usr/include/boost/multiprecision/random.hpp	/^    result_type operator()()$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
operator ()	/usr/include/boost/multiprecision/random.hpp	/^    result_type operator()(Engine& eng) const$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(Engine& eng) const
operator ()	/usr/include/boost/multiprecision/random.hpp	/^    result_type operator()(Engine& eng, const param_type& parm) const$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(Engine& eng, const param_type& parm) const
operator ()	/usr/include/boost/multiprecision/random.hpp	/^  result_type operator()(result_type const& x, result_type const& y) { return x - y; }$/;"	f	struct:boost::random::detail::subtract	access:public	signature:(result_type const& x, result_type const& y)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator *	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator * (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator * (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator * (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator * (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator * (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator *	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator * (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
operator *=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator*=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
operator *=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator*=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator + (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^inline const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& operator + (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v) { return v; }$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)
operator +	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^inline const number<B, ExpressionTemplates>& operator + (const number<B, ExpressionTemplates>& v) { return v; }$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ExpressionTemplates>& v)
operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator + (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator + (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator + (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator + (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator +	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator + (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
operator ++	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator++(void)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
operator +=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator+=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
operator +=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator+=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::multiply_immediates, Arg1, Arg2, Arg3, Arg4>& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator - (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^inline detail::expression<detail::negate, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > operator - (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v) $/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)
operator -	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^inline detail::expression<detail::negate, number<B, et_on> > operator - (const number<B, et_on>& v) $/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& v)
operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator - (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator - (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator - (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator - (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (const number<B, et_off>& v) $/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& v)
operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator - (number<B, et_off>&& v) $/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& v)
operator -	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE typename enable_if<is_signed_number<B>, number<B, et_off> >::type operator - (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
operator --	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator--(void)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(void)
operator -=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator-=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
operator -=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator-=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const V& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B, et_on>& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<detail::negate, number<B, et_on> >& a, const number<B2, ET>& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, ET>& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<detail::negate, Arg1, Arg2, Arg3, Arg4>& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, ET>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator /	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator \/ (const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B2, ET>& a, const detail::expression<detail::negate, number<B, et_on> >& b)
operator /	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator \/ (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator /	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator \/ (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator /	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator \/ (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator /	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator \/ (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator /	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator \/ (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator /=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator\/=(const cpp_dec_float& v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
operator /=	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator\/=(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const cpp_dec_float<Digits10, ExponentType, Allocator>& v)
operator <	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator < (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
operator <	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator < (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
operator <	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator < (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
operator <	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator < (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
operator <	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator < (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
operator <	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool operator < (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
operator <<	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator << (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)
operator <<	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator << (const number<B, et_on>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const I& b)
operator <<	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator << (const number<B, et_off>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const I& b)
operator <<	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator << (number<B, et_off>&& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const I& b)
operator <<	/usr/include/boost/multiprecision/number.hpp	/^inline std::ostream& operator << (std::ostream& os, const expression<tag, A1, A2, A3, A4>& r)$/;"	f	namespace:boost::multiprecision::detail	signature:(std::ostream& os, const expression<tag, A1, A2, A3, A4>& r)
operator <<	/usr/include/boost/multiprecision/number.hpp	/^inline std::ostream& operator << (std::ostream& os, const number<Backend, ExpressionTemplates>& r)$/;"	f	namespace:boost::multiprecision	signature:(std::ostream& os, const number<Backend, ExpressionTemplates>& r)
operator <=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator <= (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
operator <=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator <= (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
operator <=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator <= (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
operator <=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator <= (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
operator <=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator <= (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
operator <=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool operator <= (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
operator =	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (const char* s)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const char* s)
operator =	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (const number_backend_float_architype& o)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(const number_backend_float_architype& o)
operator =	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (long double d)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long double d)
operator =	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (long long i)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(long long i)
operator =	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   number_backend_float_architype& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(unsigned long long i)
operator =	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (const char* v)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const char* v)
operator =	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (const cpp_dec_float& v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float& v)
operator =	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (long double v)  ;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(long double v)
operator =	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (long long v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(long long v)
operator =	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator= (unsigned long long v)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(unsigned long long v)
operator =	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& operator=(const cpp_dec_float<D>& f)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const cpp_dec_float<D>& f)
operator =	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator>& cpp_dec_float<Digits10, ExponentType, Allocator>::operator = (long double a)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(long double a)
operator =	/usr/include/boost/multiprecision/cpp_int.hpp	/^      operator=(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other)$/;"	f	namespace:boost::multiprecision	signature:(const cpp_int_backend<MinBits2, MaxBits2, SignType2, Allocator2>& other)
operator =	/usr/include/boost/multiprecision/cpp_int.hpp	/^   BOOST_MP_FORCEINLINE cpp_int_backend& operator = (Arithmetic val)$/;"	f	namespace:boost::multiprecision	access:public	signature:(Arithmetic val)
operator =	/usr/include/boost/multiprecision/cpp_int.hpp	/^   cpp_int_backend& operator = (const char* s)$/;"	f	namespace:boost::multiprecision	access:public	signature:(const char* s)
operator =	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   terminal& operator = (R val) {  value = val;  }$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:(R val)
operator =	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   expression& operator=(const expression&);$/;"	p	struct:boost::multiprecision::detail::expression	access:private	signature:(const expression&)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const V& v)$/;"	f	namespace:boost::multiprecision::backends	signature:(const V& v)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const V& v)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const V& v)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_float& o)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_float<D>& o)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_float<D>& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_float<D>& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(const gmp_float<D>& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_int& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(const gmp_int& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_int& o);$/;"	p	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_int& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_rational& o);$/;"	p	namespace:boost::multiprecision::backends	signature:(const gmp_rational& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_float	access:public	signature:(const gmp_rational& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpf_t val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpf_t val)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpf_t val)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpq_t val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpq_t val)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpq_t val)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpz_t val)$/;"	f	namespace:boost::multiprecision::backends	signature:(const mpz_t val)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float& operator=(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_float	access:public	signature:(const mpz_t val)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(const char* s)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (const gmp_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(const gmp_float_imp& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (double d)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(double d)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (long double a)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(long double a)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(long i)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (long long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(long long i)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (unsigned long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(unsigned long i)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_float_imp& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(unsigned long long i)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (const char* s)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const char* s)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (const gmp_int& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_int& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (double d)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(double d)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (long double a)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(long double a)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(long i)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (long long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(long long i)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (unsigned long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(unsigned long i)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(unsigned long long i)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator=(const gmp_float<Digits10>& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_float<Digits10>& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator=(const gmp_rational& o);$/;"	p	struct:boost::multiprecision::gmp_int	access:public	signature:(const gmp_rational& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator=(const mpf_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpf_t val)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator=(const mpq_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpq_t val)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^   gmp_int& operator=(const mpz_t val)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(const mpz_t val)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_float<0>& gmp_float<0>::operator=(const gmp_int& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_int& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_float<0>& gmp_float<0>::operator=(const gmp_rational& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_rational& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_float<Digits10>& gmp_float<Digits10>::operator=(const gmp_int& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_int& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_float<Digits10>& gmp_float<Digits10>::operator=(const gmp_rational& o)$/;"	f	class:boost::gmp_float	signature:(const gmp_rational& o)
operator =	/usr/include/boost/multiprecision/gmp.hpp	/^inline gmp_int& gmp_int::operator=(const gmp_rational& o)$/;"	f	class:boost::gmp_int	signature:(const gmp_rational& o)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const V& v)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const V& v)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const gmp_float<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_float<D>& val)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const gmp_int& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_int& val)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const gmp_rational& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const gmp_rational& val)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpf_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpf_t val)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_float_backend& o)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend& o)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_float_backend<D, AT>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D, AT>& val)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_float_backend<D>& val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_float_backend<D>& val)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpfr_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpfr_t val)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpq_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpq_t val)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend& operator=(const mpz_t val)$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(const mpz_t val)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(const char* s)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (const mpfr_float_imp& o)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(const mpfr_float_imp& o)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (double d)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(double d)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (long double a)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(long double a)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(long i)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (long long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(long long i)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (unsigned long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(unsigned long i)
operator =	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_imp& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(unsigned long long i)
operator =	/usr/include/boost/multiprecision/number.hpp	/^   typename enable_if<is_convertible<typename detail::expression<tag, Arg1, Arg2, Arg3, Arg4>::result_type, self_type>, number&>::type operator=(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)$/;"	f	class:boost::multiprecision::number	access:public	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& e)
operator =	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter& operator = (const IntBackend& o)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const IntBackend& o)
operator =	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const char* s)
operator =	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter& operator = (const rational_adapter& o)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const rational_adapter& o)
operator =	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter& operator = (rational_adapter&& o)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(rational_adapter&& o)
operator =	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typename enable_if<is_floating_point<Float>, rational_adapter&>::type operator = (Float i)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(Float i)
operator =	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typename enable_if<is_integral<Int>, rational_adapter&>::type operator = (Int i)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(Int i)
operator =	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typename enable_if_c<(boost::multiprecision::detail::is_explicitly_convertible<U, IntBackend>::value && !is_arithmetic<U>::value), rational_adapter&>::type operator = (const U& u) $/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const U& u)
operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (boost::int32_t i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(boost::int32_t i)
operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (boost::uint32_t i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(boost::uint32_t i)
operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (const char* s)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const char* s)
operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (const tommath_int& o)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const tommath_int& o)
operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (long double a)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(long double a)
operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (long long i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(long long i)
operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (tommath_int&& o)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(tommath_int&& o)
operator =	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int& operator = (unsigned long long i)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(unsigned long long i)
operator ==	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator == (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
operator ==	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator == (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
operator ==	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator == (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
operator ==	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator == (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
operator ==	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator == (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
operator ==	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool operator == (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
operator ==	/usr/include/boost/multiprecision/number.hpp	/^inline bool operator == (const sparse_vector_element<V>& a, const ::boost::multiprecision::number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::numeric::ublas	signature:(const sparse_vector_element<V>& a, const ::boost::multiprecision::number<Backend, ExpressionTemplates>& b)
operator ==	/usr/include/boost/multiprecision/number.hpp	/^typename enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator == (const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)$/;"	f	namespace:boost	signature:(const Arithmetic& b, const rational<multiprecision::number<T, ExpressionTemplates> >& a)
operator ==	/usr/include/boost/multiprecision/number.hpp	/^typename enable_if<boost::is_arithmetic<Arithmetic>, bool>::type operator == (const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)$/;"	f	namespace:boost	signature:(const rational<multiprecision::number<T, ExpressionTemplates> >& a, const Arithmetic& b)
operator >	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator > (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
operator >	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator > (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
operator >	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
operator >	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator > (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
operator >	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator > (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
operator >	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool operator > (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
operator >=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator >= (const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const detail::expression<Tag, A1, A2, A3, A4>& b)
operator >=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator >= (const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const Arithmetic& a, const number<Backend, ExpressionTemplates>& b)
operator >=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator >= (const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const Arithmetic& b)
operator >=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator >= (const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<Tag, A1, A2, A3, A4>& a, const detail::expression<Tagb, A1b, A2b, A3b, A4b>& b)
operator >=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^   operator >= (const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const Arithmetic& b)
operator >=	/usr/include/boost/multiprecision/detail/number_compare.hpp	/^inline bool operator >= (const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& a, const number<Backend, ExpressionTemplates>& b)
operator >>	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator >> (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const I& b)
operator >>	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator >> (const number<B, et_on>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const I& b)
operator >>	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator >> (const number<B, et_off>& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const I& b)
operator >>	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator >> (number<B, et_off>&& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const I& b)
operator >>	/usr/include/boost/multiprecision/number.hpp	/^inline std::istream& operator >> (std::istream& is, number<Backend, ExpressionTemplates>& r)$/;"	f	namespace:boost::multiprecision	signature:(std::istream& is, number<Backend, ExpressionTemplates>& r)
operator >>	/usr/include/boost/multiprecision/number.hpp	/^inline std::istream& operator >> (std::istream& is, rational<multiprecision::number<Backend, ExpressionTemplates> >& r)$/;"	f	namespace:boost	signature:(std::istream& is, rational<multiprecision::number<Backend, ExpressionTemplates> >& r)
operator R	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   operator R()const {  return value;  }$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:() const
operator T	/usr/include/boost/multiprecision/number.hpp	/^   explicit operator T ()const$/;"	f	class:boost::multiprecision::number	access:public	signature:() const
operator T	/usr/include/boost/multiprecision/number.hpp	/^   explicit operator T()const$/;"	f	class:boost::multiprecision::number	access:public	signature:() const
operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator ^	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator^ (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator ^ (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator ^ (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator ^ (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator ^ (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator ^ (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator ^ (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator ^ (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator ^	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator ^ (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
operator bool	/usr/include/boost/multiprecision/number.hpp	/^   explicit operator bool()const$/;"	f	class:boost::multiprecision::number	access:public	signature:() const
operator unmentionable_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   operator unmentionable_type()const$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
operator unmentionable_type	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE operator unmentionable_type()const$/;"	f	class:boost::multiprecision::number	access:public	signature:() const
operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const V& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_on>& b)
operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const V& b)
operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const detail::expression<tag2, Arg1b, Arg2b, Arg3b, Arg4b>& b)
operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& a, const number<B, et_on>& b)
operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const number<B, et_on>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const V& b)
operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& b)
operator |	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^   operator| (const number<B, et_on>& a, const number<B, et_on>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& a, const number<B, et_on>& b)
operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator | (const V& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, const number<B, et_off>& b)
operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator | (const V& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const V& a, number<B, et_off>&& b)
operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator | (const number<B, et_off>& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const V& b)
operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^   operator | (number<B, et_off>&& a, const V& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const V& b)
operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator | (const number<B, et_off>& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, const number<B, et_off>& b)
operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator | (const number<B, et_off>& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& a, number<B, et_off>&& b)
operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator | (number<B, et_off>&& a, const number<B, et_off>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, const number<B, et_off>& b)
operator |	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator | (number<B, et_off>&& a, number<B, et_off>&& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& a, number<B, et_off>&& b)
operator ~	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^inline detail::expression<detail::bitwise_complement, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> > operator ~ (const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v) { return detail::expression<detail::bitwise_complement, detail::expression<tag, Arg1, Arg2, Arg3, Arg4> >(v); }$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, Arg1, Arg2, Arg3, Arg4>& v)
operator ~	/usr/include/boost/multiprecision/detail/et_ops.hpp	/^inline detail::expression<detail::complement_immediates, number<B, et_on> > operator ~ (const number<B, et_on>& v) { return detail::expression<detail::complement_immediates, number<B, et_on> >(v); }$/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_on>& v)
operator ~	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator ~ (const number<B, et_off>& v) $/;"	f	namespace:boost::multiprecision	signature:(const number<B, et_off>& v)
operator ~	/usr/include/boost/multiprecision/detail/no_et_ops.hpp	/^BOOST_MP_FORCEINLINE number<B, et_off> operator ~ (number<B, et_off>&& v) $/;"	f	namespace:boost::multiprecision	signature:(number<B, et_off>&& v)
order	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   ExponentType order()const $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:() const
param	/usr/include/boost/multiprecision/random.hpp	/^    param_type param() const { return param_type(_min, _max); }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:() const
param	/usr/include/boost/multiprecision/random.hpp	/^    void param(const param_type& parm)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(const param_type& parm)
param_type	/usr/include/boost/multiprecision/random.hpp	/^        param_type(result_type const& min_arg = 0, result_type const& max_arg = 9)$/;"	f	class:boost::random::uniform_smallint::param_type	access:public	signature:(result_type const& min_arg = 0, result_type const& max_arg = 9)
param_type	/usr/include/boost/multiprecision/random.hpp	/^    class param_type$/;"	c	class:boost::random::uniform_smallint	access:public
plus	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct plus{};$/;"	s	namespace:boost::multiprecision::detail
policies	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace policies{$/;"	n	namespace:boost::math
pow2	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static cpp_dec_float pow2(long long i);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(long long i)
pow2	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^cpp_dec_float<Digits10, ExponentType, Allocator> cpp_dec_float<Digits10, ExponentType, Allocator>::pow2(const long long p)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const long long p)
pow_imp	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^inline void pow_imp(T& result, const T& t, const U& p, const mpl::false_&)$/;"	f	namespace:detail	signature:(T& result, const T& t, const U& p, const mpl::false_&)
pow_imp	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^inline void pow_imp(T& result, const T& t, const U& p, const mpl::true_&)$/;"	f	namespace:detail	signature:(T& result, const T& t, const U& p, const mpl::true_&)
powm	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   powm(const T& b, const U& p, const V& mod)$/;"	f	namespace:boost::multiprecision	signature:(const T& b, const U& p, const V& mod)
powm_func	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^struct powm_func$/;"	s	namespace:boost::multiprecision::detail
prec_elem	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   boost::int32_t  prec_elem;$/;"	m	class:boost::multiprecision::backends::cpp_dec_float	access:private
precision	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   void precision(const boost::int32_t prec_digits) $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const boost::int32_t prec_digits)
precision	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^struct precision< boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates>, Policy>$/;"	s	namespace:boost::math::policies
precision	/usr/include/boost/multiprecision/number.hpp	/^   void precision(unsigned digits10)$/;"	f	class:boost::multiprecision::number	access:public	signature:(unsigned digits10)
precision_type	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef typename Policy::precision_type precision_type;$/;"	t	struct:boost::math::policies::precision	access:public
precision_type	/usr/include/boost/multiprecision/detail/big_lanczos.hpp	/^   typedef typename boost::math::policies::precision<multiprecision::number<Backend, ExpressionTemplates>, Policy>::type precision_type;$/;"	t	struct:boost::math::lanczos::lanczos	access:public
pred_type	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   typedef typename has_enough_bits<R, std::numeric_limits<R>::digits>::template type<mpl::_> pred_type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
pred_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename has_enough_bits<bits_of<Val>::value>::template type<mpl::_> pred_type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
proc	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static void proc(){}$/;"	f	struct:boost::multiprecision::detail::unmentionable	access:public	signature:()
promote_arg	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct promote_arg<boost::multiprecision::detail::expression<tag, A1, A2, A3, A4> >$/;"	s	namespace:boost::math::tools
quiet_NaN	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> quiet_NaN    (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::nan(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
quiet_NaN	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type quiet_NaN() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
quiet_NaN	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type quiet_NaN() { return base_type::quiet_NaN(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
quiet_NaN	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type quiet_NaN() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
radix	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     radix             = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_radix;$/;"	m	class:std::numeric_limits	access:public
radix	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::radix;$/;"	m	class:std::numeric_limits
radix	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int radix = 2;$/;"	m	class:std::numeric_limits	access:public
radix	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::radix;$/;"	m	class:std::numeric_limits
radix	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int radix = 2;$/;"	m	class:std::numeric_limits	access:public
radix	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::radix;$/;"	m	class:std::numeric_limits
raise_add_overflow	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline void raise_add_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
raise_div_overflow	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline void raise_div_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
raise_mul_overflow	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline void raise_mul_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
raise_overflow	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline void raise_overflow(std::string op)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(std::string op)
raise_subtract_overflow	/usr/include/boost/multiprecision/cpp_int/checked.hpp	/^inline void raise_subtract_overflow()$/;"	f	namespace:boost::multiprecision::backends::detail	signature:()
random	/usr/include/boost/multiprecision/random.hpp	/^namespace boost{ namespace random{ namespace detail{$/;"	n	namespace:boost
random	/usr/include/boost/multiprecision/random.hpp	/^namespace random{$/;"	n	namespace:boost
rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   explicit rational_adapter(const U& u, $/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const U& u, typename enable_if_c< boost::multiprecision::detail::is_explicitly_convertible<U, IntBackend>::value && !is_convertible<U, IntBackend>::value >::type* = 0)
rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter(){}$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:()
rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter(IntBackend&& o) : m_value(o) {}$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(IntBackend&& o)
rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter(const IntBackend& o) : m_value(o) {}$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const IntBackend& o)
rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter(const U& u, typename enable_if_c<is_convertible<U, IntBackend>::value>::type* = 0) $/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const U& u, typename enable_if_c<is_convertible<U, IntBackend>::value>::type* = 0)
rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter(const rational_adapter& o)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(const rational_adapter& o)
rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   rational_adapter(rational_adapter&& o) : m_value(o.m_value) {}$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(rational_adapter&& o)
rational_adapter	/usr/include/boost/multiprecision/rational_adapter.hpp	/^struct rational_adapter$/;"	s	namespace:boost::multiprecision::backends
rational_type	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef boost::rational<integer_type>        rational_type;$/;"	t	struct:boost::multiprecision::backends::rational_adapter	access:public
rd_string	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   bool rd_string(const char* const s);$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(const char* const s)
rd_string	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^bool cpp_dec_float<Digits10, ExponentType, Allocator>::rd_string(const char* const s)$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(const char* const s)
real_cast	/usr/include/boost/multiprecision/detail/number_base.hpp	/^inline R real_cast(const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>& val)$/;"	f	namespace:boost::math::tools	signature:(const boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>& val)
real_cast	/usr/include/boost/multiprecision/detail/number_base.hpp	/^inline R real_cast(const boost::multiprecision::number<B, ET>& val)$/;"	f	namespace:boost::math::tools	signature:(const boost::multiprecision::number<B, ET>& val)
rebind	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^struct rebind$/;"	s	namespace:boost::multiprecision::backends::detail
reset	/usr/include/boost/multiprecision/random.hpp	/^    void reset() { }$/;"	f	class:boost::random::uniform_smallint	access:public	signature:()
resize_for_carry	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^inline void resize_for_carry(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& \/*result*\/, unsigned \/*required*\/){}$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& , unsigned )
resize_for_carry	/usr/include/boost/multiprecision/cpp_int/multiply.hpp	/^inline void resize_for_carry(cpp_int_backend<MinBits1, MaxBits1, SignType1, checked, void>& result, unsigned required)$/;"	f	namespace:boost::multiprecision::backends	signature:(cpp_int_backend<MinBits1, MaxBits1, SignType1, checked, void>& result, unsigned required)
result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   >::type result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef Arg1 result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename combine_expression<left_result_type, right_result_type>::type result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename left_type::result_type result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
result_type	/usr/include/boost/multiprecision/random.hpp	/^    typedef boost::multiprecision::number<Backend, ExpressionTemplates> result_type;$/;"	t	class:boost::random::independent_bits_engine	access:public
result_type	/usr/include/boost/multiprecision/random.hpp	/^    typedef boost::multiprecision::number<Backend, ExpressionTemplates> result_type;$/;"	t	class:boost::random::uniform_smallint	access:public
result_type	/usr/include/boost/multiprecision/random.hpp	/^  typedef boost::multiprecision::number<Backend, ExpressionTemplates> result_type;$/;"	t	struct:boost::random::detail::subtract	access:public
right	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   right_type right()const { return right_type(arg2); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
right	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   right_type right()const { return right_type(arg3); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
right	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   right_type right()const { return right_type(arg4); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
right_depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned right_depth = right_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
right_max_depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned right_max_depth = right_depth > right_middle_depth ? right_depth : right_middle_depth;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
right_middle	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   right_middle_type right_middle()const { return right_middle_type(arg3); }$/;"	f	struct:boost::multiprecision::detail::expression	access:public	signature:() const
right_middle_depth	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned right_middle_depth = right_middle_type::depth + 1;$/;"	m	struct:boost::multiprecision::detail::expression	access:public
right_middle_result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename right_middle_type::result_type right_middle_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
right_middle_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg3>::type right_middle_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
right_result_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename right_type::result_type right_result_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
right_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg2>::type right_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
right_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg3>::type right_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
right_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename arg_type<Arg4>::type right_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
round	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline number<T, ExpressionTemplates> round(const number<T, ExpressionTemplates>& v, const Policy&)$/;"	f	namespace:boost::multiprecision	signature:(const number<T, ExpressionTemplates>& v, const Policy&)
round	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename detail::expression<tag, A1, A2, A3, A4>::result_type round(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
round_error	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> round_error  (void)  { return 0.5L; }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
round_error	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type round_error() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
round_error	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type round_error() { return epsilon() \/ 2; }$/;"	f	class:std::numeric_limits	access:public	signature:()
round_error	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type round_error() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
round_style	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR std::float_round_style  round_style       = std::round_to_nearest;$/;"	m	class:std::numeric_limits	access:public
round_style	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST float_round_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::round_style;$/;"	m	class:std::numeric_limits
round_style	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR float_round_style round_style = round_toward_zero;$/;"	m	class:std::numeric_limits	access:public
round_style	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST float_round_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::round_style;$/;"	m	class:std::numeric_limits
round_style	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR float_round_style round_style = round_toward_zero;$/;"	m	class:std::numeric_limits	access:public
round_style	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST float_round_style numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::round_style;$/;"	m	class:std::numeric_limits
seed	/usr/include/boost/multiprecision/random.hpp	/^    template<class It> void seed(It& first, It last)$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:(It& first, It last)
seed	/usr/include/boost/multiprecision/random.hpp	/^    void seed() { _base.seed(); }$/;"	f	class:boost::random::independent_bits_engine	access:public	signature:()
select_uniform_01	/usr/include/boost/multiprecision/random.hpp	/^struct select_uniform_01<boost::multiprecision::number<Backend, ExpressionTemplates> >$/;"	s	namespace:boost::random::detail
selector	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^   static type_traits::no_type selector(...);$/;"	p	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public	signature:(....)
selector	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^   static type_traits::yes_type selector(dummy_size<sizeof(static_cast<T1>(declval<S1>()))>*);$/;"	p	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public	signature:(dummy_size<sizeof(static_cast<T1>(declval<S1>()))>*)
self	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> self;$/;"	t	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
self_type	/usr/include/boost/multiprecision/number.hpp	/^   typedef number<Backend, ExpressionTemplates> self_type;$/;"	t	class:boost::multiprecision::number	access:private
shift_left	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct shift_left{};$/;"	s	namespace:boost::multiprecision::detail
shift_right	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct shift_right{};$/;"	s	namespace:boost::multiprecision::detail
sign	/usr/include/boost/multiprecision/cpp_int.hpp	/^      this->sign(other.sign());$/;"	p	struct:boost::multiprecision::cpp_int_base	access:public	signature:(other.sign())
sign	/usr/include/boost/multiprecision/number.hpp	/^   BOOST_MP_FORCEINLINE int sign()const$/;"	f	class:boost::multiprecision::number	access:public	signature:() const
sign_bit_mask	/usr/include/boost/multiprecision/cpp_int.hpp	/^const limb_type cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::sign_bit_mask;$/;"	m	class:boost::multiprecision::cpp_int_base
signaling_NaN	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> signaling_NaN(void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::zero(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
signaling_NaN	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type signaling_NaN() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
signaling_NaN	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type signaling_NaN() { return base_type::signaling_NaN(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
signaling_NaN	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type signaling_NaN() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
signed_double_limb_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^typedef boost::int128_type signed_double_limb_type;$/;"	t	namespace:boost::multiprecision
signed_limb_type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^typedef detail::largest_signed_type<64>::type signed_limb_type;$/;"	t	namespace:boost::multiprecision
signed_magnitude	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   signed_magnitude = 1,$/;"	e	enum:boost::multiprecision::cpp_integer_type
signed_packed	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   signed_packed = 3,$/;"	e	enum:boost::multiprecision::cpp_integer_type
signed_types	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef mpl::list<long long>                 signed_types;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
signed_types	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef mpl::list<long long>           signed_types;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
signed_types	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef mpl::list<long, long long>                     signed_types;$/;"	t	struct:boost::multiprecision::gmp_int	access:public
signed_types	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef mpl::list<long, long long>                 signed_types;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
signed_types	/usr/include/boost/multiprecision/mpfr.hpp	/^   typedef mpl::list<long, long long>                     signed_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
signed_types	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef typename IntBackend::signed_types    signed_types;$/;"	t	struct:boost::multiprecision::backends::rational_adapter	access:public
signed_types	/usr/include/boost/multiprecision/tommath.hpp	/^   typedef mpl::list<boost::int32_t, long long>             signed_types;$/;"	t	struct:boost::multiprecision::backends::tommath_int	access:public
sinc_pi	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x)
sinc_pi	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)
sinc_pi_imp	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   template <class T> T sinc_pi_imp(T);$/;"	p	namespace:boost::math::detail	signature:(T)
sinhc_pi	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinhc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x)
sinhc_pi	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline multiprecision::number<Backend, ExpressionTemplates> sinhc_pi(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)$/;"	f	namespace:boost::math	signature:(const multiprecision::number<Backend, ExpressionTemplates>& x, const Policy&)
sinhc_pi_imp	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   template <class T> T sinhc_pi_imp(T);$/;"	p	namespace:boost::math::detail	signature:(T)
sinhcosh	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^   void sinhcosh(const T& x, T* p_sinh, T* p_cosh)$/;"	f	namespace:detail	signature:(const T& x, T* p_sinh, T* p_cosh)
sizeof	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   BOOST_STATIC_ASSERT_MSG(sizeof(ExponentType) > 1, "ExponentType is too small.");$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:private	signature:(ExponentType)
small_sinh_series	/usr/include/boost/multiprecision/detail/functions/pow.hpp	/^   void small_sinh_series(T x, T& result)$/;"	f	namespace:detail	signature:(T x, T& result)
static_cast	/usr/include/boost/multiprecision/mpfr.hpp	/^   mpfr_float_backend(mpfr_float_backend&& o) BOOST_NOEXCEPT : detail::mpfr_float_imp<0, allocate_dynamic>(static_cast<detail::mpfr_float_imp<0, allocate_dynamic>&&>(o)) {}$/;"	f	struct:boost::multiprecision::backends::mpfr_float_backend	access:public	signature:(o)
std	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^namespace std{$/;"	n
std	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^namespace std$/;"	n
std	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^namespace std{$/;"	n
std	/usr/include/boost/multiprecision/rational_adapter.hpp	/^namespace std{$/;"	n
std	/usr/include/boost/multiprecision/tommath.hpp	/^namespace std{$/;"	n
std::detail	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^namespace detail{$/;"	n	namespace:std
std::detail::get_max	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::false_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::false_&)
std::detail::get_max	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::false_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::true_&)
std::detail::get_max	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::true_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::false_&)
std::detail::get_max	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_max(const boost::mpl::true_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::true_&)
std::detail::get_min	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::false_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::false_&)
std::detail::get_min	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::false_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::false_&, const boost::mpl::true_&)
std::detail::get_min	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::true_&, const boost::mpl::false_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::false_&)
std::detail::get_min	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   get_min(const boost::mpl::true_&, const boost::mpl::true_&)$/;"	f	namespace:std::detail	signature:(const boost::mpl::true_&, const boost::mpl::true_&)
std::numeric_limits	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::concepts::number_backend_float_architype, ExpressionTemplates> > : public std::numeric_limits<long double>$/;"	c	namespace:std	inherits:std::numeric_limits
std::numeric_limits	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   class numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >$/;"	c	namespace:std
std::numeric_limits	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >$/;"	c	namespace:std
std::numeric_limits	/usr/include/boost/multiprecision/rational_adapter.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adapter<IntBackend>, ExpressionTemplates> > : public std::numeric_limits<boost::multiprecision::number<IntBackend, ExpressionTemplates> >$/;"	c	namespace:std	inherits:std::numeric_limits
std::numeric_limits	/usr/include/boost/multiprecision/tommath.hpp	/^class numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >$/;"	c	namespace:std
std::numeric_limits::backend_type	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   typedef boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> backend_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::base_type	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef std::numeric_limits<long double> base_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::base_type	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef std::numeric_limits<boost::multiprecision::number<IntBackend> > base_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::boost::multiprecision::max	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> (max)        (void)  { return (boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::max)(); }$/;"	f	class:std::numeric_limits::boost::multiprecision	access:public	signature:(void)
std::numeric_limits::boost::multiprecision::min	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> (min)        (void)  { return (boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::min)(); }$/;"	f	class:std::numeric_limits::boost::multiprecision	access:public	signature:(void)
std::numeric_limits::denorm_min	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> denorm_min   (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::zero(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
std::numeric_limits::denorm_min	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type denorm_min() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::denorm_min	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type denorm_min() { return base_type::denorm_min(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::denorm_min	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type denorm_min() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::digits	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     digits            = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::digits;$/;"	m	class:std::numeric_limits
std::numeric_limits::digits	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int digits = boost::multiprecision::backends::max_precision<backend_type>::value == UINT_MAX ? INT_MAX : boost::multiprecision::backends::max_precision<backend_type>::value;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::digits;$/;"	m	class:std::numeric_limits
std::numeric_limits::digits	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int digits = INT_MAX;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::digits;$/;"	m	class:std::numeric_limits
std::numeric_limits::digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     digits10          = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_digits10;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::digits10;$/;"	m	class:std::numeric_limits
std::numeric_limits::digits10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int digits10 = (INT_MAX \/ 1000) * 301L;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::digits10;$/;"	m	class:std::numeric_limits
std::numeric_limits::digits10	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int digits10 = (INT_MAX \/ 1000) * 301L;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::digits10	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::digits10;$/;"	m	class:std::numeric_limits
std::numeric_limits::epsilon	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> epsilon      (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::eps(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
std::numeric_limits::epsilon	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type epsilon() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::epsilon	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type epsilon() { return base_type::epsilon(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::epsilon	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type epsilon() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::has_denorm	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR std::float_denorm_style has_denorm        = std::denorm_absent;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST float_denorm_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_denorm;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_denorm	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR float_denorm_style has_denorm = denorm_absent;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST float_denorm_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_denorm;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_denorm	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR float_denorm_style has_denorm = denorm_absent;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST float_denorm_style numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_denorm;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_denorm_loss	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_denorm_loss   = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm_loss	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_denorm_loss;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_denorm_loss	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_denorm_loss = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm_loss	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_denorm_loss;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_denorm_loss	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_denorm_loss = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_denorm_loss	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_denorm_loss;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_infinity	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_infinity      = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_infinity	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_infinity;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_infinity	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_infinity = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_infinity	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_infinity;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_infinity	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_infinity = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_infinity	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_infinity;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_quiet_NaN	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_quiet_NaN     = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_quiet_NaN	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_quiet_NaN;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_quiet_NaN	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_quiet_NaN = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_quiet_NaN	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_quiet_NaN;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_quiet_NaN	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_quiet_NaN = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_quiet_NaN	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_quiet_NaN;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_signaling_NaN	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    has_signaling_NaN = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_signaling_NaN	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::has_signaling_NaN;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_signaling_NaN	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_signaling_NaN = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_signaling_NaN	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::has_signaling_NaN;$/;"	m	class:std::numeric_limits
std::numeric_limits::has_signaling_NaN	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool has_signaling_NaN = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::has_signaling_NaN	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::has_signaling_NaN;$/;"	m	class:std::numeric_limits
std::numeric_limits::infinity	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> infinity     (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::inf(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
std::numeric_limits::infinity	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type infinity() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::infinity	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type infinity() { return base_type::infinity(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::infinity	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type infinity() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::init	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static const inititializer init;$/;"	m	class:std::numeric_limits	access:private
std::numeric_limits::init	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^const typename numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::inititializer numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates> >::init;$/;"	m	class:std::numeric_limits
std::numeric_limits::inititializer	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   struct inititializer$/;"	s	class:std::numeric_limits	access:private
std::numeric_limits::inititializer::do_nothing	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^      void do_nothing()const{}$/;"	f	struct:std::numeric_limits::inititializer	access:public	signature:() const
std::numeric_limits::inititializer::inititializer	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^      inititializer()$/;"	f	struct:std::numeric_limits::inititializer	access:public	signature:()
std::numeric_limits::is_bounded	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_bounded        = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_bounded	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_bounded;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_bounded	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_bounded = boost::multiprecision::backends::is_fixed_precision<backend_type>::value;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_bounded	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_bounded;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_bounded	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_bounded = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_bounded	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_bounded;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_exact	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_exact          = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_exact	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_exact;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_exact	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_exact = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_exact	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_exact;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_exact	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_exact = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_exact	/usr/include/boost/multiprecision/rational_adapter.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adapter<IntBackend>, ExpressionTemplates> >::is_exact;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_exact	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_exact = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_exact	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_exact;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_iec559	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_iec559         = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_iec559	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_iec559;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_iec559	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_iec559 = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_iec559	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_iec559;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_iec559	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_iec559 = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_iec559	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_iec559;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_integer	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_integer        = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_integer	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_integer;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_integer	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_integer = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_integer	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_integer;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_integer	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_integer = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_integer	/usr/include/boost/multiprecision/rational_adapter.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::rational_adapter<IntBackend>, ExpressionTemplates> >::is_integer;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_integer	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_integer = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_integer	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_integer;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_modulo	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_modulo         = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_modulo	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_modulo;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_modulo	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_modulo = (boost::multiprecision::backends::is_fixed_precision<backend_type>::value && (Checked == boost::multiprecision::unchecked));$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_modulo	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_modulo;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_modulo	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_modulo = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_modulo	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_modulo;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_signed	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_signed         = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_signed	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::is_signed;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_signed	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_signed = boost::multiprecision::is_signed_number<backend_type>::value;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_signed	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::is_signed;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_signed	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_signed = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_signed	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::is_signed;$/;"	m	class:std::numeric_limits
std::numeric_limits::is_specialized	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    is_specialized    = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_specialized	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_specialized = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::is_specialized	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool is_specialized = true;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::lowest	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> lowest       (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::zero(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
std::numeric_limits::lowest	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type lowest() { return (min)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::lowest	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type lowest() { return -(max)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::lowest	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type lowest() { return (min)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::max	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type (max)() $/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::max	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type (max)() { return (base_type::max)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::max	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type (max)() $/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::max_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     max_digits10      = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_total_digits10;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_digits10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::max_digits10;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_digits10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int max_digits10 = digits10 + 2;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_digits10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::max_digits10;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_digits10	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int max_digits10 = digits10 + 2;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_digits10	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::max_digits10;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_exponent	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          max_exponent      = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp;      \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::max_exponent;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_exponent	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::max_exponent;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_exponent	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::max_exponent;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_exponent10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          max_exponent10    = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_max_exp10;    \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::max_exponent10;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_exponent10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::max_exponent10;$/;"	m	class:std::numeric_limits
std::numeric_limits::max_exponent10	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int max_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::max_exponent10	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::max_exponent10;$/;"	m	class:std::numeric_limits
std::numeric_limits::min	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type (min)()$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::min	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type (min)() { return (base_type::min)(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::min	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type (min)()$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::min_exponent	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          min_exponent      = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp;      \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::min_exponent;$/;"	m	class:std::numeric_limits
std::numeric_limits::min_exponent	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::min_exponent;$/;"	m	class:std::numeric_limits
std::numeric_limits::min_exponent	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::min_exponent;$/;"	m	class:std::numeric_limits
std::numeric_limits::min_exponent10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR ExponentType          min_exponent10    = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_min_exp10;    \/\/ Type differs from int.$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent10	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST ExponentType numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::min_exponent10;$/;"	m	class:std::numeric_limits
std::numeric_limits::min_exponent10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent10	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::min_exponent10;$/;"	m	class:std::numeric_limits
std::numeric_limits::min_exponent10	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int min_exponent10 = 0;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::min_exponent10	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::min_exponent10;$/;"	m	class:std::numeric_limits
std::numeric_limits::number_type	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::concepts::number_backend_float_architype, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::number_type	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   typedef boost::multiprecision::number<backend_type, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::number_type	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::rational_adapter<IntBackend> > number_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::number_type	/usr/include/boost/multiprecision/tommath.hpp	/^   typedef boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> number_type;$/;"	t	class:std::numeric_limits	access:private
std::numeric_limits::quiet_NaN	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> quiet_NaN    (void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::nan(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
std::numeric_limits::quiet_NaN	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type quiet_NaN() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::quiet_NaN	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type quiet_NaN() { return base_type::quiet_NaN(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::quiet_NaN	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type quiet_NaN() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::radix	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR int                     radix             = boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::cpp_dec_float_radix;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::radix	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::radix;$/;"	m	class:std::numeric_limits
std::numeric_limits::radix	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR int radix = 2;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::radix	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::radix;$/;"	m	class:std::numeric_limits
std::numeric_limits::radix	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR int radix = 2;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::radix	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST int numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::radix;$/;"	m	class:std::numeric_limits
std::numeric_limits::round_error	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> round_error  (void)  { return 0.5L; }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
std::numeric_limits::round_error	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type round_error() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::round_error	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type round_error() { return epsilon() \/ 2; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::round_error	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type round_error() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::round_style	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR std::float_round_style  round_style       = std::round_to_nearest;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::round_style	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST float_round_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::round_style;$/;"	m	class:std::numeric_limits
std::numeric_limits::round_style	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR float_round_style round_style = round_toward_zero;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::round_style	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST float_round_style numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::round_style;$/;"	m	class:std::numeric_limits
std::numeric_limits::round_style	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR float_round_style round_style = round_toward_zero;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::round_style	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST float_round_style numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::round_style;$/;"	m	class:std::numeric_limits
std::numeric_limits::signaling_NaN	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> signaling_NaN(void)  { return boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>::zero(); }$/;"	f	class:std::numeric_limits	access:public	signature:(void)
std::numeric_limits::signaling_NaN	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   static number_type signaling_NaN() { return 0; }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::signaling_NaN	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   BOOST_STATIC_CONSTEXPR number_type signaling_NaN() { return base_type::signaling_NaN(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::signaling_NaN	/usr/include/boost/multiprecision/tommath.hpp	/^   static number_type signaling_NaN() { return number_type(); }$/;"	f	class:std::numeric_limits	access:public	signature:()
std::numeric_limits::tinyness_before	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    tinyness_before   = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::tinyness_before	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::tinyness_before;$/;"	m	class:std::numeric_limits
std::numeric_limits::tinyness_before	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool tinyness_before = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::tinyness_before	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::tinyness_before;$/;"	m	class:std::numeric_limits
std::numeric_limits::tinyness_before	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool tinyness_before = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::tinyness_before	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::tinyness_before;$/;"	m	class:std::numeric_limits
std::numeric_limits::traps	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    traps             = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::traps	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::traps;$/;"	m	class:std::numeric_limits
std::numeric_limits::traps	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool traps = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::traps	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::traps;$/;"	m	class:std::numeric_limits
std::numeric_limits::traps	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool traps = false;$/;"	m	class:std::numeric_limits	access:public
std::numeric_limits::traps	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::traps;$/;"	m	class:std::numeric_limits
str	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
str	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   std::string str(boost::intmax_t digits, std::ios_base::fmtflags f)const;$/;"	p	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(boost::intmax_t digits, std::ios_base::fmtflags f) const
str	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^std::string cpp_dec_float<Digits10, ExponentType, Allocator>::str(boost::intmax_t number_of_digits, std::ios_base::fmtflags f) const$/;"	f	class:boost::multiprecision::backends::cpp_dec_float	signature:(boost::intmax_t number_of_digits, std::ios_base::fmtflags f) const
str	/usr/include/boost/multiprecision/cpp_int.hpp	/^   std::string str(std::streamsize \/*digits*\/, std::ios_base::fmtflags f)const$/;"	f	namespace:boost::multiprecision	access:public	signature:(std::streamsize , std::ios_base::fmtflags f) const
str	/usr/include/boost/multiprecision/gmp.hpp	/^   std::string str(std::streamsize \/*digits*\/, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(std::streamsize , std::ios_base::fmtflags f) const
str	/usr/include/boost/multiprecision/gmp.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
str	/usr/include/boost/multiprecision/mpfr.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
str	/usr/include/boost/multiprecision/number.hpp	/^   std::string str(std::streamsize digits = 0, std::ios_base::fmtflags f = std::ios_base::fmtflags(0))const$/;"	f	class:boost::multiprecision::number	access:public	signature:(std::streamsize digits = 0, std::ios_base::fmtflags f = std::ios_base::fmtflags(0)) const
str	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   std::string str(std::streamsize digits, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(std::streamsize digits, std::ios_base::fmtflags f) const
str	/usr/include/boost/multiprecision/tommath.hpp	/^   std::string str(std::streamsize \/*digits*\/, std::ios_base::fmtflags f)const$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(std::streamsize , std::ios_base::fmtflags f) const
sub_unsigned_long_long	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   cpp_dec_float& sub_unsigned_long_long(const unsigned long long n)  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(const unsigned long long n)
subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   subtract(number<B, ET>& result, const I& a, const I& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B, ET>& result, const I& a, const I& b)
subtract	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline number<B1, ET1>& subtract(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<B1, ET1>& result, const number<B2, ET2>& a, const number<B3, ET3>& b)
subtract	/usr/include/boost/multiprecision/integer.hpp	/^   subtract(Integer& result, const I2& a, const I2& b)$/;"	f	namespace:boost::multiprecision	signature:(Integer& result, const I2& a, const I2& b)
subtract	/usr/include/boost/multiprecision/random.hpp	/^struct subtract<boost::multiprecision::number<Backend, ExpressionTemplates>, true> $/;"	s	namespace:boost::random::detail
subtract_immediates	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct subtract_immediates{};$/;"	s	namespace:boost::multiprecision::detail
swap	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   void swap(number_backend_float_architype& o)$/;"	f	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public	signature:(number_backend_float_architype& o)
swap	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   void swap(cpp_dec_float& v) $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:(cpp_dec_float& v)
swap	/usr/include/boost/multiprecision/gmp.hpp	/^   void swap(gmp_int& o)$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:(gmp_int& o)
swap	/usr/include/boost/multiprecision/number.hpp	/^BOOST_MP_FORCEINLINE void swap(number<Backend, ExpressionTemplates>& a, number<Backend, ExpressionTemplates>& b)$/;"	f	namespace:boost::multiprecision	signature:(number<Backend, ExpressionTemplates>& a, number<Backend, ExpressionTemplates>& b)
swap	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   void swap(rational_adapter& o)$/;"	f	struct:boost::multiprecision::backends::rational_adapter	access:public	signature:(rational_adapter& o)
t1	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> t1;$/;"	t	struct:boost::multiprecision::backends::is_implicit_cpp_int_conversion	access:public
t2	/usr/include/boost/multiprecision/cpp_int.hpp	/^   typedef cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> t2;$/;"	t	struct:boost::multiprecision::backends::is_implicit_cpp_int_conversion	access:public
tag_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   >::type tag_type;$/;"	t	struct:boost::multiprecision::detail::canonical	access:public
tag_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef tag tag_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
tag_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef terminal tag_type;$/;"	t	struct:boost::multiprecision::detail::expression	access:public
terminal	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   terminal(){}$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:()
terminal	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   terminal(const R& v) : value(v){}$/;"	f	struct:boost::multiprecision::default_ops::terminal	access:public	signature:(const R& v)
terminal	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^struct terminal$/;"	s	namespace:boost::multiprecision::default_ops
terminal	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct terminal{};$/;"	s	namespace:boost::multiprecision::detail
tinyness_before	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    tinyness_before   = false;$/;"	m	class:std::numeric_limits	access:public
tinyness_before	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::tinyness_before;$/;"	m	class:std::numeric_limits
tinyness_before	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool tinyness_before = false;$/;"	m	class:std::numeric_limits	access:public
tinyness_before	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::tinyness_before;$/;"	m	class:std::numeric_limits
tinyness_before	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool tinyness_before = false;$/;"	m	class:std::numeric_limits	access:public
tinyness_before	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::tinyness_before;$/;"	m	class:std::numeric_limits
tom_int	/usr/include/boost/multiprecision/tommath.hpp	/^typedef number<tommath_int >                     tom_int;$/;"	t	namespace:boost::multiprecision
tom_rational	/usr/include/boost/multiprecision/tommath.hpp	/^typedef number<tommath_rational>                 tom_rational;$/;"	t	namespace:boost::multiprecision
tommath_int	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int()$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
tommath_int	/usr/include/boost/multiprecision/tommath.hpp	/^   tommath_int(const tommath_int& o)$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:(const tommath_int& o)
tommath_int	/usr/include/boost/multiprecision/tommath.hpp	/^struct tommath_int$/;"	s	namespace:boost::multiprecision::backends
tommath_rational	/usr/include/boost/multiprecision/tommath.hpp	/^typedef rational_adapter<tommath_int>               tommath_rational;$/;"	t	namespace:boost::multiprecision
tools	/usr/include/boost/multiprecision/detail/number_base.hpp	/^namespace boost{ namespace math{ namespace tools{$/;"	n	namespace:boost::math
traps	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^      BOOST_STATIC_CONSTEXPR bool                    traps             = false;$/;"	m	class:std::numeric_limits	access:public
traps	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_dec_float<Digits10, ExponentType, Allocator>, ExpressionTemplates> >::traps;$/;"	m	class:std::numeric_limits
traps	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^   BOOST_STATIC_CONSTEXPR bool traps = false;$/;"	m	class:std::numeric_limits	access:public
traps	/usr/include/boost/multiprecision/cpp_int/limits.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>, ExpressionTemplates>  >::traps;$/;"	m	class:std::numeric_limits
traps	/usr/include/boost/multiprecision/tommath.hpp	/^   BOOST_STATIC_CONSTEXPR bool traps = false;$/;"	m	class:std::numeric_limits	access:public
traps	/usr/include/boost/multiprecision/tommath.hpp	/^BOOST_CONSTEXPR_OR_CONST bool numeric_limits<boost::multiprecision::number<boost::multiprecision::tommath_int, ExpressionTemplates> >::traps;$/;"	m	class:std::numeric_limits
trunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline number<Backend, ExpressionTemplates> trunc(const number<Backend, ExpressionTemplates>& v, const Policy&)$/;"	f	namespace:boost::multiprecision	signature:(const number<Backend, ExpressionTemplates>& v, const Policy&)
trunc	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^inline typename detail::expression<tag, A1, A2, A3, A4>::result_type trunc(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)$/;"	f	namespace:boost::multiprecision	signature:(const detail::expression<tag, A1, A2, A3, A4>& v, const Policy& pol)
two	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& two()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
type	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef typename Allocator::template rebind<T>::other type;$/;"	t	struct:boost::multiprecision::backends::detail::rebind	access:public
type	/usr/include/boost/multiprecision/cpp_int.hpp	/^   >::type type;$/;"	t	struct:detail::double_precision_type	access:public
type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::largest_signed_type	access:public
type	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::largest_unsigned_type	access:public
type	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^      >::type type;$/;"	t	struct:boost::multiprecision::default_ops::calculate_next_larger_type	access:public
type	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   struct type : public mpl::and_<mpl::not_<is_same<R, T> >, mpl::bool_<std::numeric_limits<T>::digits >= b> >{};$/;"	s	struct:boost::multiprecision::default_ops::has_enough_bits	inherits:mpl::and_	access:public
type	/usr/include/boost/multiprecision/detail/integer_ops.hpp	/^   typedef Backend type;$/;"	t	struct:boost::multiprecision::detail::double_precision_type	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^      >::type type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   struct type : public mpl::bool_<bits_of<T>::value>= b>{};$/;"	s	struct:boost::multiprecision::detail::has_enough_bits	inherits:mpl::bool_,b	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef B type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef T type;$/;"	t	struct:boost::multiprecision::detail::backend_type	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef T* type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef const T& type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef const T* type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef const char* type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef expression<Tag, Arg1, Arg2, Arg3, Arg4> type;$/;"	t	struct:boost::multiprecision::detail::arg_type	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef expression<tag, A1, A2, A3, A4> type;$/;"	t	struct:boost::multiprecision::detail::expression_storage	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef expression<terminal, T> type;$/;"	t	struct:boost::multiprecision::detail::arg_type	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef number<T, ExpressionTemplates> type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef number<T1, ExpressionTemplates> type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef number<T2, ExpressionTemplates> type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename backend_type<typename expression<tag, A1, A2, A3, A4>::result_type>::type type;$/;"	t	struct:boost::multiprecision::detail::backend_type	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename boost::multiprecision::detail::expression<tag, A1, A2, A3, A4>::result_type type;$/;"	t	struct:boost::math::tools::promote_arg	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename canonical_imp<Val, Backend, tag_type>::type type;$/;"	t	struct:boost::multiprecision::detail::canonical	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename mpl::deref<iter_type>::type type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename mpl::if_c<(sizeof(T1() + T2()) == sizeof(T1)), T1, T2>::type type;$/;"	t	struct:boost::multiprecision::detail::combine_expression	access:public
type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   typedef typename remove_cv<typename decay<const Val>::type>::type type;$/;"	t	struct:boost::multiprecision::detail::canonical_imp	access:public
type	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef number<gmp_int> type;$/;"	t	struct:component_type	access:public
type	/usr/include/boost/multiprecision/random.hpp	/^    typedef new_uniform_01<boost::multiprecision::number<Backend, ExpressionTemplates> > type;$/;"	t	struct:boost::random::detail::select_uniform_01::apply	access:public
type	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef number<T> type;$/;"	t	struct:boost::multiprecision::component_type	access:public
type	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::has_generic_interconversion	access:public
type	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^   typedef boost::integral_constant<bool,value> type;$/;"	t	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public
type	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::is_lossy_conversion	access:public
type	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^   >::type type;$/;"	t	struct:boost::multiprecision::detail::is_restricted_conversion	access:public
ublas	/usr/include/boost/multiprecision/number.hpp	/^namespace numeric { namespace ublas {$/;"	n	namespace:boost::numeric
uint1024_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<1024, 1024, unsigned_magnitude, unchecked, void> > uint1024_t;$/;"	t
uint128_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<128, 128, unsigned_magnitude, unchecked, void> >   uint128_t;$/;"	t
uint256_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<256, 256, unsigned_magnitude, unchecked, void> >   uint256_t;$/;"	t
uint512_t	/usr/include/boost/multiprecision/cpp_int.hpp	/^typedef number<cpp_int_backend<512, 512, unsigned_magnitude, unchecked, void> >   uint512_t;$/;"	t
ulong_long_max	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& ulong_long_max()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
unchecked	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   unchecked = 0$/;"	e	enum:boost::multiprecision::cpp_int_check_type
uniform_smallint	/usr/include/boost/multiprecision/random.hpp	/^    explicit uniform_smallint(const param_type& parm)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(const param_type& parm)
uniform_smallint	/usr/include/boost/multiprecision/random.hpp	/^    explicit uniform_smallint(result_type const& min_arg = 0, result_type const& max_arg = 9)$/;"	f	class:boost::random::uniform_smallint	access:public	signature:(result_type const& min_arg = 0, result_type const& max_arg = 9)
uniform_smallint	/usr/include/boost/multiprecision/random.hpp	/^class uniform_smallint<boost::multiprecision::number<Backend, ExpressionTemplates> >$/;"	c	namespace:boost::random
unmentionable	/usr/include/boost/multiprecision/detail/number_base.hpp	/^struct unmentionable$/;"	s	namespace:boost::multiprecision::detail
unmentionable_type	/usr/include/boost/multiprecision/detail/number_base.hpp	/^typedef void (*unmentionable_type)();$/;"	t	namespace:boost::multiprecision::detail
unsigned_magnitude	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   unsigned_magnitude = 0,$/;"	e	enum:boost::multiprecision::cpp_integer_type
unsigned_packed	/usr/include/boost/multiprecision/cpp_int/cpp_int_config.hpp	/^   unsigned_packed = 2$/;"	e	enum:boost::multiprecision::cpp_integer_type
unsigned_types	/usr/include/boost/multiprecision/concepts/mp_number_archetypes.hpp	/^   typedef mpl::list<unsigned long long>        unsigned_types;$/;"	t	struct:boost::multiprecision::concepts::number_backend_float_architype	access:public
unsigned_types	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   typedef mpl::list<unsigned long long>  unsigned_types;$/;"	t	class:boost::multiprecision::backends::cpp_dec_float	access:public
unsigned_types	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef mpl::list<unsigned long, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::backends::detail::gmp_float_imp	access:public
unsigned_types	/usr/include/boost/multiprecision/gmp.hpp	/^   typedef mpl::list<unsigned long, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::gmp_int	access:public
unsigned_types	/usr/include/boost/multiprecision/mpfr.hpp	/^   typedef mpl::list<unsigned long, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::backends::detail::mpfr_float_imp	access:public
unsigned_types	/usr/include/boost/multiprecision/rational_adapter.hpp	/^   typedef typename IntBackend::unsigned_types  unsigned_types;$/;"	t	struct:boost::multiprecision::backends::rational_adapter	access:public
unsigned_types	/usr/include/boost/multiprecision/tommath.hpp	/^   typedef mpl::list<boost::uint32_t, unsigned long long>   unsigned_types;$/;"	t	struct:boost::multiprecision::backends::tommath_int	access:public
value	/usr/include/boost/multiprecision/cpp_int.hpp	/^   static const bool value = false;$/;"	m	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
value	/usr/include/boost/multiprecision/cpp_int.hpp	/^   static const bool value = is_void<Allocator>::value && (max_precision<self>::value <= (sizeof(double_limb_type) * CHAR_BIT) - (SignType == signed_packed ? 1 : 0));$/;"	m	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
value	/usr/include/boost/multiprecision/cpp_int.hpp	/^   static const bool value = true;$/;"	m	struct:boost::multiprecision::backends::is_trivial_cpp_int	access:public
value	/usr/include/boost/multiprecision/cpp_int.hpp	/^   static const bool value =$/;"	m	struct:boost::multiprecision::backends::is_implicit_cpp_int_conversion	access:public
value	/usr/include/boost/multiprecision/cpp_int.hpp	/^   static const expression_template_option value = et_off;$/;"	m	struct:expression_template_default	access:public
value	/usr/include/boost/multiprecision/cpp_int.hpp	/^   static const unsigned value = (is_void<Allocator>::value ? static_unsigned_max<MinBits, MaxBits>::value : MinBits);$/;"	m	struct:boost::multiprecision::backends::min_precision	access:public
value	/usr/include/boost/multiprecision/cpp_int.hpp	/^   static const unsigned value = is_void<Allocator>::value ?$/;"	m	struct:boost::multiprecision::backends::max_precision	access:public
value	/usr/include/boost/multiprecision/detail/default_ops.hpp	/^   R value;$/;"	m	struct:boost::multiprecision::default_ops::terminal	access:public
value	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const expression_template_option value = et_on;$/;"	m	struct:boost::multiprecision::expression_template_default	access:public
value	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const long value = std::numeric_limits<T>::radix == 10 ?  (((std::numeric_limits<T>::digits + 1) * 1000L) \/ 301L) : std::numeric_limits<T>::digits;$/;"	m	struct:boost::multiprecision::detail::digits2	access:public
value	/usr/include/boost/multiprecision/detail/number_base.hpp	/^   static const unsigned value =$/;"	m	struct:boost::multiprecision::detail::bits_of	access:public
value	/usr/include/boost/multiprecision/traits/explicit_conversion.hpp	/^   static const bool value = sizeof(selector<S,T>(0)) == sizeof(type_traits::yes_type);$/;"	m	struct:boost::multiprecision::detail::is_explicitly_convertible_imp	access:public
value	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^   static const bool value = type::value;$/;"	m	struct:boost::multiprecision::detail::is_lossy_conversion	access:public
value	/usr/include/boost/multiprecision/traits/is_restricted_conversion.hpp	/^   static const bool value = type::value;$/;"	m	struct:boost::multiprecision::detail::is_restricted_conversion	access:public
variable	/usr/include/boost/multiprecision/cpp_int.hpp	/^const bool cpp_int_base<MinBits, MaxBits, signed_magnitude, Checked, Allocator, false>::variable;$/;"	m	class:boost::multiprecision::cpp_int_base
verify_limb_mask	/usr/include/boost/multiprecision/cpp_int.hpp	/^inline void verify_limb_mask(bool \/*b*\/, U \/*limb*\/, U \/*mask*\/, const mpl::int_<unchecked>&){}$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(bool , U , U , const mpl::int_<unchecked>&)
verify_limb_mask	/usr/include/boost/multiprecision/cpp_int.hpp	/^inline void verify_limb_mask(bool b, U limb, U mask, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(bool b, U limb, U mask, const mpl::int_<checked>&)
verify_new_size	/usr/include/boost/multiprecision/cpp_int.hpp	/^      detail::verify_new_size(new_size, min_size, checked_type());$/;"	p	class:boost::multiprecision::backends::cpp_int_base::detail	access:public	signature:(new_size, min_size, checked_type())
verify_new_size	/usr/include/boost/multiprecision/cpp_int.hpp	/^inline void verify_new_size(unsigned \/*new_size*\/, unsigned \/*min_size*\/, const mpl::int_<unchecked>&){}$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(unsigned , unsigned , const mpl::int_<unchecked>&)
verify_new_size	/usr/include/boost/multiprecision/cpp_int.hpp	/^inline void verify_new_size(unsigned new_size, unsigned min_size, const mpl::int_<checked>&)$/;"	f	namespace:boost::multiprecision::backends::detail	signature:(unsigned new_size, unsigned min_size, const mpl::int_<checked>&)
zero	/usr/include/boost/multiprecision/cpp_dec_float.hpp	/^   static const cpp_dec_float& zero()  $/;"	f	class:boost::multiprecision::backends::cpp_dec_float	access:public	signature:()
~gmp_int	/usr/include/boost/multiprecision/gmp.hpp	/^   ~gmp_int()$/;"	f	struct:boost::multiprecision::gmp_int	access:public	signature:()
~tommath_int	/usr/include/boost/multiprecision/tommath.hpp	/^   ~tommath_int()$/;"	f	struct:boost::multiprecision::backends::tommath_int	access:public	signature:()
